function [fxi,si,di] = CAllocation_Fix(fi,fei,fxi,si,di,p,info)
% compute the fraction of NPP tto the diffe



cLeaf
cWood
cWoodSap
cWoodHard
cRoot
cRootFine
cRootCoarse





if sum(PRCT > 1) ~=0, PRCT = PRCT ./ 100; end

DO_FRAC = 1;

switch dynamic_allocation
    case 0
        [TREEFR, GRASSFR]   = calc_fixed_allocation(cinput, VGTP, DO_FRAC);
    case 1
        [TREEFR, GRASSFR]   = calc_dynamic_allocation(LAI, PET, PPTT, ...
                            AIRT, SOILM, WPT, FC, VGTP, DO_FRAC);
    otherwise
        error('Undifined allocation scheme');
end

% COMPUTE TOTAL VEGETATION FRACTIONS COMPONENTS
% this could be changed into grass and tree pools and then account for
% herbivory too... do it simple first and when validation data exists
% account for it.
% 
% when accounting for tree and grass together in fluxes the main issue is
% the constants turnover rates that are considered the same for both. this
% is an error. could we try to correct it a check the results?

if DO_FRAC 
	GRASSPRCT           = 1 - PRCT;
	BIOMEPRCT           = GRASSPRCT + PRCT; % NOT VERY GOOD! WE'RE ASSUMING THE 
                                            % TOTAL BIOME FRACTION IS 100%
                                            % AND NO BARE/URBAN/SNOW ARE
                                            % INVOLVED
	% FUNCTION OUTPUT
	VEGCALL(1).name     = 'ROOT';
	VEGCALL(1).value    = (TREEFR(1).value .* PRCT + GRASSFR(1).value .* ...
                        GRASSPRCT) ./ BIOMEPRCT;
	VEGCALL(2).name     = 'WOOD';
	VEGCALL(2).value    = TREEFR(2).value .* PRCT ./ BIOMEPRCT;
	VEGCALL(3).name     = 'LEAF';
	VEGCALL(3).value    = 1 - VEGCALL(1).value - VEGCALL(2).value;
else
    VEGCALL(1).name     = 'ROOT';
    VEGCALL(1).value     = TREEFR(1).value;
	VEGCALL(2).name     = 'WOOD';
    VEGCALL(2).value     = TREEFR(2).value;
	VEGCALL(3).name     = 'LEAF';
    VEGCALL(3).value     = TREEFR(3).value;
end

% CHECK COMPUTATION
T   = VEGCALL(1).value + VEGCALL(2).value + VEGCALL(3).value;

if ~isempty(find(T > 1 | T < 0, 1))
    error(['Bad allocation in ' num2str(numel(find(T > 1 | ...
        T < 0))) ' pixels.']);
end

for i = 1:numel(VEGCALL)
    if ~isempty(find(VEGCALL(i).value < 0 | VEGCALL(i).value > 1, 1))
        error(['Bad allocation in ' num2str(numel( ...
            VEGCALL(i).value < 0 | VEGCALL(i).value > 1)) ...
            ' pixels.']);
    end
end

% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
function [TREEFR, GRASSFR] = calc_dynamic_allocation(LAI, PET, PPTT, ...
    AIRT, SOILM, WPT, FC, VGTP, DO_FRAC)
% #########################################################################
% DINAMIC ALLOCATION: FRIEDLINGSTEIN ET AL., 1999
% #########################################################################

% constants
so  = 0.3;
ro  = 0.3;

% light limitation calculation
LL              = exp (-0.5 * LAI); 
LL(LL <= 0.1)	= 0.1;
LL(LL >= 1.0)   = 1.0;

% pseudo-nutrient limitation calculation
NUT             = zeros(size(LAI));
NUT(PET == 0)	= 0.1;
ndx             = find(PET > 0);
if ~isempty(ndx)
    PFACT               = PPTT(ndx) ./ PET(ndx);
    PFACT(PFACT >= 2)   = 5 - 2 .* PFACT(PFACT >= 2);
    PFACT(PFACT >= 1)   = 1;
    PFACT(PFACT <= 0.5)	= 0.5;
    TFACT               = 2 .^ ((AIRT(ndx) - 30) ./ 10);
    TFACT(TFACT >= 1)   = 1;
    TFACT(TFACT <= 0.5) = 0.5;
    NUT(ndx)            = PFACT .* TFACT;
end

NUT(NUT <= 0.1)	= 0.1;
NUT(NUT >= 1.0) = 1.0;

% water limitation calculation
WL              = (SOILM - WPT) ./ (FC - WPT);
WL(WL <= 0.1)   = 0.1;
WL(WL >= 1.0)   = 1.0;
WORN            = NUT;
WORN(WL < NUT)	= WL(WL < NUT);

% CREATE STRUCTURAL OUTPUT ARRAY
zt      = zeros(size(LAI));
TREEFR  = struct(...
    'name',     {'root', 'stem', 'leaf'}, ...
    'value',    {zt, zt, zt});
GRASSFR = TREEFR;

% TREEFR(1).name  = 'root';,  TREEFR(1).value     = zeros(size(LAI));
% TREEFR(2).name  = 'stem';,  TREEFR(2).value     = zeros(size(LAI));
% TREEFR(3).name  = 'leaf';,  TREEFR(3).value     = zeros(size(LAI));
% 
% GRASSFR(1).name = 'root';,  GRASSFR(1).value    = zeros(size(LAI));
% GRASSFR(2).name = 'stem';,  GRASSFR(2).value    = zeros(size(LAI));
% GRASSFR(3).name = 'leaf';,  GRASSFR(3).value    = zeros(size(LAI));

if DO_FRAC
	% FOR FRACTIONAL BIOMES
	TREEFR(1).value = ro .* 3 .* LL ./ (LL + 2 .* WORN);
	
	% DIFFERENCES BETWEEN GRASSLAND BIOMES AND OTHERS
	ndx = find(VGTP == 7 | VGTP == 10 | VGTP == 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = 0; end
	
	ndx = find(VGTP ~= 7 & VGTP ~= 10 & VGTP ~= 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = so .* 3 .* WORN(ndx) ./ ...
        (2 .* LL(ndx) + WORN(ndx)); end
	
	TREEFR(3).value     = 1 - TREEFR(1).value - TREEFR(2).value;
	GRASSFR(1).value    = TREEFR(1).value;
	GRASSFR(2).value(:) = 0;
	GRASSFR(3).value    = 1 - GRASSFR(1).value;
else
    % FOR THE SINGLE DOMINANT LAND COVER SCHEME
	ndx = find(VGTP == 7 | VGTP == 10 | VGTP == 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = 0; end
	
	ndx = find(VGTP ~= 7 & VGTP ~= 10 & VGTP ~= 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = so .* 3 .* WORN(ndx) ./ ...
        (2 .* LL(ndx) + WORN(ndx)); end
    
    TREEFR(1).value     = ro .* 3 .* LL ./ (LL + 2 .* WORN);
    TREEFR(3).value     = 1 - TREEFR(1).value - TREEFR(2).value;
end

% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
function [TREEFR, GRASSFR] = calc_fixed_allocation(cinput, VGTP, DO_FRAC)

% FIXED (LENGTH(VGTP), 3) - ROOT : STEM : LEAF
FIXED = get_lcprm(cinput, 'fixedallocation', VGTP);

% CREATE STRUCTURAL OUTPUT ARRAY
zt      = zeros(size(VGTP));
TREEFR  = struct(...
    'name',     {'root', 'stem', 'leaf'}, ...
    'value',    {zt, zt, zt});
GRASSFR = TREEFR;

% TREEFR(1).name  = 'root';, TREEFR(1).value  = zeros(size(VGTP));
% TREEFR(2).name  = 'stem';, TREEFR(2).value  = zeros(size(VGTP));
% TREEFR(3).name  = 'leaf';, TREEFR(3).value  = zeros(size(VGTP));
% 
% GRASSFR(1).name = 'root';, GRASSFR(1).value = zeros(size(VGTP));
% GRASSFR(2).name = 'stem';, GRASSFR(2).value = zeros(size(VGTP));
% GRASSFR(3).name = 'leaf';, GRASSFR(3).value = zeros(size(VGTP));

if DO_FRAC
	% FOR FRACTIONAL BIOMES
	GRASSFR(3).value    = FIXED(:, 3) ./ (FIXED(:, 3) + FIXED(:, 1));
	GRASSFR(1).value    = FIXED(:, 1) ./ (FIXED(:, 3) + FIXED(:, 1));
	GRASSFR(2).value(:) = 0;
	
	TREEFR(3).value     = FIXED(:, 3);
	TREEFR(1).value     = FIXED(:, 1);
	
	% DIFFERENCES BETWEEN GRASSLAND BIOMES AND OTHERS
	ndx = find(VGTP == 7 | VGTP == 10 | VGTP == 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = 0; end
	
	ndx = find(VGTP ~= 7 & VGTP ~= 10 & VGTP ~= 12);
	if ~isempty(ndx), TREEFR(2).value(ndx) = FIXED(ndx, 2); end
else
    % FOR THE SINGLE DOMINANT LAND COVER SCHEME
    TREEFR(1).value = FIXED(:, 1);
    TREEFR(2).value = FIXED(:, 2);
    TREEFR(3).value = FIXED(:, 3);
    
	% DIFFERENCES BETWEEN GRASSLAND BIOMES AND OTHERS
	ndx = find(VGTP == 7 | VGTP == 10 | VGTP == 12);
    if ~isempty(ndx)
        TREEFR(1).value(ndx)    = TREEFR(1).value(ndx) + ...
                                TREEFR(2).value(ndx) ./ 2;
        TREEFR(3).value(ndx)    = TREEFR(3).value(ndx) + ...
                                TREEFR(2).value(ndx) ./ 2;
        TREEFR(2).value(ndx)	= 0;
    end
end
