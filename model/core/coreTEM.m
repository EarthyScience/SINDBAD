function [f,fe,fx,s,d,p] = coreTEM(f,fe,fx,s,d,p,info)
% The core driver of SINDBAD TEM that loops through all the modules and
% runs time loop
%
% Requires:
%   - f: forcing
%   - fe: extra forcing precomputed outside time loop (exclusively out of runPreCompOnce)
%   - fx: structure with all fluxes
%   - s: structure with all state variables
%   - d: structure with all diagnostics
%   - p: structure with all parameters
%   - info: all additional information needed to run modules
%
% Purposes:
%   - runs all modules and fills the SINDBAD structures with simulation results
%
% Conventions:
%   - The modules are executed in the order called in the coreTEM 
%   - If order of call is to be changed, a copy of coreTEM should be created and corresponding path should be provided in modelStructure.json
%   - Default approach for each module is dummy (empty approach with no calculation)
%   - Other approaches should be set in modelStructure.json
%   - Through runCoreTEM.m
%       - If runGenCode is true, the generated version of precOnce and core with selected approaches per model are used
%       - If runGenCode is false, 
%           - original handles for coreTEM.m and
%   runPrecOnceTEM.m are used for forward run
%           - corresponding reduced versions, coreTEM4spinup.m and
%       runPrecOnceTEM4Spinup.m, 
%       are used for spinup
%           - NOTE THAT THESE FUNCTIONS AUTOMATICALLY TRACK CHANGES IN
%       coreTEM.m AND DO NOT NEED MODIFICATIONS WHEN coreTEM.M IS COPIED
%       AND CHANGED
%
% Created by:
%   - Nuno Carvalhais (ncarval)
%   - Martin Jung (mjung)
%   - Sujan Koirala (skoirala)
%
% References:
%
% Versions:
%   - 1.2 on 20.11.2019 : skoirala : multiple changes in name of modules
%   - 1.1 on 10.07.2018 : skoirala : cleanup and documentation
%   - 1.0 on 01.05.2018
%
%%
% -------------------------------------------------------------------------
% Do precomputations
% -------------------------------------------------------------------------
for prc = 1:numel(info.tem.model.code.prec)
    if info.tem.model.code.prec(prc).runAlways == 1
        [f,fe,fx,s,d,p]    = info.tem.model.code.prec(prc).funHandle(f,fe,fx,s,d,p,info);
    end
end
% -------------------------------------------------------------------------
% carbon and water processes over land
% -------------------------------------------------------------------------
% get the model structure generated by setupCode.m
% tstart = tic;
% disp(pad('-',200,'both','-'))
% disp([pad('TIME LOOP',20)  ' : ' pad('coreTEM',20) ' | Running the time loop of SINDBAD core'])
ms    = info.tem.model.code.ms;

% LOOP : loop through the whole length of of the forcing dataset
for tix = 1:info.tem.helpers.sizes.nTix
    % ---------------------------------------------------------------------
    % Climate: rainfall, snowfall, rainfall intensities, PET, ambCO2
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.rainSnow.funHandle(f,fe,fx,s,d,p,info,tix);          % set rain and snow to fe.rainSnow.
    [f,fe,fx,s,d,p]     =   ms.rainInt.funHandle(f,fe,fx,s,d,p,info,tix);           % set rainfall intensity
    [f,fe,fx,s,d,p]     =   ms.PET.funHandle(f,fe,fx,s,d,p,info,tix);               % set potential evapotranspiration
    [f,fe,fx,s,d,p]     =   ms.ambCO2.funHandle(f,fe,fx,s,d,p,info,tix);            % set/get ambient CO2 concentration
    % ---------------------------------------------------------------------
    % Get variables for previous time step and keep in s.prev. or d.prev
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.getStates.funHandle(f,fe,fx,s,d,p,info,tix);         % get the amount of water at the beginning of timestep
    % ---------------------------------------------------------------------
    % Terrain: terrain/topography params   
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.pTopo.funHandle(f,fe,fx,s,d,p,info,tix);             % topographic properties
    % ---------------------------------------------------------------------
    % Soil properties: texture, hydr. params, distribution per soil layers
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.soilTexture.funHandle(f,fe,fx,s,d,p,info,tix);       % soil texture (sand,silt,clay, and organic matter fraction)
    [f,fe,fx,s,d,p]     =   ms.pSoil.funHandle(f,fe,fx,s,d,p,info,tix);             % soil properties (hydraulic properties)
    [f,fe,fx,s,d,p]     =   ms.wSoilBase.funHandle(f,fe,fx,s,d,p,info,tix);         % distribution of soil hydraulic properties over depth
    % ---------------------------------------------------------------------
    % Root properties: root depth and distribution
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.rootMaxD.funHandle(f,fe,fx,s,d,p,info,tix);          % maximum rooting depth
    [f,fe,fx,s,d,p]     =   ms.rootFrac.funHandle(f,fe,fx,s,d,p,info,tix);          % distribution of maximum water uptake by root per soil layer
    % ---------------------------------------------------------------------
    % Veg. properties: structural, phenology, disturbances, LULCC, etc.
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.pVeg.funHandle(f,fe,fx,s,d,p,info,tix);              % vegetation/structural properties
    [f,fe,fx,s,d,p]     =   ms.fAPAR.funHandle(f,fe,fx,s,d,p,info,tix);             % fraction of Absorbed Photosynthetically Active Radiation
    [f,fe,fx,s,d,p]     =   ms.EVI.funHandle(f,fe,fx,s,d,p,info,tix);               % EVI
    [f,fe,fx,s,d,p]     =   ms.LAI.funHandle(f,fe,fx,s,d,p,info,tix);               % leaf area index
    [f,fe,fx,s,d,p]     =   ms.NDVI.funHandle(f,fe,fx,s,d,p,info,tix);               % NDVI
    [f,fe,fx,s,d,p]     =   ms.NIRv.funHandle(f,fe,fx,s,d,p,info,tix);               % NIRv
    [f,fe,fx,s,d,p]     =   ms.NDWI.funHandle(f,fe,fx,s,d,p,info,tix);               % NDWI
    
    [f,fe,fx,s,d,p]     =   ms.vegFrac.funHandle(f,fe,fx,s,d,p,info,tix);           % fractional coverage of vegetation
    % ---------------------------------------------------------------------
    % Snow processes
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.wSnowFrac.funHandle(f,fe,fx,s,d,p,info,tix);         % calculate snow cover fraction
    [f,fe,fx,s,d,p]     =   ms.evapSub.funHandle(f,fe,fx,s,d,p,info,tix);           % calculate sublimation and update snow water equivalent
    [f,fe,fx,s,d,p]     =   ms.snowMelt.funHandle(f,fe,fx,s,d,p,info,tix);          % calculate snowmelt and update s.w.wSnow
    % ---------------------------------------------------------------------
    % Water fluxes: runoff and evaporation processes 
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.evapInt.funHandle(f,fe,fx,s,d,p,info,tix);           % interception evaporation
    [f,fe,fx,s,d,p]     =   ms.roInf.funHandle(f,fe,fx,s,d,p,info,tix);             % infiltration excess runoff
    [f,fe,fx,s,d,p]     =   ms.wSoilSatFrac.funHandle(f,fe,fx,s,d,p,info,tix);      % saturated fraction of a grid cell
    [f,fe,fx,s,d,p]     =   ms.roSat.funHandle(f,fe,fx,s,d,p,info,tix);             % saturation runoff
    [f,fe,fx,s,d,p]     =   ms.roInt.funHandle(f,fe,fx,s,d,p,info,tix);             % interflow
    [f,fe,fx,s,d,p]     =   ms.roOverland.funHandle(f,fe,fx,s,d,p,info,tix);        % land over flow (sum of saturation and infiltration excess runoff)
                                                                                    % if e.g. infiltration excess runoff and or saturation runoff are not
                                                                                    % explicitly modelled then assign a none handle that returnes zeros and
                                                                                    % lump the FastRunoff into interflow
    [f,fe,fx,s,d,p]     =   ms.roSurf.funHandle(f,fe,fx,s,d,p,info,tix);            % runoff from surface water storages
    [f,fe,fx,s,d,p]     =   ms.wSoilPerc.funHandle(f,fe,fx,s,d,p,info,tix);         % calculate the soil percolation = WBP at this point
    [f,fe,fx,s,d,p]     =   ms.evapSoil.funHandle(f,fe,fx,s,d,p,info,tix);          % soil evaporation
    [f,fe,fx,s,d,p]     =   ms.wSoilRec.funHandle(f,fe,fx,s,d,p,info,tix);          % recharge the soil
    [f,fe,fx,s,d,p]     =   ms.gwRec.funHandle(f,fe,fx,s,d,p,info,tix);             % recharge the groundwater
    % ---------------------------------------------------------------------
    % Water transfer: upward flow from GW through soil
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.wGW2wSoil.funHandle(f,fe,fx,s,d,p,info,tix);         % Groundwater soil moisture interactions (e.g. capilary flux, water
    [f,fe,fx,s,d,p]     =   ms.wSoilUpflow.funHandle(f,fe,fx,s,d,p,info,tix);       % Flux of water from lower to upper soil layers (upward soil moisture movement)
    [f,fe,fx,s,d,p]     =   ms.wGW2wSurf.funHandle(f,fe,fx,s,d,p,info,tix);         % water exchange between surface and groundwater
                                                                                    % table in root zone etc)
    [f,fe,fx,s,d,p]     =   ms.roBase.funHandle(f,fe,fx,s,d,p,info,tix);            % baseflow

    % ---------------------------------------------------------------------
    % Water-carbon processes: demand and supply GPP and transpiration
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.pawAct.funHandle(f,fe,fx,s,d,p,info,tix);            % plant available water
    [f,fe,fx,s,d,p]     =   ms.gppPot.funHandle(f,fe,fx,s,d,p,info,tix);            % maximum instantaneous radiation use efficiency
    [f,fe,fx,s,d,p]     =   ms.gppfRdiff.funHandle(f,fe,fx,s,d,p,info,tix);         % effect of diffuse radiation
    [f,fe,fx,s,d,p]     =   ms.gppfRdir.funHandle(f,fe,fx,s,d,p,info,tix);          % effect of direct radiation
    [f,fe,fx,s,d,p]     =   ms.gppfTair.funHandle(f,fe,fx,s,d,p,info,tix);          % effect of temperature
    [f,fe,fx,s,d,p]     =   ms.gppfVPD.funHandle(f,fe,fx,s,d,p,info,tix);           % VPD effect
    [f,fe,fx,s,d,p]     =   ms.gppDem.funHandle(f,fe,fx,s,d,p,info,tix);            % combine effects as multiplicative or minimum
    [f,fe,fx,s,d,p]     =   ms.gppfwSoil.funHandle(f,fe,fx,s,d,p,info,tix);         % GPP as a function of wSoil; should be set to none if coupled with transpiration    
    % ---------------------------------------------------------------------
    % Water-carbon interaction: GPP, transpiration, and water uptake
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.tranDem.funHandle(f,fe,fx,s,d,p,info,tix);           % demand-driven Transpiration
    [f,fe,fx,s,d,p]     =   ms.tranSup.funHandle(f,fe,fx,s,d,p,info,tix);           % supply-limited Transpiration
    [f,fe,fx,s,d,p]     =   ms.WUE.funHandle(f,fe,fx,s,d,p,info,tix);               % estimate WUE
    [f,fe,fx,s,d,p]     =   ms.gppAct.funHandle(f,fe,fx,s,d,p,info,tix);            % combine effects as multiplicative or minimum; if coupled, uses tranSup    
    [f,fe,fx,s,d,p]     =   ms.tranAct.funHandle(f,fe,fx,s,d,p,info,tix);           % if coupled, computed from GPP and AOE from WUE
    [f,fe,fx,s,d,p]     =   ms.wRootUptake.funHandle(f,fe,fx,s,d,p,info,tix);       % root water uptake (extract water from soil)
    % ---------------------------------------------------------------------
    % Climate + additional effects: carbon metabolic processes
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cCycleBase.funHandle(f,fe,fx,s,d,p,info,tix);        % pool structure of the carbon cycle
    [f,fe,fx,s,d,p]     =   ms.cTaufTsoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil temperature on decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufwSoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil moisture on decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufLAI.funHandle(f,fe,fx,s,d,p,info,tix);          % calculate litterfall scalars (that affect the changes in the vegetation k)
    [f,fe,fx,s,d,p]     =   ms.cTaufpSoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil texture on soil decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufpVeg.funHandle(f,fe,fx,s,d,p,info,tix);         % effect of vegetation properties on soil decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTauAct.funHandle(f,fe,fx,s,d,p,info,tix);           % combine effects of different factors on decomposition rates
    [f,fe,fx,s,d,p]     =   ms.rafTair.funHandle(f,fe,fx,s,d,p,info,tix);           % temperature effect on autotrophic maintenance respiration
    % ---------------------------------------------------------------------
    % Climate + additional effects: carbon allocation to plant organs
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cAllocfLAI.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of LAI on carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAllocfRad.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of radiation on carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAllocfwSoil.funHandle(f,fe,fx,s,d,p,info,tix);      % effect of soil moisture on carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAllocfTsoil.funHandle(f,fe,fx,s,d,p,info,tix);      % effect of soil temperature on carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAllocfNut.funHandle(f,fe,fx,s,d,p,info,tix);        % (pseudo)effect of nutrients on carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAlloc.funHandle(f,fe,fx,s,d,p,info,tix);            % combine the different effects of carbon allocation 
    [f,fe,fx,s,d,p]     =   ms.cAllocfTreeFrac.funHandle(f,fe,fx,s,d,p,info,tix);  % adjustment of carbon allocation according to tree cover
    % ---------------------------------------------------------------------
    % Autotrophic respiration
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =    ms.raAct.funHandle(f,fe,fx,s,d,p,info,tix);            % determine growth and maintenance respiration -> NPP
    % ---------------------------------------------------------------------
    % Carbon transfers: among different carbon pools
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cFlowfpSoil.funHandle(f,fe,fx,s,d,p,info,tix);       % effect of soil properties on the C transfers between pools
    [f,fe,fx,s,d,p]     =   ms.cFlowfpVeg.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of vegetation properties on the C transfers between pools
    [f,fe,fx,s,d,p]     =   ms.cFlowAct.funHandle(f,fe,fx,s,d,p,info,tix);          % actual transfers of C between pools (of diagonal components)
    [f,fe,fx,s,d,p]     =   ms.cCycleConsistency.funHandle(f,fe,fx,s,d,p,info,tix); % consistency checks on the C allocation and transfers between pools
    [f,fe,fx,s,d,p]     =   ms.cCycle.funHandle(f,fe,fx,s,d,p,info,tix);            % allocate carbon to vegetation components
                                                                                    % litterfall and litter scalars
                                                                                    % calculate carbon cycle/decomposition/respiration in soil
    % ---------------------------------------------------------------------
    % sum up components (fluxes/states), river routing, and water balance
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.sumVariables.funHandle(f,fe,fx,s,d,p,info,tix);      % sum variables (through modelRun.json)
    [f,fe,fx,s,d,p]     =   ms.riverRouting.funHandle(f,fe,fx,s,d,p,info,tix);      % routing of runoff through river networks
    [f,fe,fx,s,d,p]     =   ms.wBalance.funHandle(f,fe,fx,s,d,p,info,tix);          % calculate the water balance    
    % ---------------------------------------------------------------------
    % Store the time series of selected state variables
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.keepStates.funHandle(f,fe,fx,s,d,p,info,tix);        % keep states from previous time step to s.prev    
    [f,fe,fx,s,d,p]     =   ms.storeStates.funHandle(f,fe,fx,s,d,p,info,tix);       % store the full time series of selected state variables
end
% disp([pad('TIME LOOP',20)  ' : ' pad('coreTEM',20) ' | Completed the time loop of SINDBAD core | Total Time Needed: ' sec2som(toc(tstart))]) 
end
