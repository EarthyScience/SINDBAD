function [f,fe,fx,s,d,p] = coreTEM_baselineT(f,fe,fx,s,d,p,info)
% The core driver of SINDBAD TEM that loops through all the modules and
% runs time loop
%
% Requires:
%   - f: dorcing fe,fx,s,d,p,info)
%   - fe: extra forcing precomputed outside time loop (exclusively out of runPreCompOnce
%   - fx: structure with all fluxes
%   - s: structure with all state variables
%   - d: structure with all diagnostics
%   - p: structure with all parameters
%   - info: all additional information needed to run modules
%
% Purposes:
%   - runs all modules and fills the SINDBAD structures with simulation results
%
% Conventions:
%   - The modules are executed in the order called in the coreTEM
%   - If order of call are to be changed, a copy of coreTEM should be created and corresponding path should be provided in modelStructure.json
%   - Default approach for each module is dummy (empty approach with no calculation)
%   - Other approaches should be set in modelStructure.json
%   - Through runCoreTEM.m
%       - If runGenCode is true, the generated version of precOnce and core with selected approaches per model are used
%       - If runGenCode is false,
%           - original handles for coreTEM.m and
%   runPrecOnceTEM.m are used for forward run
%           - corresponding reduced versions, coreTEM4spinup.m and
%       runPrecOnceTEM4Spinup.m,
%       are used for spinup
%           - NOTE THAT THESE FUNCTIONS AUTOMATICALLY TRACK CHANGES IN
%       coreTEM.m AND DO NOT NEED MODIFICATIONS WHEN coreTEM.M IS COPIED
%       AND CHANGED
%
% Created by:
%   - Nuno Carvalhais (ncarval@bgc-jena.mpg.de)
%   - Martin Jung (mjung@bgc-jena.mpg.de)
%   - Sujan Koirala (skoirala@bgc-jena.mpg.de)
%   - Tina Trautmann (ttraut@bgc-jena.mpg.de)
%
% References:
%
% Versions:
%   - 1.2 on 24.09.2018 : adding new modules
%   - 1.1 on 10.07.2018 : cleanup and documentation
%   - 1.0 on 01.05.2018
%
% Temp Notes:
%   - A) In this code, we should use the following strategy, e.g. for ET: if ET is not a forcing (~exist('f.ET','var'))
%     compute ET
%   - for ET and GPP - this allows us to force the model with different datastreams
%   - B) from 1->3 depends on the WAI flags (which we should start calling the
%   - C) check mass balance in all different calculations (at each iteration or in the end? In the end: saves time)
%   - D) don't forget to output the stressors for the spinup inside thediagnostics structure (d) to be used in the calc_cflux_fast

%%
% -------------------------------------------------------------------------
% Do precomputations
% -------------------------------------------------------------------------
for prc = 1:numel(info.tem.model.code.prec)
    if info.tem.model.code.prec(prc).runAlways == 1
        [f,fe,fx,s,d,p]	= info.tem.model.code.prec(prc).funHandle(f,fe,fx,s,d,p,info);
    end
end

% -------------------------------------------------------------------------
% CARBON AND WATER FLUXES ON LAND
% -------------------------------------------------------------------------
% get the model structure generated by setupCode.m
ms	= info.tem.model.code.ms;

% LOOP : loop through the whole length of of the forcing dataset
for tix = 1:info.tem.helpers.sizes.nTix
    [f,fe,fx,s,d,p]     =   ms.getStates.funHandle(f,fe,fx,s,d,p,info,tix);         % get states from previous time step
    % ---------------------------------------------------------------------
    % 0 - Terrain - to get the terrain params ...
    % 0 - SOIL - to get the soil related params ...
    % 0 - VEG - put here any LC changes / phenology / disturbances / ...
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.pTopo.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.pSoil.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.pVeg.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.cLAI.funHandle(f,fe,fx,s,d,p,info,tix);
    % ---------------------------------------------------------------------
    % 1 - Snow
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.wSnowFrac.funHandle(f,fe,fx,s,d,p,info,tix);            % add snow fall and calculate SnowCoverFraction
    [f,fe,fx,s,d,p]     =   ms.EvapSub.funHandle(f,fe,fx,s,d,p,info,tix);           % calculate sublimation and update swe
    [f,fe,fx,s,d,p]     =   ms.Qsnow.funHandle(f,fe,fx,s,d,p,info,tix);              % calculate snowmelt and update SWE
    % ---------------------------------------------------------------------
    % 2 - Water
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.EvapInt.funHandle(f,fe,fx,s,d,p,info,tix);           % interception evaporation
    [f,fe,fx,s,d,p]     =   ms.QinfExc.funHandle(f,fe,fx,s,d,p,info,tix);           % infiltration excess runoff
    [f,fe,fx,s,d,p]     =   ms.wSoilSatFrac.funHandle(f,fe,fx,s,d,p,info,tix);        % saturation runoff
    [f,fe,fx,s,d,p]     =   ms.Qsat.funHandle(f,fe,fx,s,d,p,info,tix);              % saturation runoff
    [f,fe,fx,s,d,p]     =   ms.wSoilRec.funHandle(f,fe,fx,s,d,p,info,tix);        % recharge the soil
    [f,fe,fx,s,d,p]     =   ms.Qint.funHandle(f,fe,fx,s,d,p,info,tix);              % interflow
    [f,fe,fx,s,d,p]     =   ms.QoverFlow.funHandle(f,fe,fx,s,d,p,info,tix);         % land over flow (sum of saturation and infiltration excess runoff)
                                                                                    % if e.g. infiltration excess runoff and or saturation runoff are not
                                                                                    % explicitly modelled then assign a dummy handle that returnes zeros and
                                                                                    % lump the FastRunoff into interflow
    [f,fe,fx,s,d,p]     =   ms.wSurfRec.funHandle(f,fe,fx,s,d,p,info,tix);        % recharge to surface water storages
    [f,fe,fx,s,d,p]     =   ms.QsurfDir.funHandle(f,fe,fx,s,d,p,info,tix);          % direct surface runoff
    [f,fe,fx,s,d,p]     =   ms.QsurfIndir.funHandle(f,fe,fx,s,d,p,info,tix);        % runoff from surface water storages
    [f,fe,fx,s,d,p]     =   ms.wGWRec.funHandle(f,fe,fx,s,d,p,info,tix);          % recharge the groundwater
    [f,fe,fx,s,d,p]     =   ms.Qbase.funHandle(f,fe,fx,s,d,p,info,tix);             % baseflow
    [f,fe,fx,s,d,p]     =   ms.wGW2wSoil.funHandle(f,fe,fx,s,d,p,info,tix);         % Groundwater soil moisture interactions (e.g. capilary flux, water
                                                                                    % table in root zone etc)
    [f,fe,fx,s,d,p]     =   ms.EvapSoil.funHandle(f,fe,fx,s,d,p,info,tix);          % soil evaporation
    % ---------------------------------------------------------------------
    % 3 - Transpiration and GPP
    % ---------------------------------------------------------------------
	  [f,fe,fx,s,d,p]     =   ms.WUE.funHandle(f,fe,fx,s,d,p,info,tix);               % estimate WUE
    [f,fe,fx,s,d,p]     =   ms.TranfwSoil.funHandle(f,fe,fx,s,d,p,info,tix);        % supply limited Transpiration
    [f,fe,fx,s,d,p]     =   ms.GPPpot.funHandle(f,fe,fx,s,d,p,info,tix);            % maximum instantaneous radiation use efficiency
    [f,fe,fx,s,d,p]     =   ms.GPPfRdiff.funHandle(f,fe,fx,s,d,p,info,tix);          % compute 'stress' scalars
    [f,fe,fx,s,d,p]     =   ms.GPPfRdir.funHandle(f,fe,fx,s,d,p,info,tix);          % compute 'stress' scalars
    [f,fe,fx,s,d,p]     =   ms.GPPfTair.funHandle(f,fe,fx,s,d,p,info,tix);          % effect of temperature
    [f,fe,fx,s,d,p]     =   ms.GPPfVPD.funHandle(f,fe,fx,s,d,p,info,tix);           % VPD effect
    [f,fe,fx,s,d,p]     =   ms.GPPdem.funHandle(f,fe,fx,s,d,p,info,tix);            % combine effects as multiplicative or minimum
    [f,fe,fx,s,d,p]     =   ms.GPPfwSoil.funHandle(f,fe,fx,s,d,p,info,tix);         % if 'coupled' requires access to iwue param
    [f,fe,fx,s,d,p]     =   ms.GPPact.funHandle(f,fe,fx,s,d,p,info,tix);            % combine effects as multiplicative or minimum
    [f,fe,fx,s,d,p]     =   ms.TranAct.funHandle(f,fe,fx,s,d,p,info,tix);           % if coupled computed from GPP
    [f,fe,fx,s,d,p]     =   ms.wRootUptake.funHandle(f,fe,fx,s,d,p,info,tix);       % root water uptake (extract water from soil)
    % ---------------------------------------------------------------------
    % 4 - Climate and other effects on metabolic processes
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cCycleBase.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.cTaufTsoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil temperature on decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufwSoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil moisture on decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufLAI.funHandle(f,fe,fx,s,d,p,info,tix);          % calculate litterfall scalars (that affect the changes in the vegetation k
    [f,fe,fx,s,d,p]     =   ms.cTaufpSoil.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of soil texture on soil decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTaufpVeg.funHandle(f,fe,fx,s,d,p,info,tix);         % effect of vegetation properties on soil decomposition rates
    [f,fe,fx,s,d,p]     =   ms.cTauAct.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.RAfTair.funHandle(f,fe,fx,s,d,p,info,tix);           % temperature effect on autotrophic maintenance respiration
    % ---------------------------------------------------------------------
    % 5 - Allocation of C within plant organs
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cAllocfLAI.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of LAI on carbon allocation
    [f,fe,fx,s,d,p]     =   ms.cAllocfwSoil.funHandle(f,fe,fx,s,d,p,info,tix);      % effect of soil moisture on carbon allocation
    [f,fe,fx,s,d,p]     =   ms.cAllocfTsoil.funHandle(f,fe,fx,s,d,p,info,tix);      % effect of soil temperature on carbon allocation
    [f,fe,fx,s,d,p]     =   ms.cAllocfNut.funHandle(f,fe,fx,s,d,p,info,tix);        % (pseudo)effect of nutrients on carbon allocation
    [f,fe,fx,s,d,p]     =   ms.cAlloc.funHandle(f,fe,fx,s,d,p,info,tix);            % combine the different effects of carbon allocation
    [f,fe,fx,s,d,p]     =   ms.cAllocfTreeCover.funHandle(f,fe,fx,s,d,p,info,tix);  % adjustment of carbon allocation according to tree cover
    % ---------------------------------------------------------------------
    % 6 - Autotrophic respiration
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =    ms.RAact.funHandle(f,fe,fx,s,d,p,info,tix);             % determine growth and maintenance respiration -> NPP
    % ---------------------------------------------------------------------
    % 7 - Carbon transfers to soil pools
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.cFlowfpSoil.funHandle(f,fe,fx,s,d,p,info,tix);       % effect of soil texture on transfer between C pools
    [f,fe,fx,s,d,p]     =   ms.cFlowfpVeg.funHandle(f,fe,fx,s,d,p,info,tix);        % effect of vegetation properties on transfer between C pools
    [f,fe,fx,s,d,p]     =   ms.cFlowAct.funHandle(f,fe,fx,s,d,p,info,tix);
    [f,fe,fx,s,d,p]     =   ms.cCycle.funHandle(f,fe,fx,s,d,p,info,tix);            % allocate carbon to vegetation components
                                                                                    % litterfall and litter scalars
                                                                                    % calculate carbon cycle/decomposition/respiration in soil
    [f,fe,fx,s,d,p]     =   ms.wSoilUpflow.funHandle(f,fe,fx,s,d,p,info,tix);       % Flux of water from lower to upper soil layers (upward soil moisture movement)
    [f,fe,fx,s,d,p]     =   ms.wGWUpflow.funHandle(f,fe,fx,s,d,p,info,tix);         % Flux of water from wGW to the lowermost soil layers (upward GW capillary flux)
    % Gather all variables that are desired and insert them
    
    % in fx,s,d
    % ---------------------------------------------------------------------
     [f,fe,fx,s,d,p]	= ms.storeStates.funHandle(f,fe,fx,s,d,p,info,tix);         % store current states in previous state variables


end

    % ---------------------------------------------------------------------
    % sum up components of fluxes and states
    % ---------------------------------------------------------------------
    [f,fe,fx,s,d,p]     =   ms.wTotal.funHandle(f,fe,fx,s,d,p,info,tix);                  % add water storages to their sum
    [f,fe,fx,s,d,p]     =   ms.QTotal.funHandle(f,fe,fx,s,d,p,info,tix);                % add runoff components to their sum
    [f,fe,fx,s,d,p]     =   ms.EvapTotal.funHandle(f,fe,fx,s,d,p,info,tix);             % add evapotranspiration components to their sum
    % ---------------------------------------------------------------------


end
