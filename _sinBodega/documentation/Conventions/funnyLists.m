c.nameSize = {'Veg',1;'Soil',1}[flags,nPools] = genFlagsPools(c.nameSize)c.nameSize = {'Veg.Leaf',4;'Veg.Wood',2;'Veg.Root',5;'Soil.Fast',3;'Soil.Slow',2}[flags,nPools] = genFlagsPools(c.nameSize)% w.nameSize = {'Snow',5;'SoilMoisture',7;'GroundWater',22}% [flags,nPools] = genFlagsPools(w.nameSize)% c.nameSize = {'Veg',1;'xVeg',1}% [flags,nPools] = genFlagsPools(c.nameSize)function [flags,nPools] = genFlagsPools(nameSize)% check that the names are unique : we can just let it go too...if numel(unique(nameSize(:,1)))~=size(nameSize,1)    error('ERR : getFlagsPools : pool names are not unique')end% number of poolsnPools      = sum([nameSize{:,2}]);ndxPools    = [0 cumsum([nameSize{:,2}])];% flags (logical vectors in the structureflags = struct;for i = 1:size(nameSize,1)    pName       = nameSize{i,1};    fullName    = '';    while ~isempty(pName)        [fName, pName]  = strtok(pName, '.');        pName           = strrep(pName,'.','');        fullName        = [fullName fName];        if~isfield(flags,fullName)            flags.(fullName) = false(1,nPools);        end        flags.(fullName)(ndxPools(i)+1:ndxPools(i+1)) = true;    endendend