import{_ as d,C as a,c as p,o as f,j as l,aA as u,a as o,G as e,w as i}from"./chunks/framework.CB6YZlnI.js";const tu=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/code/models.md","filePath":"pages/code/models.md","lastUpdated":null}'),g={name:"pages/code/models.md"},m={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},y={class:"details custom-block"},c={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},S={class:"details custom-block"},w={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},x={class:"details custom-block"},C={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},A={class:"details custom-block"},P={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},W={class:"details custom-block"},D={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},O={class:"details custom-block"},B={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},U={class:"details custom-block"},J={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},H={class:"details custom-block"},q={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},h={class:"details custom-block"},_={class:"jldocstring custom-block",open:""},ll={class:"jldocstring custom-block",open:""},nl={class:"jldocstring custom-block",open:""},ol={class:"details custom-block"},el={class:"jldocstring custom-block",open:""},tl={class:"jldocstring custom-block",open:""},il={class:"jldocstring custom-block",open:""},sl={class:"jldocstring custom-block",open:""},ul={class:"jldocstring custom-block",open:""},rl={class:"details custom-block"},al={class:"jldocstring custom-block",open:""},dl={class:"jldocstring custom-block",open:""},pl={class:"jldocstring custom-block",open:""},fl={class:"details custom-block"},gl={class:"jldocstring custom-block",open:""},ml={class:"jldocstring custom-block",open:""},bl={class:"jldocstring custom-block",open:""},yl={class:"jldocstring custom-block",open:""},cl={class:"jldocstring custom-block",open:""},vl={class:"details custom-block"},kl={class:"jldocstring custom-block",open:""},Sl={class:"jldocstring custom-block",open:""},wl={class:"jldocstring custom-block",open:""},Tl={class:"details custom-block"},jl={class:"jldocstring custom-block",open:""},El={class:"jldocstring custom-block",open:""},xl={class:"jldocstring custom-block",open:""},Cl={class:"details custom-block"},Ml={class:"jldocstring custom-block",open:""},Il={class:"jldocstring custom-block",open:""},Al={class:"jldocstring custom-block",open:""},Pl={class:"jldocstring custom-block",open:""},Rl={class:"jldocstring custom-block",open:""},Vl={class:"details custom-block"},Wl={class:"jldocstring custom-block",open:""},Dl={class:"jldocstring custom-block",open:""},Fl={class:"jldocstring custom-block",open:""},Nl={class:"jldocstring custom-block",open:""},Ol={class:"jldocstring custom-block",open:""},Bl={class:"details custom-block"},Gl={class:"jldocstring custom-block",open:""},Ll={class:"jldocstring custom-block",open:""},zl={class:"jldocstring custom-block",open:""},Ul={class:"jldocstring custom-block",open:""},Jl={class:"jldocstring custom-block",open:""},Kl={class:"details custom-block"},Hl={class:"jldocstring custom-block",open:""},ql={class:"jldocstring custom-block",open:""},Zl={class:"details custom-block"},Ql={class:"jldocstring custom-block",open:""},Yl={class:"jldocstring custom-block",open:""},Xl={class:"jldocstring custom-block",open:""},$l={class:"jldocstring custom-block",open:""},hl={class:"details custom-block"},_l={class:"jldocstring custom-block",open:""},ln={class:"jldocstring custom-block",open:""},nn={class:"jldocstring custom-block",open:""},on={class:"jldocstring custom-block",open:""},en={class:"details custom-block"},tn={class:"jldocstring custom-block",open:""},sn={class:"jldocstring custom-block",open:""},un={class:"jldocstring custom-block",open:""},rn={class:"jldocstring custom-block",open:""},an={class:"jldocstring custom-block",open:""},dn={class:"jldocstring custom-block",open:""},pn={class:"details custom-block"},fn={class:"jldocstring custom-block",open:""},gn={class:"jldocstring custom-block",open:""},mn={class:"details custom-block"},bn={class:"jldocstring custom-block",open:""},yn={class:"jldocstring custom-block",open:""},cn={class:"jldocstring custom-block",open:""},vn={class:"details custom-block"},kn={class:"jldocstring custom-block",open:""},Sn={class:"jldocstring custom-block",open:""},wn={class:"jldocstring custom-block",open:""},Tn={class:"jldocstring custom-block",open:""},jn={class:"jldocstring custom-block",open:""},En={class:"details custom-block"},xn={class:"jldocstring custom-block",open:""},Cn={class:"jldocstring custom-block",open:""},Mn={class:"jldocstring custom-block",open:""},In={class:"details custom-block"},An={class:"jldocstring custom-block",open:""},Pn={class:"jldocstring custom-block",open:""},Rn={class:"jldocstring custom-block",open:""},Vn={class:"details custom-block"},Wn={class:"jldocstring custom-block",open:""},Dn={class:"jldocstring custom-block",open:""},Fn={class:"jldocstring custom-block",open:""},Nn={class:"details custom-block"},On={class:"jldocstring custom-block",open:""},Bn={class:"jldocstring custom-block",open:""},Gn={class:"jldocstring custom-block",open:""},Ln={class:"details custom-block"},zn={class:"jldocstring custom-block",open:""},Un={class:"jldocstring custom-block",open:""},Jn={class:"jldocstring custom-block",open:""},Kn={class:"details custom-block"},Hn={class:"jldocstring custom-block",open:""},qn={class:"jldocstring custom-block",open:""},Zn={class:"jldocstring custom-block",open:""},Qn={class:"details custom-block"},Yn={class:"jldocstring custom-block",open:""},Xn={class:"jldocstring custom-block",open:""},$n={class:"jldocstring custom-block",open:""},hn={class:"jldocstring custom-block",open:""},_n={class:"details custom-block"},lo={class:"jldocstring custom-block",open:""},no={class:"jldocstring custom-block",open:""},oo={class:"jldocstring custom-block",open:""},eo={class:"details custom-block"},to={class:"jldocstring custom-block",open:""},io={class:"jldocstring custom-block",open:""},so={class:"details custom-block"},uo={class:"jldocstring custom-block",open:""},ro={class:"jldocstring custom-block",open:""},ao={class:"details custom-block"},po={class:"jldocstring custom-block",open:""},fo={class:"jldocstring custom-block",open:""},go={class:"details custom-block"},mo={class:"jldocstring custom-block",open:""},bo={class:"jldocstring custom-block",open:""},yo={class:"details custom-block"},co={class:"jldocstring custom-block",open:""},vo={class:"jldocstring custom-block",open:""},ko={class:"jldocstring custom-block",open:""},So={class:"jldocstring custom-block",open:""},wo={class:"details custom-block"},To={class:"jldocstring custom-block",open:""},jo={class:"jldocstring custom-block",open:""},Eo={class:"jldocstring custom-block",open:""},xo={class:"jldocstring custom-block",open:""},Co={class:"jldocstring custom-block",open:""},Mo={class:"jldocstring custom-block",open:""},Io={class:"jldocstring custom-block",open:""},Ao={class:"details custom-block"},Po={class:"jldocstring custom-block",open:""},Ro={class:"jldocstring custom-block",open:""},Vo={class:"details custom-block"},Wo={class:"jldocstring custom-block",open:""},Do={class:"jldocstring custom-block",open:""},Fo={class:"jldocstring custom-block",open:""},No={class:"jldocstring custom-block",open:""},Oo={class:"jldocstring custom-block",open:""},Bo={class:"jldocstring custom-block",open:""},Go={class:"jldocstring custom-block",open:""},Lo={class:"jldocstring custom-block",open:""},zo={class:"details custom-block"},Uo={class:"jldocstring custom-block",open:""},Jo={class:"jldocstring custom-block",open:""},Ko={class:"details custom-block"},Ho={class:"jldocstring custom-block",open:""},qo={class:"jldocstring custom-block",open:""},Zo={class:"jldocstring custom-block",open:""},Qo={class:"jldocstring custom-block",open:""},Yo={class:"jldocstring custom-block",open:""},Xo={class:"jldocstring custom-block",open:""},$o={class:"details custom-block"},ho={class:"jldocstring custom-block",open:""},_o={class:"jldocstring custom-block",open:""},le={class:"jldocstring custom-block",open:""},ne={class:"jldocstring custom-block",open:""},oe={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},se={class:"details custom-block"},ue={class:"jldocstring custom-block",open:""},re={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""},de={class:"jldocstring custom-block",open:""},pe={class:"details custom-block"},fe={class:"jldocstring custom-block",open:""},ge={class:"jldocstring custom-block",open:""},me={class:"jldocstring custom-block",open:""},be={class:"jldocstring custom-block",open:""},ye={class:"jldocstring custom-block",open:""},ce={class:"details custom-block"},ve={class:"jldocstring custom-block",open:""},ke={class:"jldocstring custom-block",open:""},Se={class:"jldocstring custom-block",open:""},we={class:"details custom-block"},Te={class:"jldocstring custom-block",open:""},je={class:"jldocstring custom-block",open:""},Ee={class:"details custom-block"},xe={class:"jldocstring custom-block",open:""},Ce={class:"jldocstring custom-block",open:""},Me={class:"jldocstring custom-block",open:""},Ie={class:"jldocstring custom-block",open:""},Ae={class:"jldocstring custom-block",open:""},Pe={class:"jldocstring custom-block",open:""},Re={class:"details custom-block"},Ve={class:"jldocstring custom-block",open:""},We={class:"jldocstring custom-block",open:""},De={class:"jldocstring custom-block",open:""},Fe={class:"jldocstring custom-block",open:""},Ne={class:"jldocstring custom-block",open:""},Oe={class:"jldocstring custom-block",open:""},Be={class:"details custom-block"},Ge={class:"jldocstring custom-block",open:""},Le={class:"jldocstring custom-block",open:""},ze={class:"jldocstring custom-block",open:""},Ue={class:"jldocstring custom-block",open:""},Je={class:"jldocstring custom-block",open:""},Ke={class:"details custom-block"},He={class:"jldocstring custom-block",open:""},qe={class:"jldocstring custom-block",open:""},Ze={class:"jldocstring custom-block",open:""},Qe={class:"jldocstring custom-block",open:""},Ye={class:"jldocstring custom-block",open:""},Xe={class:"details custom-block"},$e={class:"jldocstring custom-block",open:""},he={class:"jldocstring custom-block",open:""},_e={class:"jldocstring custom-block",open:""},lt={class:"details custom-block"},nt={class:"jldocstring custom-block",open:""},ot={class:"jldocstring custom-block",open:""},et={class:"jldocstring custom-block",open:""},tt={class:"jldocstring custom-block",open:""},it={class:"jldocstring custom-block",open:""},st={class:"details custom-block"},ut={class:"jldocstring custom-block",open:""},rt={class:"jldocstring custom-block",open:""},at={class:"details custom-block"},dt={class:"jldocstring custom-block",open:""},pt={class:"jldocstring custom-block",open:""},ft={class:"jldocstring custom-block",open:""},gt={class:"details custom-block"},mt={class:"jldocstring custom-block",open:""},bt={class:"jldocstring custom-block",open:""},yt={class:"jldocstring custom-block",open:""},ct={class:"details custom-block"},vt={class:"jldocstring custom-block",open:""},kt={class:"jldocstring custom-block",open:""},St={class:"jldocstring custom-block",open:""},wt={class:"jldocstring custom-block",open:""},Tt={class:"details custom-block"},jt={class:"jldocstring custom-block",open:""},Et={class:"jldocstring custom-block",open:""},xt={class:"details custom-block"},Ct={class:"jldocstring custom-block",open:""},Mt={class:"jldocstring custom-block",open:""},It={class:"jldocstring custom-block",open:""},At={class:"jldocstring custom-block",open:""},Pt={class:"jldocstring custom-block",open:""},Rt={class:"jldocstring custom-block",open:""},Vt={class:"details custom-block"},Wt={class:"jldocstring custom-block",open:""},Dt={class:"jldocstring custom-block",open:""},Ft={class:"jldocstring custom-block",open:""},Nt={class:"details custom-block"},Ot={class:"jldocstring custom-block",open:""},Bt={class:"jldocstring custom-block",open:""},Gt={class:"details custom-block"},Lt={class:"jldocstring custom-block",open:""},zt={class:"jldocstring custom-block",open:""},Ut={class:"jldocstring custom-block",open:""},Jt={class:"details custom-block"},Kt={class:"jldocstring custom-block",open:""},Ht={class:"jldocstring custom-block",open:""},qt={class:"jldocstring custom-block",open:""},Zt={class:"jldocstring custom-block",open:""},Qt={class:"details custom-block"},Yt={class:"jldocstring custom-block",open:""},Xt={class:"jldocstring custom-block",open:""},$t={class:"jldocstring custom-block",open:""},ht={class:"details custom-block"},_t={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},ti={class:"details custom-block"},ii={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},fi={class:"jldocstring custom-block",open:""},gi={class:"jldocstring custom-block",open:""},mi={class:"details custom-block"},bi={class:"jldocstring custom-block",open:""},yi={class:"jldocstring custom-block",open:""},ci={class:"jldocstring custom-block",open:""},vi={class:"jldocstring custom-block",open:""},ki={class:"jldocstring custom-block",open:""},Si={class:"jldocstring custom-block",open:""},wi={class:"jldocstring custom-block",open:""},Ti={class:"jldocstring custom-block",open:""},ji={class:"details custom-block"},Ei={class:"jldocstring custom-block",open:""},xi={class:"jldocstring custom-block",open:""},Ci={class:"details custom-block"},Mi={class:"jldocstring custom-block",open:""},Ii={class:"jldocstring custom-block",open:""},Ai={class:"jldocstring custom-block",open:""},Pi={class:"jldocstring custom-block",open:""},Ri={class:"details custom-block"},Vi={class:"jldocstring custom-block",open:""},Wi={class:"jldocstring custom-block",open:""},Di={class:"jldocstring custom-block",open:""},Fi={class:"details custom-block"},Ni={class:"jldocstring custom-block",open:""},Oi={class:"jldocstring custom-block",open:""},Bi={class:"jldocstring custom-block",open:""},Gi={class:"details custom-block"},Li={class:"jldocstring custom-block",open:""},zi={class:"jldocstring custom-block",open:""},Ui={class:"jldocstring custom-block",open:""},Ji={class:"details custom-block"},Ki={class:"jldocstring custom-block",open:""},Hi={class:"jldocstring custom-block",open:""},qi={class:"jldocstring custom-block",open:""},Zi={class:"jldocstring custom-block",open:""},Qi={class:"jldocstring custom-block",open:""},Yi={class:"details custom-block"},Xi={class:"jldocstring custom-block",open:""},$i={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},_i={class:"details custom-block"},ls={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ts={class:"details custom-block"},is={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ds={class:"details custom-block"},ps={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ys={class:"details custom-block"},cs={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},Ss={class:"details custom-block"},ws={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},Es={class:"details custom-block"},xs={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},Ws={class:"details custom-block"},Ds={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Os={class:"details custom-block"},Bs={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Ls={class:"details custom-block"},zs={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""};function $s(hs,n,_s,lu,nu,ou){const t=a("Badge"),s=a("PluginTabsTab"),r=a("PluginTabs");return f(),p("div",null,[l("details",m,[l("summary",null,[n[0]||(n[0]=l("a",{id:"Sindbad.Models",href:"#Sindbad.Models"},[l("span",{class:"jlbinding"},"Sindbad.Models")],-1)),n[1]||(n[1]=o()),e(t,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),n[2]||(n[2]=u("",15))]),n[4550]||(n[4550]=l("h2",{id:"Available-Models",tabindex:"-1"},[o("Available Models "),l("a",{class:"header-anchor",href:"#Available-Models","aria-label":'Permalink to "Available Models {#Available-Models}"'},"​")],-1)),n[4551]||(n[4551]=l("h3",{id:"EVI",tabindex:"-1"},[o("EVI "),l("a",{class:"header-anchor",href:"#EVI","aria-label":'Permalink to "EVI {#EVI}"'},"​")],-1)),l("details",b,[l("summary",null,[n[3]||(n[3]=l("a",{id:"Sindbad.Models.EVI",href:"#Sindbad.Models.EVI"},[l("span",{class:"jlbinding"},"Sindbad.Models.EVI")],-1)),n[4]||(n[4]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[5]||(n[5]=u("",4))]),l("details",y,[n[40]||(n[40]=l("summary",null,"EVI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"EVI_constant"},{default:i(()=>[l("details",c,[l("summary",null,[n[6]||(n[6]=l("a",{id:"Sindbad.Models.EVI_constant",href:"#Sindbad.Models.EVI_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.EVI_constant")],-1)),n[7]||(n[7]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[8]||(n[8]=l("p",null,"Sets EVI as a constant value.",-1)),n[9]||(n[9]=l("p",null,[l("strong",null,"Parameters")],-1)),n[10]||(n[10]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_EVI"),o(": 1.0 ∈ [0.0, 1.0] => EVI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[11]||(n[11]=l("p",null,[l("strong",null,"Methods:")],-1)),n[12]||(n[12]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[13]||(n[13]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.EVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :EVI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[14]||(n[14]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[15]||(n[15]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"EVI_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[16]||(n[16]=l("hr",null,null,-1)),n[17]||(n[17]=l("p",null,[l("strong",null,"Extended help")],-1)),n[18]||(n[18]=l("p",null,[l("em",null,"References")],-1)),n[19]||(n[19]=l("p",null,[l("em",null,"Versions")],-1)),n[20]||(n[20]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[21]||(n[21]=l("p",null,[l("em",null,"Created by")],-1)),n[22]||(n[22]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"EVI_forcing"},{default:i(()=>[l("details",v,[l("summary",null,[n[23]||(n[23]=l("a",{id:"Sindbad.Models.EVI_forcing",href:"#Sindbad.Models.EVI_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.EVI_forcing")],-1)),n[24]||(n[24]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[25]||(n[25]=l("p",null,"Gets EVI from forcing data.",-1)),n[26]||(n[26]=l("p",null,[l("strong",null,"Parameters")],-1)),n[27]||(n[27]=l("ul",null,[l("li",null,"None")],-1)),n[28]||(n[28]=l("p",null,[l("strong",null,"Methods:")],-1)),n[29]||(n[29]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[30]||(n[30]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_EVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_EVI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.EVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :EVI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[31]||(n[31]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[32]||(n[32]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"EVI_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[33]||(n[33]=l("hr",null,null,-1)),n[34]||(n[34]=l("p",null,[l("strong",null,"Extended help")],-1)),n[35]||(n[35]=l("p",null,[l("em",null,"References")],-1)),n[36]||(n[36]=l("p",null,[l("em",null,"Versions")],-1)),n[37]||(n[37]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[38]||(n[38]=l("p",null,[l("em",null,"Created by")],-1)),n[39]||(n[39]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4552]||(n[4552]=l("hr",null,null,-1)),n[4553]||(n[4553]=l("h3",{id:"LAI",tabindex:"-1"},[o("LAI "),l("a",{class:"header-anchor",href:"#LAI","aria-label":'Permalink to "LAI {#LAI}"'},"​")],-1)),l("details",k,[l("summary",null,[n[41]||(n[41]=l("a",{id:"Sindbad.Models.LAI",href:"#Sindbad.Models.LAI"},[l("span",{class:"jlbinding"},"Sindbad.Models.LAI")],-1)),n[42]||(n[42]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[43]||(n[43]=u("",4))]),l("details",S,[n[95]||(n[95]=l("summary",null,"LAI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"LAI_cVegLeaf"},{default:i(()=>[l("details",w,[l("summary",null,[n[44]||(n[44]=l("a",{id:"Sindbad.Models.LAI_cVegLeaf",href:"#Sindbad.Models.LAI_cVegLeaf"},[l("span",{class:"jlbinding"},"Sindbad.Models.LAI_cVegLeaf")],-1)),n[45]||(n[45]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[46]||(n[46]=l("p",null,"LAI as a function of cVegLeaf and SLA.",-1)),n[47]||(n[47]=l("p",null,[l("strong",null,"Parameters")],-1)),n[48]||(n[48]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"SLA"),o(": 0.016 ∈ [0.01, 0.024] => specific leaf area (units: "),l("code",null,"m^2.gC^-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[49]||(n[49]=l("p",null,[l("strong",null,"Methods:")],-1)),n[50]||(n[50]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[51]||(n[51]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.LAI"),o(": leaf area index")])])])],-1)),n[52]||(n[52]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[53]||(n[53]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"LAI_cVegLeaf.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[54]||(n[54]=l("hr",null,null,-1)),n[55]||(n[55]=l("p",null,[l("strong",null,"Extended help")],-1)),n[56]||(n[56]=l("p",null,[l("em",null,"References")],-1)),n[57]||(n[57]=l("p",null,[l("em",null,"Versions")],-1)),n[58]||(n[58]=l("ul",null,[l("li",null,"1.0 on 05.05.2020 [sbesnard]")],-1)),n[59]||(n[59]=l("p",null,[l("em",null,"Created by")],-1)),n[60]||(n[60]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"LAI_constant"},{default:i(()=>[l("details",T,[l("summary",null,[n[61]||(n[61]=l("a",{id:"Sindbad.Models.LAI_constant",href:"#Sindbad.Models.LAI_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.LAI_constant")],-1)),n[62]||(n[62]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[63]||(n[63]=l("p",null,"sets LAI as a constant value.",-1)),n[64]||(n[64]=l("p",null,[l("strong",null,"Parameters")],-1)),n[65]||(n[65]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_LAI"),o(": 3.0 ∈ [1.0, 12.0] => LAI (units: "),l("code",null,"m2/m2"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[66]||(n[66]=l("p",null,[l("strong",null,"Methods:")],-1)),n[67]||(n[67]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[68]||(n[68]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.LAI"),o(": leaf area index")])])])],-1)),n[69]||(n[69]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[70]||(n[70]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"LAI_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[71]||(n[71]=l("hr",null,null,-1)),n[72]||(n[72]=l("p",null,[l("strong",null,"Extended help")],-1)),n[73]||(n[73]=l("p",null,[l("em",null,"References")],-1)),n[74]||(n[74]=l("p",null,[l("em",null,"Versions")],-1)),n[75]||(n[75]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[76]||(n[76]=l("p",null,[l("em",null,"Created by")],-1)),n[77]||(n[77]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"LAI_forcing"},{default:i(()=>[l("details",j,[l("summary",null,[n[78]||(n[78]=l("a",{id:"Sindbad.Models.LAI_forcing",href:"#Sindbad.Models.LAI_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.LAI_forcing")],-1)),n[79]||(n[79]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[80]||(n[80]=l("p",null,"Gets LAI from forcing data.",-1)),n[81]||(n[81]=l("p",null,[l("strong",null,"Parameters")],-1)),n[82]||(n[82]=l("ul",null,[l("li",null,"None")],-1)),n[83]||(n[83]=l("p",null,[l("strong",null,"Methods:")],-1)),n[84]||(n[84]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[85]||(n[85]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_LAI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_LAI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.LAI"),o(": leaf area index")])])])],-1)),n[86]||(n[86]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[87]||(n[87]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"LAI_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[88]||(n[88]=l("hr",null,null,-1)),n[89]||(n[89]=l("p",null,[l("strong",null,"Extended help")],-1)),n[90]||(n[90]=l("p",null,[l("em",null,"References")],-1)),n[91]||(n[91]=l("p",null,[l("em",null,"Versions")],-1)),n[92]||(n[92]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: moved LAI from land.LAI.LAI to land.states.LAI")],-1)),n[93]||(n[93]=l("p",null,[l("em",null,"Created by")],-1)),n[94]||(n[94]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4554]||(n[4554]=l("hr",null,null,-1)),n[4555]||(n[4555]=l("h3",{id:"NDVI",tabindex:"-1"},[o("NDVI "),l("a",{class:"header-anchor",href:"#NDVI","aria-label":'Permalink to "NDVI {#NDVI}"'},"​")],-1)),l("details",E,[l("summary",null,[n[96]||(n[96]=l("a",{id:"Sindbad.Models.NDVI",href:"#Sindbad.Models.NDVI"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDVI")],-1)),n[97]||(n[97]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[98]||(n[98]=u("",4))]),l("details",x,[n[133]||(n[133]=l("summary",null,"NDVI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"NDVI_constant"},{default:i(()=>[l("details",C,[l("summary",null,[n[99]||(n[99]=l("a",{id:"Sindbad.Models.NDVI_constant",href:"#Sindbad.Models.NDVI_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDVI_constant")],-1)),n[100]||(n[100]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[101]||(n[101]=l("p",null,"Sets NDVI as a constant value.",-1)),n[102]||(n[102]=l("p",null,[l("strong",null,"Parameters")],-1)),n[103]||(n[103]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_NDVI"),o(": 1.0 ∈ [0.0, 1.0] => NDVI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[104]||(n[104]=l("p",null,[l("strong",null,"Methods:")],-1)),n[105]||(n[105]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[106]||(n[106]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NDVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NDVI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[107]||(n[107]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[108]||(n[108]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NDVI_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[109]||(n[109]=l("hr",null,null,-1)),n[110]||(n[110]=l("p",null,[l("strong",null,"Extended help")],-1)),n[111]||(n[111]=l("p",null,[l("em",null,"References")],-1)),n[112]||(n[112]=l("p",null,[l("em",null,"Versions")],-1)),n[113]||(n[113]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]: new module")],-1)),n[114]||(n[114]=l("p",null,[l("em",null,"Created by")],-1)),n[115]||(n[115]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"NDVI_forcing"},{default:i(()=>[l("details",M,[l("summary",null,[n[116]||(n[116]=l("a",{id:"Sindbad.Models.NDVI_forcing",href:"#Sindbad.Models.NDVI_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDVI_forcing")],-1)),n[117]||(n[117]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[118]||(n[118]=l("p",null,"Gets NDVI from forcing data.",-1)),n[119]||(n[119]=l("p",null,[l("strong",null,"Parameters")],-1)),n[120]||(n[120]=l("ul",null,[l("li",null,"None")],-1)),n[121]||(n[121]=l("p",null,[l("strong",null,"Methods:")],-1)),n[122]||(n[122]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[123]||(n[123]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_NDVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_NDVI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NDVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NDVI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[124]||(n[124]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[125]||(n[125]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NDVI_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[126]||(n[126]=l("hr",null,null,-1)),n[127]||(n[127]=l("p",null,[l("strong",null,"Extended help")],-1)),n[128]||(n[128]=l("p",null,[l("em",null,"References")],-1)),n[129]||(n[129]=l("p",null,[l("em",null,"Versions")],-1)),n[130]||(n[130]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]")],-1)),n[131]||(n[131]=l("p",null,[l("em",null,"Created by")],-1)),n[132]||(n[132]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1})]),_:1})]),n[4556]||(n[4556]=l("hr",null,null,-1)),n[4557]||(n[4557]=l("h3",{id:"NDWI",tabindex:"-1"},[o("NDWI "),l("a",{class:"header-anchor",href:"#NDWI","aria-label":'Permalink to "NDWI {#NDWI}"'},"​")],-1)),l("details",I,[l("summary",null,[n[134]||(n[134]=l("a",{id:"Sindbad.Models.NDWI",href:"#Sindbad.Models.NDWI"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDWI")],-1)),n[135]||(n[135]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[136]||(n[136]=u("",4))]),l("details",A,[n[171]||(n[171]=l("summary",null,"NDWI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"NDWI_constant"},{default:i(()=>[l("details",P,[l("summary",null,[n[137]||(n[137]=l("a",{id:"Sindbad.Models.NDWI_constant",href:"#Sindbad.Models.NDWI_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDWI_constant")],-1)),n[138]||(n[138]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[139]||(n[139]=l("p",null,"Sets NDWI as a constant value.",-1)),n[140]||(n[140]=l("p",null,[l("strong",null,"Parameters")],-1)),n[141]||(n[141]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_NDWI"),o(": 1.0 ∈ [0.0, 1.0] => NDWI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[142]||(n[142]=l("p",null,[l("strong",null,"Methods:")],-1)),n[143]||(n[143]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[144]||(n[144]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NDWI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NDWI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[145]||(n[145]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[146]||(n[146]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NDWI_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[147]||(n[147]=l("hr",null,null,-1)),n[148]||(n[148]=l("p",null,[l("strong",null,"Extended help")],-1)),n[149]||(n[149]=l("p",null,[l("em",null,"References")],-1)),n[150]||(n[150]=l("p",null,[l("em",null,"Versions")],-1)),n[151]||(n[151]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]: new module")],-1)),n[152]||(n[152]=l("p",null,[l("em",null,"Created by")],-1)),n[153]||(n[153]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"NDWI_forcing"},{default:i(()=>[l("details",R,[l("summary",null,[n[154]||(n[154]=l("a",{id:"Sindbad.Models.NDWI_forcing",href:"#Sindbad.Models.NDWI_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.NDWI_forcing")],-1)),n[155]||(n[155]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[156]||(n[156]=l("p",null,"Gets NDWI from forcing data.",-1)),n[157]||(n[157]=l("p",null,[l("strong",null,"Parameters")],-1)),n[158]||(n[158]=l("ul",null,[l("li",null,"None")],-1)),n[159]||(n[159]=l("p",null,[l("strong",null,"Methods:")],-1)),n[160]||(n[160]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[161]||(n[161]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_NDWI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_NDWI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NDWI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NDWI)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[162]||(n[162]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[163]||(n[163]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NDWI_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[164]||(n[164]=l("hr",null,null,-1)),n[165]||(n[165]=l("p",null,[l("strong",null,"Extended help")],-1)),n[166]||(n[166]=l("p",null,[l("em",null,"References")],-1)),n[167]||(n[167]=l("p",null,[l("em",null,"Versions")],-1)),n[168]||(n[168]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]")],-1)),n[169]||(n[169]=l("p",null,[l("em",null,"Created by")],-1)),n[170]||(n[170]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1})]),_:1})]),n[4558]||(n[4558]=l("hr",null,null,-1)),n[4559]||(n[4559]=l("h3",{id:"NIRv",tabindex:"-1"},[o("NIRv "),l("a",{class:"header-anchor",href:"#NIRv","aria-label":'Permalink to "NIRv {#NIRv}"'},"​")],-1)),l("details",V,[l("summary",null,[n[172]||(n[172]=l("a",{id:"Sindbad.Models.NIRv",href:"#Sindbad.Models.NIRv"},[l("span",{class:"jlbinding"},"Sindbad.Models.NIRv")],-1)),n[173]||(n[173]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[174]||(n[174]=u("",4))]),l("details",W,[n[209]||(n[209]=l("summary",null,"NIRv approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"NIRv_constant"},{default:i(()=>[l("details",D,[l("summary",null,[n[175]||(n[175]=l("a",{id:"Sindbad.Models.NIRv_constant",href:"#Sindbad.Models.NIRv_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.NIRv_constant")],-1)),n[176]||(n[176]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[177]||(n[177]=l("p",null,"Sets NIRv as a constant value.",-1)),n[178]||(n[178]=l("p",null,[l("strong",null,"Parameters")],-1)),n[179]||(n[179]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_NIRv"),o(": 1.0 ∈ [0.0, 1.0] => NIRv ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[180]||(n[180]=l("p",null,[l("strong",null,"Methods:")],-1)),n[181]||(n[181]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[182]||(n[182]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NIRv"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NIRv)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[183]||(n[183]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[184]||(n[184]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NIRv_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[185]||(n[185]=l("hr",null,null,-1)),n[186]||(n[186]=l("p",null,[l("strong",null,"Extended help")],-1)),n[187]||(n[187]=l("p",null,[l("em",null,"References")],-1)),n[188]||(n[188]=l("p",null,[l("em",null,"Versions")],-1)),n[189]||(n[189]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]: new module")],-1)),n[190]||(n[190]=l("p",null,[l("em",null,"Created by")],-1)),n[191]||(n[191]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"NIRv_forcing"},{default:i(()=>[l("details",F,[l("summary",null,[n[192]||(n[192]=l("a",{id:"Sindbad.Models.NIRv_forcing",href:"#Sindbad.Models.NIRv_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.NIRv_forcing")],-1)),n[193]||(n[193]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[194]||(n[194]=l("p",null,"Gets NIRv from forcing data.",-1)),n[195]||(n[195]=l("p",null,[l("strong",null,"Parameters")],-1)),n[196]||(n[196]=l("ul",null,[l("li",null,"None")],-1)),n[197]||(n[197]=l("p",null,[l("strong",null,"Methods:")],-1)),n[198]||(n[198]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[199]||(n[199]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_NIRv"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_NIRv)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NIRv"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NIRv)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[200]||(n[200]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[201]||(n[201]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"NIRv_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[202]||(n[202]=l("hr",null,null,-1)),n[203]||(n[203]=l("p",null,[l("strong",null,"Extended help")],-1)),n[204]||(n[204]=l("p",null,[l("em",null,"References")],-1)),n[205]||(n[205]=l("p",null,[l("em",null,"Versions")],-1)),n[206]||(n[206]=l("ul",null,[l("li",null,"1.0 on 29.04.2020 [sbesnard]")],-1)),n[207]||(n[207]=l("p",null,[l("em",null,"Created by")],-1)),n[208]||(n[208]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1})]),_:1})]),n[4560]||(n[4560]=l("hr",null,null,-1)),n[4561]||(n[4561]=l("h3",{id:"PET",tabindex:"-1"},[o("PET "),l("a",{class:"header-anchor",href:"#PET","aria-label":'Permalink to "PET {#PET}"'},"​")],-1)),l("details",N,[l("summary",null,[n[210]||(n[210]=l("a",{id:"Sindbad.Models.PET",href:"#Sindbad.Models.PET"},[l("span",{class:"jlbinding"},"Sindbad.Models.PET")],-1)),n[211]||(n[211]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[212]||(n[212]=u("",4))]),l("details",O,[n[268]||(n[268]=l("summary",null,"PET approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"PET_Lu2005"},{default:i(()=>[l("details",B,[l("summary",null,[n[213]||(n[213]=l("a",{id:"Sindbad.Models.PET_Lu2005",href:"#Sindbad.Models.PET_Lu2005"},[l("span",{class:"jlbinding"},"Sindbad.Models.PET_Lu2005")],-1)),n[214]||(n[214]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[215]||(n[215]=l("p",null,"Calculates PET using Lu et al. (2005) method.",-1)),n[216]||(n[216]=l("p",null,[l("strong",null,"Parameters")],-1)),n[217]||(n[217]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 1.26 ∈ [0.1, 2.0] => calibration constant: α = 1.26 for wet or humid ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"svp_1"),o(": 0.2 ∈ [-Inf, Inf] => saturation vapor pressure temperature curve parameter 1 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"svp_2"),o(": 0.00738 ∈ [-Inf, Inf] => saturation vapor pressure temperature curve parameter 2 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"svp_3"),o(": 0.8072 ∈ [-Inf, Inf] => saturation vapor pressure temperature curve parameter 3 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"svp_4"),o(": 7.0 ∈ [-Inf, Inf] => saturation vapor pressure temperature curve parameter 4 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"svp_5"),o(": 0.000116 ∈ [-Inf, Inf] => saturation vapor pressure temperature curve parameter 5 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sh_cp"),o(": 0.001013 ∈ [-Inf, Inf] => specific heat of moist air at constant pressure (1.013 kJ/kg/°C) (units: "),l("code",null,"MJ/kg/°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"elev"),o(": 0.0 ∈ [0.0, 8848.0] => elevation (units: "),l("code",null,"m"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"pres_sl"),o(": 101.29 ∈ [0.0, 101.3] => atmospheric pressure at sea level (units: "),l("code",null,"kpa"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"pres_elev"),o(": 0.01055 ∈ [-Inf, Inf] => rate of change of atmospheric pressure with elevation (units: "),l("code",null,"kpa/m"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"λ_base"),o(": 2.501 ∈ [-Inf, Inf] => latent heat of vaporization (units: "),l("code",null,"MJ/kg"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"λ_airT"),o(": 0.002361 ∈ [-Inf, Inf] => rate of change of latent heat of vaporization with temperature (units: "),l("code",null,"MJ/kg/°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"γ_resistance"),o(": 0.622 ∈ [-Inf, Inf] => ratio of canopy resistance to atmospheric resistance ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Δt"),o(": 2.0 ∈ [-Inf, Inf] => time delta for calculation of G (units: "),l("code",null,"day"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"G_base"),o(": 4.2 ∈ [-Inf, Inf] => base groundheat flux ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[218]||(n[218]=l("p",null,[l("strong",null,"Methods:")],-1)),n[219]||(n[219]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[220]||(n[220]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"states.Tair_prev"),o(": air temperature in the previous time step")])])])])],-1)),n[221]||(n[221]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[222]||(n[222]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rn"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rn)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.Tair_prev"),o(": air temperature in the previous time step")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"states.Tair_prev"),o(": air temperature in the previous time step")])])])])],-1)),n[223]||(n[223]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[224]||(n[224]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"PET_Lu2005.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[225]||(n[225]=l("hr",null,null,-1)),n[226]||(n[226]=l("p",null,[l("strong",null,"Extended help")],-1)),n[227]||(n[227]=l("p",null,[l("em",null,"References")],-1)),n[228]||(n[228]=l("ul",null,[l("li",null,"Lu")],-1)),n[229]||(n[229]=l("p",null,[l("em",null,"Versions")],-1)),n[230]||(n[230]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[231]||(n[231]=l("p",null,[l("em",null,"Created by")],-1)),n[232]||(n[232]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"PET_PriestleyTaylor1972"},{default:i(()=>[l("details",G,[l("summary",null,[n[233]||(n[233]=l("a",{id:"Sindbad.Models.PET_PriestleyTaylor1972",href:"#Sindbad.Models.PET_PriestleyTaylor1972"},[l("span",{class:"jlbinding"},"Sindbad.Models.PET_PriestleyTaylor1972")],-1)),n[234]||(n[234]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[235]||(n[235]=l("p",null,"Calculates PET using Priestley-Taylor (1972) method.",-1)),n[236]||(n[236]=l("p",null,[l("strong",null,"Parameters")],-1)),n[237]||(n[237]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"Δ_1"),o(": 6.11 ∈ [-Inf, Inf] => parameter 1 for calculating Δ ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Δ_2"),o(": 17.26938818 ∈ [-Inf, Inf] => parameter 2 for calculating Δ ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Δ_3"),o(": 237.3 ∈ [-Inf, Inf] => parameter 3 for calculating Δ ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Lhv_1"),o(": 5.147 ∈ [-Inf, Inf] => parameter 1 for calculating Lhv ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Lhv_2"),o(": -0.0004643 ∈ [-Inf, Inf] => parameter 2 for calculating Lhv ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Lhv_3"),o(": 2.6466 ∈ [-Inf, Inf] => parameter 3 for calculating Lhv ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"γ_1"),o(": 0.4 ∈ [-Inf, Inf] => parameter 1 for calculating γ ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"γ_2"),o(": 0.622 ∈ [-Inf, Inf] => parameter 2 for calculating γ ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"PET_1"),o(": 1.26 ∈ [-Inf, Inf] => parameter 1 for calculating PET ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[238]||(n[238]=l("p",null,[l("strong",null,"Methods:")],-1)),n[239]||(n[239]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[240]||(n[240]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rn"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rn)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])])],-1)),n[241]||(n[241]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[242]||(n[242]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"PET_PriestleyTaylor1972.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[243]||(n[243]=l("hr",null,null,-1)),n[244]||(n[244]=l("p",null,[l("strong",null,"Extended help")],-1)),n[245]||(n[245]=l("p",null,[l("em",null,"References")],-1)),n[246]||(n[246]=l("ul",null,[l("li",null,"Priestley, C. H. B., & TAYLOR, R. J. (1972). On the assessment of surface heat flux & evaporation using large-scale parameters. Monthly weather review, 100[2], 81-92.")],-1)),n[247]||(n[247]=l("p",null,[l("em",null,"Versions")],-1)),n[248]||(n[248]=l("ul",null,[l("li",null,"1.0 on 20.03.2020 [skoirala | @dr-ko]")],-1)),n[249]||(n[249]=l("p",null,[l("em",null,"Created by")],-1)),n[250]||(n[250]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"PET_forcing"},{default:i(()=>[l("details",L,[l("summary",null,[n[251]||(n[251]=l("a",{id:"Sindbad.Models.PET_forcing",href:"#Sindbad.Models.PET_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.PET_forcing")],-1)),n[252]||(n[252]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[253]||(n[253]=l("p",null,"Gets PET from forcing data.",-1)),n[254]||(n[254]=l("p",null,[l("strong",null,"Parameters")],-1)),n[255]||(n[255]=l("ul",null,[l("li",null,"None")],-1)),n[256]||(n[256]=l("p",null,[l("strong",null,"Methods:")],-1)),n[257]||(n[257]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[258]||(n[258]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_PET"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_PET)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])])],-1)),n[259]||(n[259]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[260]||(n[260]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"PET_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[261]||(n[261]=l("hr",null,null,-1)),n[262]||(n[262]=l("p",null,[l("strong",null,"Extended help")],-1)),n[263]||(n[263]=l("p",null,[l("em",null,"References")],-1)),n[264]||(n[264]=l("p",null,[l("em",null,"Versions")],-1)),n[265]||(n[265]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[266]||(n[266]=l("p",null,[l("em",null,"Created by")],-1)),n[267]||(n[267]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4562]||(n[4562]=l("hr",null,null,-1)),n[4563]||(n[4563]=l("h3",{id:"PFT",tabindex:"-1"},[o("PFT "),l("a",{class:"header-anchor",href:"#PFT","aria-label":'Permalink to "PFT {#PFT}"'},"​")],-1)),l("details",z,[l("summary",null,[n[269]||(n[269]=l("a",{id:"Sindbad.Models.PFT",href:"#Sindbad.Models.PFT"},[l("span",{class:"jlbinding"},"Sindbad.Models.PFT")],-1)),n[270]||(n[270]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[271]||(n[271]=u("",4))]),l("details",U,[n[289]||(n[289]=l("summary",null,"PFT approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"PFT_constant"},{default:i(()=>[l("details",J,[l("summary",null,[n[272]||(n[272]=l("a",{id:"Sindbad.Models.PFT_constant",href:"#Sindbad.Models.PFT_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.PFT_constant")],-1)),n[273]||(n[273]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[274]||(n[274]=l("p",null,"Sets a uniform PFT class.",-1)),n[275]||(n[275]=l("p",null,[l("strong",null,"Parameters")],-1)),n[276]||(n[276]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"PFT"),o(": 1.0 ∈ [1.0, 13.0] => Plant functional type (units: "),l("code",null,"class"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[277]||(n[277]=l("p",null,[l("strong",null,"Methods:")],-1)),n[278]||(n[278]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[279]||(n[279]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"PFT.PFT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:PFT, :PFT)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[280]||(n[280]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[281]||(n[281]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"PFT_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[282]||(n[282]=l("hr",null,null,-1)),n[283]||(n[283]=l("p",null,[l("strong",null,"Extended help")],-1)),n[284]||(n[284]=l("p",null,[l("em",null,"References")],-1)),n[285]||(n[285]=l("p",null,[l("em",null,"Versions")],-1)),n[286]||(n[286]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[287]||(n[287]=l("p",null,[l("em",null,"Created by")],-1)),n[288]||(n[288]=l("ul",null,[l("li",null,"unknown [xxx]")],-1))])]),_:1})]),_:1})]),n[4564]||(n[4564]=l("hr",null,null,-1)),n[4565]||(n[4565]=l("h3",{id:"WUE",tabindex:"-1"},[o("WUE "),l("a",{class:"header-anchor",href:"#WUE","aria-label":'Permalink to "WUE {#WUE}"'},"​")],-1)),l("details",K,[l("summary",null,[n[290]||(n[290]=l("a",{id:"Sindbad.Models.WUE",href:"#Sindbad.Models.WUE"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE")],-1)),n[291]||(n[291]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[292]||(n[292]=u("",4))]),l("details",H,[n[383]||(n[383]=l("summary",null,"WUE approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"WUE_Medlyn2011"},{default:i(()=>[l("details",q,[l("summary",null,[n[293]||(n[293]=l("a",{id:"Sindbad.Models.WUE_Medlyn2011",href:"#Sindbad.Models.WUE_Medlyn2011"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE_Medlyn2011")],-1)),n[294]||(n[294]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[295]||(n[295]=l("p",null,"Calculates WUE as a function of daytime mean VPD and ambient CO₂, following Medlyn et al. (2011).",-1)),n[296]||(n[296]=l("p",null,[l("strong",null,"Parameters")],-1)),n[297]||(n[297]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"g1"),o(": 3.0 ∈ [0.5, 12.0] => stomatal conductance parameter (units: "),l("code",null,"kPa^0.5"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ζ"),o(": 1.0 ∈ [0.85, 3.5] => sensitivity of WUE to ambient co2 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"diffusivity_ratio"),o(": 1.6 ∈ [-Inf, Inf] => Ratio of the molecular diffusivities for water vapor and CO2 ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[298]||(n[298]=l("p",null,[l("strong",null,"Methods:")],-1)),n[299]||(n[299]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[300]||(n[300]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"WUE.umol_to_gC"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:WUE, :umol_to_gC)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[301]||(n[301]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[302]||(n[302]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_psurf_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_psurf_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])]),l("li",null,[l("p",null,[l("code",null,"WUE.umol_to_gC"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:WUE, :umol_to_gC)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.ci"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :ci)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ciNoCO2"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :ciNoCO2)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUENoCO2"),o(": water use efficiency of the ecosystem without CO2 effect")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])])],-1)),n[303]||(n[303]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[304]||(n[304]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"WUE_Medlyn2011.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[305]||(n[305]=l("hr",null,null,-1)),n[306]||(n[306]=l("p",null,[l("strong",null,"Extended help")],-1)),n[307]||(n[307]=l("p",null,[l("em",null,"References")],-1)),n[308]||(n[308]=l("ul",null,[l("li",null,[l("p",null,[o("Knauer J, El-Madany TS, Zaehle S, Migliavacca M [2018] Bigleaf—An R package for the calculation of physical & physiological ecosystem properties from eddy covariance data. PLoS ONE 13[8]: e0201114. "),l("a",{href:"https://doi.org/10.1371/journal.pone.0201114",target:"_blank",rel:"noreferrer"},"https://doi.org/10.1371/journal.pone.0201114")])]),l("li",null,[l("p",null,"MEDLYN; B.E.; DUURSMA; R.A.; EAMUS; D.; ELLSWORTH; D.S.; PRENTICE; I.C. BARTON; C.V.M.; CROUS; K.Y.; DE ANGELIS; P.; FREEMAN; M. & WINGATE L. (2011), Reconciling the optimal & empirical approaches to modelling stomatal conductance. Global Change Biology; 17: 2134-2144. doi:10.1111/j.1365-2486.2010.02375.x")]),l("li",null,[l("p",null,"Medlyn; B.E.; Duursma; R.A.; Eamus; D.; Ellsworth; D.S.; Colin Prentice I.; Barton; C.V.M.; Crous; K.Y.; de Angelis; P.; Freeman; M. & Wingate, L. (2012), Reconciling the optimal & empirical approaches to modelling stomatal conductance. Glob Change Biol; 18: 3476-3476. doi:10.1111/j.1365-2486.2012.02790.")])],-1)),n[309]||(n[309]=l("p",null,[l("em",null,"Versions")],-1)),n[310]||(n[310]=l("ul",null,[l("li",null,"1.0 on 11.11.2020 [skoirala | @dr-ko]")],-1)),n[311]||(n[311]=l("p",null,[l("em",null,"Created by")],-1)),n[312]||(n[312]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[313]||(n[313]=l("p",null,[l("em",null,"Notes")],-1)),n[314]||(n[314]=l("ul",null,[l("li",null,[l("p",null,"unit conversion: C_flux[gC m-2 d-1] < - CO2_flux[(umol CO2 m-2 s-1)] * 1e-06 [umol2mol] * 0.012011 [Cmol] * 1000 [kg2g] * 86400 [days2seconds] from Knauer; 2019")]),l("li",null,[l("p",null,"water: mmol m-2 s-1: /1000 [mol m-2 s-1] * .018015 [Wmol in kg/mol] * 84600")])],-1))])]),_:1}),e(s,{label:"WUE_VPDDay"},{default:i(()=>[l("details",Z,[l("summary",null,[n[315]||(n[315]=l("a",{id:"Sindbad.Models.WUE_VPDDay",href:"#Sindbad.Models.WUE_VPDDay"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE_VPDDay")],-1)),n[316]||(n[316]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[317]||(n[317]=l("p",null,"Calculates WUE as a function of WUE at 1 hPa and daily mean VPD.",-1)),n[318]||(n[318]=l("p",null,[l("strong",null,"Parameters")],-1)),n[319]||(n[319]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"WUE_one_hpa"),o(": 9.2 ∈ [4.0, 17.0] => WUE at 1 hpa VPD (units: "),l("code",null,"gC/mmH2O"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"kpa_to_hpa"),o(": 10.0 ∈ [-Inf, Inf] => unit conversion kPa to hPa ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[320]||(n[320]=l("p",null,[l("strong",null,"Methods:")],-1)),n[321]||(n[321]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[322]||(n[322]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])],-1)),n[323]||(n[323]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[324]||(n[324]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"WUE_VPDDay.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[325]||(n[325]=l("hr",null,null,-1)),n[326]||(n[326]=l("p",null,[l("strong",null,"Extended help")],-1)),n[327]||(n[327]=l("p",null,[l("em",null,"References")],-1)),n[328]||(n[328]=l("p",null,[l("em",null,"Versions")],-1)),n[329]||(n[329]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[330]||(n[330]=l("p",null,[l("em",null,"Created by")],-1)),n[331]||(n[331]=l("ul",null,[l("li",null,[l("p",null,"Jake Nelson [jnelson]: for the typical values & ranges of WUEat1hPa across fluxNet sites")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1}),e(s,{label:"WUE_VPDDayCo2"},{default:i(()=>[l("details",Q,[l("summary",null,[n[332]||(n[332]=l("a",{id:"Sindbad.Models.WUE_VPDDayCo2",href:"#Sindbad.Models.WUE_VPDDayCo2"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE_VPDDayCo2")],-1)),n[333]||(n[333]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[334]||(n[334]=l("p",null,"Calculates WUE as a function of WUE at 1 hPa daily mean VPD and linear CO₂ relationship.",-1)),n[335]||(n[335]=l("p",null,[l("strong",null,"Parameters")],-1)),n[336]||(n[336]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"WUE_one_hpa"),o(": 9.2 ∈ [4.0, 17.0] => WUE at 1 hpa VPD (units: "),l("code",null,"gC/mmH2O"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"base_ambient_CO2"),o(": 380.0 ∈ [300.0, 500.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sat_ambient_CO2"),o(": 500.0 ∈ [100.0, 2000.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"kpa_to_hpa"),o(": 10.0 ∈ [-Inf, Inf] => unit conversion kPa to hPa ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[337]||(n[337]=l("p",null,[l("strong",null,"Methods:")],-1)),n[338]||(n[338]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[339]||(n[339]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.WUENoCO2"),o(": water use efficiency of the ecosystem without CO2 effect")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])])],-1)),n[340]||(n[340]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[341]||(n[341]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"WUE_VPDDayCo2.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[342]||(n[342]=l("hr",null,null,-1)),n[343]||(n[343]=l("p",null,[l("strong",null,"Extended help")],-1)),n[344]||(n[344]=l("p",null,[l("em",null,"References")],-1)),n[345]||(n[345]=l("p",null,[l("em",null,"Versions")],-1)),n[346]||(n[346]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[347]||(n[347]=l("p",null,[l("em",null,"Created by")],-1)),n[348]||(n[348]=l("ul",null,[l("li",null,[l("p",null,"Jake Nelson [jnelson]: for the typical values & ranges of WUEat1hPa across fluxNet sites")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1}),e(s,{label:"WUE_constant"},{default:i(()=>[l("details",Y,[l("summary",null,[n[349]||(n[349]=l("a",{id:"Sindbad.Models.WUE_constant",href:"#Sindbad.Models.WUE_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE_constant")],-1)),n[350]||(n[350]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[351]||(n[351]=l("p",null,"Sets WUE as a constant value.",-1)),n[352]||(n[352]=l("p",null,[l("strong",null,"Parameters")],-1)),n[353]||(n[353]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_WUE"),o(": 4.1 ∈ [1.0, 10.0] => mean FluxNet WUE (units: "),l("code",null,"gC/mmH2O"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[354]||(n[354]=l("p",null,[l("strong",null,"Methods:")],-1)),n[355]||(n[355]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[356]||(n[356]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])],-1)),n[357]||(n[357]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[358]||(n[358]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"WUE_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[359]||(n[359]=l("hr",null,null,-1)),n[360]||(n[360]=l("p",null,[l("strong",null,"Extended help")],-1)),n[361]||(n[361]=l("p",null,[l("em",null,"References")],-1)),n[362]||(n[362]=l("p",null,[l("em",null,"Versions")],-1)),n[363]||(n[363]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[364]||(n[364]=l("p",null,[l("em",null,"Created by")],-1)),n[365]||(n[365]=l("ul",null,[l("li",null,[l("p",null,"Jake Nelson [jnelson]: for the typical values & ranges of WUE across fluxNet sites")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1}),e(s,{label:"WUE_expVPDDayCo2"},{default:i(()=>[l("details",X,[l("summary",null,[n[366]||(n[366]=l("a",{id:"Sindbad.Models.WUE_expVPDDayCo2",href:"#Sindbad.Models.WUE_expVPDDayCo2"},[l("span",{class:"jlbinding"},"Sindbad.Models.WUE_expVPDDayCo2")],-1)),n[367]||(n[367]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[368]||(n[368]=l("p",null,"Calculates WUE as a function of WUE at 1 hPa, daily mean VPD, and an exponential CO₂ relationship.",-1)),n[369]||(n[369]=l("p",null,[l("strong",null,"Parameters")],-1)),n[370]||(n[370]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"WUE_one_hpa"),o(": 9.2 ∈ [2.0, 20.0] => WUE at 1 hpa VPD (units: "),l("code",null,"gC/mmH2O"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"κ"),o(": 0.4 ∈ [0.06, 0.7] => (units: "),l("code",null,"kPa-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"base_ambient_CO2"),o(": 380.0 ∈ [300.0, 500.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sat_ambient_CO2"),o(": 500.0 ∈ [10.0, 2000.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"kpa_to_hpa"),o(": 10.0 ∈ [-Inf, Inf] => unit conversion kPa to hPa ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[371]||(n[371]=l("p",null,[l("strong",null,"Methods:")],-1)),n[372]||(n[372]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[373]||(n[373]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.WUENoCO2"),o(": water use efficiency of the ecosystem without CO2 effect")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])])],-1)),n[374]||(n[374]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[375]||(n[375]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"WUE_expVPDDayCo2.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[376]||(n[376]=l("hr",null,null,-1)),n[377]||(n[377]=l("p",null,[l("strong",null,"Extended help")],-1)),n[378]||(n[378]=l("p",null,[l("em",null,"References")],-1)),n[379]||(n[379]=l("p",null,[l("em",null,"Versions")],-1)),n[380]||(n[380]=l("ul",null,[l("li",null,"1.0 on 31.03.2021 [skoirala | @dr-ko]")],-1)),n[381]||(n[381]=l("p",null,[l("em",null,"Created by")],-1)),n[382]||(n[382]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4566]||(n[4566]=l("hr",null,null,-1)),n[4567]||(n[4567]=l("h3",{id:"ambientCO2",tabindex:"-1"},[o("ambientCO2 "),l("a",{class:"header-anchor",href:"#ambientCO2","aria-label":'Permalink to "ambientCO2 {#ambientCO2}"'},"​")],-1)),l("details",$,[l("summary",null,[n[384]||(n[384]=l("a",{id:"Sindbad.Models.ambientCO2",href:"#Sindbad.Models.ambientCO2"},[l("span",{class:"jlbinding"},"Sindbad.Models.ambientCO2")],-1)),n[385]||(n[385]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[386]||(n[386]=u("",4))]),l("details",h,[n[425]||(n[425]=l("summary",null,"ambientCO2 approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"ambientCO2_constant"},{default:i(()=>[l("details",_,[l("summary",null,[n[387]||(n[387]=l("a",{id:"Sindbad.Models.ambientCO2_constant",href:"#Sindbad.Models.ambientCO2_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.ambientCO2_constant")],-1)),n[388]||(n[388]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[389]||(n[389]=l("p",null,"Sets ambient CO₂ to a constant value.",-1)),n[390]||(n[390]=l("p",null,[l("strong",null,"Parameters")],-1)),n[391]||(n[391]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_ambient_CO2"),o(": 400.0 ∈ [200.0, 5000.0] => atmospheric CO2 concentration (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[392]||(n[392]=l("p",null,[l("strong",null,"Methods:")],-1)),n[393]||(n[393]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[394]||(n[394]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])])])],-1)),n[395]||(n[395]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[396]||(n[396]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"ambientCO2_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[397]||(n[397]=l("hr",null,null,-1)),n[398]||(n[398]=l("p",null,[l("strong",null,"Extended help")],-1)),n[399]||(n[399]=l("p",null,[o("This function assigns a constant value of ambient CO2 concentration to the land model state. The value is derived from the "),l("code",null,"constant_ambient_CO2"),o(" parameter defined in the "),l("code",null,"ambientCO2_constant"),o(" structure.")],-1)),n[400]||(n[400]=l("p",null,[l("em",null,"References")],-1)),n[401]||(n[401]=l("ul",null,[l("li",null,"None")],-1)),n[402]||(n[402]=l("p",null,[l("em",null,"Versions")],-1)),n[403]||(n[403]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[404]||(n[404]=l("p",null,[l("em",null,"Created by")],-1)),n[405]||(n[405]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"ambientCO2_forcing"},{default:i(()=>[l("details",ll,[l("summary",null,[n[406]||(n[406]=l("a",{id:"Sindbad.Models.ambientCO2_forcing",href:"#Sindbad.Models.ambientCO2_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.ambientCO2_forcing")],-1)),n[407]||(n[407]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[408]||(n[408]=l("p",null,"Gets ambient CO₂ from forcing data.",-1)),n[409]||(n[409]=l("p",null,[l("strong",null,"Parameters")],-1)),n[410]||(n[410]=l("ul",null,[l("li",null,"None")],-1)),n[411]||(n[411]=l("p",null,[l("strong",null,"Methods:")],-1)),n[412]||(n[412]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[413]||(n[413]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_ambient_CO2"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_ambient_CO2)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])])])],-1)),n[414]||(n[414]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[415]||(n[415]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"ambientCO2_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[416]||(n[416]=l("hr",null,null,-1)),n[417]||(n[417]=l("p",null,[l("strong",null,"Extended help")],-1)),n[418]||(n[418]=l("p",null,[o("This function assigns ambient CO2 concentration from the forcing data ("),l("code",null,"f_ambient_CO2"),o(") to the land model state for the current time step.")],-1)),n[419]||(n[419]=l("p",null,[l("em",null,"References")],-1)),n[420]||(n[420]=l("ul",null,[l("li",null,"None")],-1)),n[421]||(n[421]=l("p",null,[l("em",null,"Versions")],-1)),n[422]||(n[422]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[423]||(n[423]=l("p",null,[l("em",null,"Created by")],-1)),n[424]||(n[424]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4568]||(n[4568]=l("hr",null,null,-1)),n[4569]||(n[4569]=l("h3",{id:"autoRespiration",tabindex:"-1"},[o("autoRespiration "),l("a",{class:"header-anchor",href:"#autoRespiration","aria-label":'Permalink to "autoRespiration {#autoRespiration}"'},"​")],-1)),l("details",nl,[l("summary",null,[n[426]||(n[426]=l("a",{id:"Sindbad.Models.autoRespiration",href:"#Sindbad.Models.autoRespiration"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespiration")],-1)),n[427]||(n[427]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[428]||(n[428]=u("",4))]),l("details",ol,[n[509]||(n[509]=l("summary",null,"autoRespiration approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"autoRespiration_Thornley2000A"},{default:i(()=>[l("details",el,[l("summary",null,[n[429]||(n[429]=l("a",{id:"Sindbad.Models.autoRespiration_Thornley2000A",href:"#Sindbad.Models.autoRespiration_Thornley2000A"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespiration_Thornley2000A")],-1)),n[430]||(n[430]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[431]||(n[431]=l("p",null,"Calculates autotrophic maintenance and growth respiration using Thornley and Cannell (2000) Model A, where maintenance respiration is prioritized.",-1)),n[432]||(n[432]=l("p",null,[l("strong",null,"Parameters")],-1)),n[433]||(n[433]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"RMN"),o(": 0.009085714285714286 ∈ [0.0009085714285714285, 0.09085714285714286] => Nitrogen efficiency rate of maintenance respiration (units: "),l("code",null,"gC/gN/day"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"YG"),o(": 0.75 ∈ [0.0, 1.0] => growth yield coefficient, or growth efficiency. Loosely: (1-YG)*GPP is growth respiration (units: "),l("code",null,"gC/gC"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[434]||(n[434]=l("p",null,[l("strong",null,"Methods:")],-1)),n[435]||(n[435]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[436]||(n[436]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[437]||(n[437]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[438]||(n[438]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.auto_respiration_f_airT"),o(": effect of air temperature on autotrophic respiration. 0: no decomposition, >1 increase in decomposition rate")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[439]||(n[439]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[440]||(n[440]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespiration_Thornley2000A.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[441]||(n[441]=l("hr",null,null,-1)),n[442]||(n[442]=l("p",null,[l("strong",null,"Extended help")],-1)),n[443]||(n[443]=l("p",null,[l("em",null,"References")],-1)),n[444]||(n[444]=l("ul",null,[l("li",null,[l("p",null,"Amthor, J. S. (2000), The McCree-de Wit-Penning de Vries-Thornley respiration paradigms: 30 years later, Ann Bot-London, 86[1], 1-20. Ryan, M. G. (1991), Effects of Climate Change on Plant Respiration, Ecol Appl, 1[2], 157-167.")]),l("li",null,[l("p",null,"Thornley, J. H. M., & M. G. R. Cannell [2000], Modelling the components of plant respiration: Representation & realism, Ann Bot-London, 85[1] 55-67.")])],-1)),n[445]||(n[445]=l("p",null,[l("em",null,"Versions")],-1)),n[446]||(n[446]=l("ul",null,[l("li",null,"1.0 on 06.05.2022 [ncarvalhais/skoirala]: cleaned up the code")],-1)),n[447]||(n[447]=l("p",null,[l("em",null,"Created by")],-1)),n[448]||(n[448]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[449]||(n[449]=l("p",null,[l("em",null,"Notes")],-1)),n[450]||(n[450]=l("ul",null,[l("li",null,"Questions - practical - leave raAct per pool; | make a field land.fluxes.ra that has all the autotrophic respiration components together?")],-1))])]),_:1}),e(s,{label:"autoRespiration_Thornley2000B"},{default:i(()=>[l("details",tl,[l("summary",null,[n[451]||(n[451]=l("a",{id:"Sindbad.Models.autoRespiration_Thornley2000B",href:"#Sindbad.Models.autoRespiration_Thornley2000B"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespiration_Thornley2000B")],-1)),n[452]||(n[452]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[453]||(n[453]=l("p",null,"Calculates autotrophic maintenance and growth respiration using Thornley and Cannell (2000) Model B, where growth respiration is prioritized.",-1)),n[454]||(n[454]=l("p",null,[l("strong",null,"Parameters")],-1)),n[455]||(n[455]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"RMN"),o(": 0.009085714285714286 ∈ [0.0009085714285714285, 0.09085714285714286] => Nitrogen efficiency rate of maintenance respiration (units: "),l("code",null,"gC/gN/day"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"YG"),o(": 0.75 ∈ [0.0, 1.0] => growth yield coefficient, or growth efficiency. Loosely: (1-YG)*GPP is growth respiration (units: "),l("code",null,"gC/gC"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[456]||(n[456]=l("p",null,[l("strong",null,"Methods:")],-1)),n[457]||(n[457]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[458]||(n[458]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[459]||(n[459]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[460]||(n[460]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.auto_respiration_f_airT"),o(": effect of air temperature on autotrophic respiration. 0: no decomposition, >1 increase in decomposition rate")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[461]||(n[461]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[462]||(n[462]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespiration_Thornley2000B.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[463]||(n[463]=l("hr",null,null,-1)),n[464]||(n[464]=l("p",null,[l("strong",null,"Extended help")],-1)),n[465]||(n[465]=l("p",null,[l("em",null,"References")],-1)),n[466]||(n[466]=l("ul",null,[l("li",null,[l("p",null,"Amthor, J. S. (2000), The McCree-de Wit-Penning de Vries-Thornley respiration paradigms: 30 years later, Ann Bot-London, 86[1], 1-20. Ryan, M. G. (1991), Effects of Climate Change on Plant Respiration, Ecol Appl, 1[2], 157-167.")]),l("li",null,[l("p",null,"Thornley, J. H. M., & M. G. R. Cannell [2000], Modelling the components of plant respiration: Representation & realism, Ann Bot-London, 85[1] 55-67.")])],-1)),n[467]||(n[467]=l("p",null,[l("em",null,"Versions")],-1)),n[468]||(n[468]=l("ul",null,[l("li",null,"1.0 on 06.05.2022 [ncarvalhais/skoirala]: cleaned up the code")],-1)),n[469]||(n[469]=l("p",null,[l("em",null,"Created by")],-1)),n[470]||(n[470]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[471]||(n[471]=l("p",null,[l("em",null,"Notes")],-1)),n[472]||(n[472]=l("ul",null,[l("li",null,"Questions - practical - leave raAct per pool; | make a field land.fluxes.ra that has all the autotrophic respiration components together?")],-1))])]),_:1}),e(s,{label:"autoRespiration_Thornley2000C"},{default:i(()=>[l("details",il,[l("summary",null,[n[473]||(n[473]=l("a",{id:"Sindbad.Models.autoRespiration_Thornley2000C",href:"#Sindbad.Models.autoRespiration_Thornley2000C"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespiration_Thornley2000C")],-1)),n[474]||(n[474]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[475]||(n[475]=l("p",null,"Calculates autotrophic maintenance and growth respiration using Thornley and Cannell (2000) Model C, which includes growth, degradation, and resynthesis.",-1)),n[476]||(n[476]=l("p",null,[l("strong",null,"Parameters")],-1)),n[477]||(n[477]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"RMN"),o(": 0.009085714285714286 ∈ [0.0009085714285714285, 0.09085714285714286] => Nitrogen efficiency rate of maintenance respiration (units: "),l("code",null,"gC/gN/day"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"YG"),o(": 0.75 ∈ [0.0, 1.0] => growth yield coefficient, or growth efficiency. Loosely: (1-YG)*GPP is growth respiration (units: "),l("code",null,"gC/gC"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"MTF"),o(": 0.85 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[478]||(n[478]=l("p",null,[l("strong",null,"Methods:")],-1)),n[479]||(n[479]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[480]||(n[480]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.Fd"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :Fd)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[481]||(n[481]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[482]||(n[482]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.Fd"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :Fd)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.auto_respiration_f_airT"),o(": effect of air temperature on autotrophic respiration. 0: no decomposition, >1 increase in decomposition rate")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain"),o(": metabolism rate for maintenance respiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_respiration_maintain_su"),o(": metabolism rate for maintenance respiration to be used in old analytical solution to steady state")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_growth"),o(": growth respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration_maintain"),o(": maintenance respiration per vegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])])])])],-1)),n[483]||(n[483]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[484]||(n[484]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespiration_Thornley2000C.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[485]||(n[485]=l("hr",null,null,-1)),n[486]||(n[486]=l("p",null,[l("strong",null,"Extended help")],-1)),n[487]||(n[487]=l("p",null,[l("em",null,"References")],-1)),n[488]||(n[488]=l("ul",null,[l("li",null,[l("p",null,"Amthor, J. S. (2000), The McCree-de Wit-Penning de Vries-Thornley respiration paradigms: 30 years later, Ann Bot-London, 86[1], 1-20. Ryan, M. G. (1991), Effects of Climate Change on Plant Respiration, Ecol Appl, 1[2], 157-167.")]),l("li",null,[l("p",null,"Thornley, J. H. M., & M. G. R. Cannell [2000], Modelling the components of plant respiration: Representation & realism, Ann Bot-London, 85[1] 55-67.")])],-1)),n[489]||(n[489]=l("p",null,[l("em",null,"Versions")],-1)),n[490]||(n[490]=l("ul",null,[l("li",null,"1.0 on 06.05.2022 [ncarvalhais/skoirala]: cleaned up the code")],-1)),n[491]||(n[491]=l("p",null,[l("em",null,"Created by")],-1)),n[492]||(n[492]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[493]||(n[493]=l("p",null,[l("em",null,"Notes")],-1)),n[494]||(n[494]=l("ul",null,[l("li",null,"Questions - practical - leave raAct per pool; | make a field land.fluxes.ra that has all the autotrophic respiration components together?")],-1))])]),_:1}),e(s,{label:"autoRespiration_none"},{default:i(()=>[l("details",sl,[l("summary",null,[n[495]||(n[495]=l("a",{id:"Sindbad.Models.autoRespiration_none",href:"#Sindbad.Models.autoRespiration_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespiration_none")],-1)),n[496]||(n[496]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[497]||(n[497]=l("p",null,"Sets autotrophic respiration fluxes to 0.",-1)),n[498]||(n[498]=l("p",null,[l("strong",null,"Parameters")],-1)),n[499]||(n[499]=l("ul",null,[l("li",null,"None")],-1)),n[500]||(n[500]=l("p",null,[l("strong",null,"Methods:")],-1)),n[501]||(n[501]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[502]||(n[502]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.c_eco_efflux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_efflux)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[503]||(n[503]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[504]||(n[504]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespiration_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[505]||(n[505]=l("hr",null,null,-1)),n[506]||(n[506]=l("p",null,[l("strong",null,"Extended help")],-1)),n[507]||(n[507]=l("p",null,[l("em",null,"Notes"),o(" Applicability: no C cycle; or computing/inputing NPP directly, e.g. like in Potter et al., (1993) and follow up approaches.")],-1)),n[508]||(n[508]=l("p",null,[l("em",null,"References"),o(),l("a",{href:"https://doi.org/10.1029/93GB02725",target:"_blank",rel:"noreferrer"},"https://doi.org/10.1029/93GB02725")],-1))])]),_:1})]),_:1})]),n[4570]||(n[4570]=l("hr",null,null,-1)),n[4571]||(n[4571]=l("h3",{id:"autoRespirationAirT",tabindex:"-1"},[o("autoRespirationAirT "),l("a",{class:"header-anchor",href:"#autoRespirationAirT","aria-label":'Permalink to "autoRespirationAirT {#autoRespirationAirT}"'},"​")],-1)),l("details",ul,[l("summary",null,[n[510]||(n[510]=l("a",{id:"Sindbad.Models.autoRespirationAirT",href:"#Sindbad.Models.autoRespirationAirT"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespirationAirT")],-1)),n[511]||(n[511]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[512]||(n[512]=u("",4))]),l("details",rl,[n[544]||(n[544]=l("summary",null,"autoRespirationAirT approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"autoRespirationAirT_Q10"},{default:i(()=>[l("details",al,[l("summary",null,[n[513]||(n[513]=l("a",{id:"Sindbad.Models.autoRespirationAirT_Q10",href:"#Sindbad.Models.autoRespirationAirT_Q10"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespirationAirT_Q10")],-1)),n[514]||(n[514]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[515]||(n[515]=l("p",null,"Calculates the effect of air temperature on maintenance respiration using a Q10 function.",-1)),n[516]||(n[516]=l("p",null,[l("strong",null,"Parameters")],-1)),n[517]||(n[517]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"Q10"),o(": 2.0 ∈ [1.05, 3.0] => Q10 parameter for maintenance respiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ref_airT"),o(": 20.0 ∈ [0.0, 40.0] => Reference temperature for the maintenance respiration (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Q10_base"),o(": 10.0 ∈ [-Inf, Inf] => base temperature difference (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[518]||(n[518]=l("p",null,[l("strong",null,"Methods:")],-1)),n[519]||(n[519]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[520]||(n[520]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.auto_respiration_f_airT"),o(": effect of air temperature on autotrophic respiration. 0: no decomposition, >1 increase in decomposition rate")])])])],-1)),n[521]||(n[521]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[522]||(n[522]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespirationAirT_Q10.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[523]||(n[523]=l("hr",null,null,-1)),n[524]||(n[524]=l("p",null,[l("strong",null,"Extended help")],-1)),n[525]||(n[525]=l("p",null,[l("em",null,"References")],-1)),n[526]||(n[526]=l("ul",null,[l("li",null,[l("p",null,"Amthor, J. S. (2000), The McCree-de Wit-Penning de Vries-Thornley respiration paradigms: 30 years later, Ann Bot-London, 86[1], 1-20.")]),l("li",null,[l("p",null,"Ryan, M. G. (1991), Effects of Climate Change on Plant Respiration, Ecol Appl, 1[2], 157-167.")]),l("li",null,[l("p",null,"Thornley, J. H. M., & M. G. R. Cannell [2000], Modelling the components of plant respiration: Representation & realism, Ann Bot-London, 85[1] 55-67.")])],-1)),n[527]||(n[527]=l("p",null,[l("em",null,"Versions")],-1)),n[528]||(n[528]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: clean up")],-1)),n[529]||(n[529]=l("p",null,[l("em",null,"Created by")],-1)),n[530]||(n[530]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[531]||(n[531]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"autoRespirationAirT_none"},{default:i(()=>[l("details",dl,[l("summary",null,[n[532]||(n[532]=l("a",{id:"Sindbad.Models.autoRespirationAirT_none",href:"#Sindbad.Models.autoRespirationAirT_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.autoRespirationAirT_none")],-1)),n[533]||(n[533]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[534]||(n[534]=l("p",null,"No air temperature effect on autotrophic respiration.",-1)),n[535]||(n[535]=l("p",null,[l("strong",null,"Parameters")],-1)),n[536]||(n[536]=l("ul",null,[l("li",null,"None")],-1)),n[537]||(n[537]=l("p",null,[l("strong",null,"Methods:")],-1)),n[538]||(n[538]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[539]||(n[539]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.auto_respiration_f_airT"),o(": effect of air temperature on autotrophic respiration. 0: no decomposition, >1 increase in decomposition rate")])])])],-1)),n[540]||(n[540]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[541]||(n[541]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"autoRespirationAirT_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[542]||(n[542]=l("hr",null,null,-1)),n[543]||(n[543]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4572]||(n[4572]=l("hr",null,null,-1)),n[4573]||(n[4573]=l("h3",{id:"cAllocation",tabindex:"-1"},[o("cAllocation "),l("a",{class:"header-anchor",href:"#cAllocation","aria-label":'Permalink to "cAllocation {#cAllocation}"'},"​")],-1)),l("details",pl,[l("summary",null,[n[545]||(n[545]=l("a",{id:"Sindbad.Models.cAllocation",href:"#Sindbad.Models.cAllocation"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocation")],-1)),n[546]||(n[546]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[547]||(n[547]=u("",4))]),l("details",fl,[n[621]||(n[621]=l("summary",null,"cAllocation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocation_Friedlingstein1999"},{default:i(()=>[l("details",gl,[l("summary",null,[n[548]||(n[548]=l("a",{id:"Sindbad.Models.cAllocation_Friedlingstein1999",href:"#Sindbad.Models.cAllocation_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocation_Friedlingstein1999")],-1)),n[549]||(n[549]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[550]||(n[550]=l("p",null,"Dynamically allocates carbon based on LAI, moisture, and nutrient availability, following Friedlingstein et al. (1999).",-1)),n[551]||(n[551]=l("p",null,[l("strong",null,"Parameters")],-1)),n[552]||(n[552]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"so"),o(": 0.3 ∈ [0.0, 1.0] => fractional carbon allocation to stem for non-limiting conditions (units: "),l("code",null,"fractional"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ro"),o(": 0.3 ∈ [0.0, 1.0] => fractional carbon allocation to root for non-limiting conditions (units: "),l("code",null,"fractional"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"rel_Y"),o(": 2.0 ∈ [1.0, Inf] => normalization parameter (units: "),l("code",null,"dimensionless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[553]||(n[553]=l("p",null,[l("strong",null,"Methods:")],-1)),n[554]||(n[554]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[555]||(n[555]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])])])])],-1)),n[556]||(n[556]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[557]||(n[557]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.c_allocation"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_allocation)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_W_N"),o(": effect of water and nutrient on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_LAI"),o(": effect of LAI on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])],-1)),n[558]||(n[558]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[559]||(n[559]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocation_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[560]||(n[560]=l("hr",null,null,-1)),n[561]||(n[561]=l("p",null,[l("strong",null,"Extended help")],-1)),n[562]||(n[562]=l("p",null,[l("em",null,"References")],-1)),n[563]||(n[563]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[564]||(n[564]=l("p",null,[l("em",null,"Versions")],-1)),n[565]||(n[565]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[566]||(n[566]=l("p",null,[l("em",null,"Created by")],-1)),n[567]||(n[567]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocation_GSI"},{default:i(()=>[l("details",ml,[l("summary",null,[n[568]||(n[568]=l("a",{id:"Sindbad.Models.cAllocation_GSI",href:"#Sindbad.Models.cAllocation_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocation_GSI")],-1)),n[569]||(n[569]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[570]||(n[570]=l("p",null,"Dynamically allocates carbon based on temperature, water, and radiation stressors following the GSI approach.",-1)),n[571]||(n[571]=l("p",null,[l("strong",null,"Parameters")],-1)),n[572]||(n[572]=l("ul",null,[l("li",null,"None")],-1)),n[573]||(n[573]=l("p",null,[l("strong",null,"Methods:")],-1)),n[574]||(n[574]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[575]||(n[575]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])])],-1)),n[576]||(n[576]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[577]||(n[577]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_two"),o(": a type stable 2")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])],-1)),n[578]||(n[578]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[579]||(n[579]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocation_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[580]||(n[580]=l("hr",null,null,-1)),n[581]||(n[581]=l("p",null,[l("strong",null,"Extended help")],-1)),n[582]||(n[582]=l("p",null,[l("em",null,"References")],-1)),n[583]||(n[583]=l("ul",null,[l("li",null,[l("p",null,"Forkel M, Carvalhais N, Schaphoff S, von Bloh W, Migliavacca M, Thurner M, Thonicke K [2014] Identifying environmental controls on vegetation greenness phenology through model–data integration. Biogeosciences, 11, 7025–7050.")]),l("li",null,[l("p",null,"Forkel, M., Migliavacca, M., Thonicke, K., Reichstein, M., Schaphoff, S., Weber, U., Carvalhais, N. (2015). Codominant water control on global interannual variability and trends in land surface phenology & greenness.")]),l("li",null,[l("p",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")]),l("li",null,[l("p",null,'Jolly, William M., Ramakrishna Nemani, & Steven W. Running. "A generalized, bioclimatic index to predict foliar phenology in response to climate." Global Change Biology 11.4 [2005]: 619-632.')]),l("li",null,[l("p",null,"Sharpe PJH, Rykiel EJ (1991) Modelling integrated response of plants to multiple stresses. In: Response of Plants to Multiple Stresses (eds Mooney HA, Winner WE, Pell EJ), pp. 205±224, Academic Press, San Diego, CA.")])],-1)),n[584]||(n[584]=l("p",null,[l("em",null,"Versions")],-1)),n[585]||(n[585]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[586]||(n[586]=l("p",null,[l("em",null,"Created by")],-1)),n[587]||(n[587]=l("ul",null,[l("li",null,"ncarvalhais & sbesnard")],-1)),n[588]||(n[588]=l("p",null,"NotesCheck if we can partition C to leaf & wood constrained by interception of light.",-1))])]),_:1}),e(s,{label:"cAllocation_fixed"},{default:i(()=>[l("details",bl,[l("summary",null,[n[589]||(n[589]=l("a",{id:"Sindbad.Models.cAllocation_fixed",href:"#Sindbad.Models.cAllocation_fixed"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocation_fixed")],-1)),n[590]||(n[590]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[591]||(n[591]=l("p",null,"Sets carbon allocation to each pool using fixed allocation parameters.",-1)),n[592]||(n[592]=l("p",null,[l("strong",null,"Parameters")],-1)),n[593]||(n[593]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"a_cVegRoot"),o(": 0.3 ∈ [0.0, 1.0] => fraction of assimilated C allocated to cRoot (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a_cVegWood"),o(": 0.3 ∈ [0.0, 1.0] => fraction of assimilated C allocated to cWood (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a_cVegLeaf"),o(": 0.4 ∈ [0.0, 1.0] => fraction of assimilated C allocated to cLeaf (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[594]||(n[594]=l("p",null,[l("strong",null,"Methods:")],-1)),n[595]||(n[595]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[596]||(n[596]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"land.land_pools = pools"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:land, :land_pools = pools)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])])])])],-1)),n[597]||(n[597]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[598]||(n[598]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_names"),o(": name of vegetation carbon pools used for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_nzix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.cVeg_zix"),o(": number of pools/layers in each vegetation carbon component")])]),l("li",null,[l("p",null,[l("code",null,"cAllocation.c_allocation_to_veg"),o(": carbon allocation to each vvegetation pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])],-1)),n[599]||(n[599]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[600]||(n[600]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocation_fixed.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[601]||(n[601]=l("hr",null,null,-1)),n[602]||(n[602]=l("p",null,[l("strong",null,"Extended help")],-1)),n[603]||(n[603]=l("p",null,[l("em",null,"References")],-1)),n[604]||(n[604]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Ciais; P.; Collatz; G.; Mahecha; M. D. Montagnani; L.; Papale; D.; Rambal; S.; & Seixas; J.: Identification of Vegetation & Soil Carbon Pools out of Equilibrium in a Process Model via Eddy Covariance & Biometric Constraints; Glob. Change Biol.; 16 2813?2829; doi: 10.1111/j.1365-2486.2009.2173.x; 2010.#")]),l("li",null,[l("p",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")])],-1)),n[605]||(n[605]=l("p",null,[l("em",null,"Versions")],-1)),n[606]||(n[606]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[607]||(n[607]=l("p",null,[l("em",null,"Created by")],-1)),n[608]||(n[608]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocation_none"},{default:i(()=>[l("details",yl,[l("summary",null,[n[609]||(n[609]=l("a",{id:"Sindbad.Models.cAllocation_none",href:"#Sindbad.Models.cAllocation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocation_none")],-1)),n[610]||(n[610]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[611]||(n[611]=l("p",null,"Sets carbon allocation to 0.",-1)),n[612]||(n[612]=l("p",null,[l("strong",null,"Parameters")],-1)),n[613]||(n[613]=l("ul",null,[l("li",null,"None")],-1)),n[614]||(n[614]=l("p",null,[l("strong",null,"Methods:")],-1)),n[615]||(n[615]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[616]||(n[616]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])],-1)),n[617]||(n[617]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[618]||(n[618]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[619]||(n[619]=l("hr",null,null,-1)),n[620]||(n[620]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4574]||(n[4574]=l("hr",null,null,-1)),n[4575]||(n[4575]=l("h3",{id:"cAllocationLAI",tabindex:"-1"},[o("cAllocationLAI "),l("a",{class:"header-anchor",href:"#cAllocationLAI","aria-label":'Permalink to "cAllocationLAI {#cAllocationLAI}"'},"​")],-1)),l("details",cl,[l("summary",null,[n[622]||(n[622]=l("a",{id:"Sindbad.Models.cAllocationLAI",href:"#Sindbad.Models.cAllocationLAI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationLAI")],-1)),n[623]||(n[623]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[624]||(n[624]=u("",4))]),l("details",vl,[n[655]||(n[655]=l("summary",null,"cAllocationLAI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationLAI_Friedlingstein1999"},{default:i(()=>[l("details",kl,[l("summary",null,[n[625]||(n[625]=l("a",{id:"Sindbad.Models.cAllocationLAI_Friedlingstein1999",href:"#Sindbad.Models.cAllocationLAI_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationLAI_Friedlingstein1999")],-1)),n[626]||(n[626]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[627]||(n[627]=l("p",null,"Estimates the effect of light limitation on carbon allocation via LAI, based on Friedlingstein et al. (1999).",-1)),n[628]||(n[628]=l("p",null,[l("strong",null,"Parameters")],-1)),n[629]||(n[629]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"kext"),o(": 0.5 ∈ [0.0, 1.0] => extinction coefficient of LAI effect on allocation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"min_f_LAI"),o(": 0.1 ∈ [0.0, 1.0] => minimum LAI effect on allocation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_f_LAI"),o(": 1.0 ∈ [0.0, 1.0] => maximum LAI effect on allocation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[630]||(n[630]=l("p",null,[l("strong",null,"Methods:")],-1)),n[631]||(n[631]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[632]||(n[632]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.LAI"),o(": leaf area index")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_LAI"),o(": effect of LAI on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[633]||(n[633]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[634]||(n[634]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationLAI_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[635]||(n[635]=l("hr",null,null,-1)),n[636]||(n[636]=l("p",null,[l("strong",null,"Extended help")],-1)),n[637]||(n[637]=l("p",null,[l("em",null,"References")],-1)),n[638]||(n[638]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[639]||(n[639]=l("p",null,[l("em",null,"Versions")],-1)),n[640]||(n[640]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[641]||(n[641]=l("p",null,[l("em",null,"Created by")],-1)),n[642]||(n[642]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocationLAI_none"},{default:i(()=>[l("details",Sl,[l("summary",null,[n[643]||(n[643]=l("a",{id:"Sindbad.Models.cAllocationLAI_none",href:"#Sindbad.Models.cAllocationLAI_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationLAI_none")],-1)),n[644]||(n[644]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[645]||(n[645]=l("p",null,"Sets the LAI effect on allocation to 1 (no effect).",-1)),n[646]||(n[646]=l("p",null,[l("strong",null,"Parameters")],-1)),n[647]||(n[647]=l("ul",null,[l("li",null,"None")],-1)),n[648]||(n[648]=l("p",null,[l("strong",null,"Methods:")],-1)),n[649]||(n[649]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[650]||(n[650]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_LAI"),o(": effect of LAI on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[651]||(n[651]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[652]||(n[652]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationLAI_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[653]||(n[653]=l("hr",null,null,-1)),n[654]||(n[654]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4576]||(n[4576]=l("hr",null,null,-1)),n[4577]||(n[4577]=l("h3",{id:"cAllocationNutrients",tabindex:"-1"},[o("cAllocationNutrients "),l("a",{class:"header-anchor",href:"#cAllocationNutrients","aria-label":'Permalink to "cAllocationNutrients {#cAllocationNutrients}"'},"​")],-1)),l("details",wl,[l("summary",null,[n[656]||(n[656]=l("a",{id:"Sindbad.Models.cAllocationNutrients",href:"#Sindbad.Models.cAllocationNutrients"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationNutrients")],-1)),n[657]||(n[657]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[658]||(n[658]=u("",4))]),l("details",Tl,[n[691]||(n[691]=l("summary",null,"cAllocationNutrients approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationNutrients_Friedlingstein1999"},{default:i(()=>[l("details",jl,[l("summary",null,[n[659]||(n[659]=l("a",{id:"Sindbad.Models.cAllocationNutrients_Friedlingstein1999",href:"#Sindbad.Models.cAllocationNutrients_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationNutrients_Friedlingstein1999")],-1)),n[660]||(n[660]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[661]||(n[661]=l("p",null,"Calculates pseudo-nutrient limitation based on Friedlingstein et al. (1999).",-1)),n[662]||(n[662]=l("p",null,[l("strong",null,"Parameters")],-1)),n[663]||(n[663]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"min_L"),o(": 0.1 ∈ [0.0, 1.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_L"),o(": 1.0 ∈ [0.0, 1.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[664]||(n[664]=l("p",null,[l("strong",null,"Methods:")],-1)),n[665]||(n[665]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[666]||(n[666]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_awc"),o(": total amount of water available for vegetation/transpiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"cAllocationNutrients.c_allocation_f_W_N"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cAllocationNutrients, :c_allocation_f_W_N)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[667]||(n[667]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[668]||(n[668]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationNutrients_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[669]||(n[669]=l("hr",null,null,-1)),n[670]||(n[670]=l("p",null,[l("strong",null,"Extended help")],-1)),n[671]||(n[671]=l("p",null,[l("em",null,"References")],-1)),n[672]||(n[672]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[673]||(n[673]=l("p",null,[l("em",null,"Notes")],-1)),n[674]||(n[674]=l("ul",null,[l("li",null,'"There is no explicit estimate of soil mineral nitrogen in the version of CASA used for these simulations. As a surrogate; we assume that spatial variability in nitrogen mineralization & soil organic matter decomposition are identical [Townsend et al. 1995]. Nitrogen availability; N; is calculated as the product of the temperature & moisture abiotic factors used in CASA for the calculation of microbial respiration [Potter et al. 1993]." in Friedlingstein et al., 1999.#')],-1)),n[675]||(n[675]=l("p",null,[l("em",null,"Versions")],-1)),n[676]||(n[676]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[677]||(n[677]=l("p",null,[l("em",null,"Created by")],-1)),n[678]||(n[678]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocationNutrients_none"},{default:i(()=>[l("details",El,[l("summary",null,[n[679]||(n[679]=l("a",{id:"Sindbad.Models.cAllocationNutrients_none",href:"#Sindbad.Models.cAllocationNutrients_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationNutrients_none")],-1)),n[680]||(n[680]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[681]||(n[681]=l("p",null,"Sets the pseudo-nutrient limitation to 1 (no effect).",-1)),n[682]||(n[682]=l("p",null,[l("strong",null,"Parameters")],-1)),n[683]||(n[683]=l("ul",null,[l("li",null,"None")],-1)),n[684]||(n[684]=l("p",null,[l("strong",null,"Methods:")],-1)),n[685]||(n[685]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[686]||(n[686]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_W_N"),o(": effect of water and nutrient on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[687]||(n[687]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[688]||(n[688]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationNutrients_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[689]||(n[689]=l("hr",null,null,-1)),n[690]||(n[690]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4578]||(n[4578]=l("hr",null,null,-1)),n[4579]||(n[4579]=l("h3",{id:"cAllocationRadiation",tabindex:"-1"},[o("cAllocationRadiation "),l("a",{class:"header-anchor",href:"#cAllocationRadiation","aria-label":'Permalink to "cAllocationRadiation {#cAllocationRadiation}"'},"​")],-1)),l("details",xl,[l("summary",null,[n[692]||(n[692]=l("a",{id:"Sindbad.Models.cAllocationRadiation",href:"#Sindbad.Models.cAllocationRadiation"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationRadiation")],-1)),n[693]||(n[693]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[694]||(n[694]=u("",4))]),l("details",Cl,[n[763]||(n[763]=l("summary",null,"cAllocationRadiation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationRadiation_GSI"},{default:i(()=>[l("details",Ml,[l("summary",null,[n[695]||(n[695]=l("a",{id:"Sindbad.Models.cAllocationRadiation_GSI",href:"#Sindbad.Models.cAllocationRadiation_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationRadiation_GSI")],-1)),n[696]||(n[696]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[697]||(n[697]=l("p",null,"Calculates the radiation effect on allocation using the GSI method.",-1)),n[698]||(n[698]=l("p",null,[l("strong",null,"Parameters")],-1)),n[699]||(n[699]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"τ_rad"),o(": 0.02 ∈ [0.001, 1.0] => temporal change rate for the light-limiting function ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"slope_rad"),o(": 1.0 ∈ [0.01, 200.0] => slope parameters of a logistic function based on mean daily y shortwave downward radiation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"base_rad"),o(": 10.0 ∈ [0.0, 100.0] => inflection point parameters of a logistic function based on mean daily y shortwave downward radiation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[700]||(n[700]=l("p",null,[l("strong",null,"Methods:")],-1)),n[701]||(n[701]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[702]||(n[702]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[703]||(n[703]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[704]||(n[704]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_PAR"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_PAR)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_c_allocation_f_cloud"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_c_allocation_f_cloud)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[705]||(n[705]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[706]||(n[706]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationRadiation_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[707]||(n[707]=l("hr",null,null,-1)),n[708]||(n[708]=l("p",null,[l("strong",null,"Extended help")],-1)),n[709]||(n[709]=l("p",null,[l("em",null,"References")],-1)),n[710]||(n[710]=l("ul",null,[l("li",null,[l("p",null,"Forkel M, Carvalhais N, Schaphoff S, von Bloh W, Migliavacca M, Thurner M, Thonicke K [2014] Identifying environmental controls on vegetation greenness phenology through model–data integration. Biogeosciences, 11, 7025–7050.")]),l("li",null,[l("p",null,"Forkel, M., Migliavacca, M., Thonicke, K., Reichstein, M., Schaphoff, S., Weber, U., Carvalhais, N. (2015). Codominant water control on global interannual variability and trends in land surface phenology & greenness.")]),l("li",null,[l("p",null,'Jolly, William M., Ramakrishna Nemani, & Steven W. Running. "A generalized, bioclimatic index to predict foliar phenology in response to climate." Global Change Biology 11.4 [2005]: 619-632.')])],-1)),n[711]||(n[711]=l("p",null,[l("em",null,"Versions")],-1)),n[712]||(n[712]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [skoirala | @dr-ko]")],-1)),n[713]||(n[713]=l("p",null,[l("em",null,"Created by")],-1)),n[714]||(n[714]=l("ul",null,[l("li",null,"ncarvalhais, sbesnard, skoirala")],-1))])]),_:1}),e(s,{label:"cAllocationRadiation_RgPot"},{default:i(()=>[l("details",Il,[l("summary",null,[n[715]||(n[715]=l("a",{id:"Sindbad.Models.cAllocationRadiation_RgPot",href:"#Sindbad.Models.cAllocationRadiation_RgPot"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationRadiation_RgPot")],-1)),n[716]||(n[716]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[717]||(n[717]=l("p",null,"Calculates the radiation effect on allocation using potential radiation instead of actual radiation.",-1)),n[718]||(n[718]=l("p",null,[l("strong",null,"Parameters")],-1)),n[719]||(n[719]=l("ul",null,[l("li",null,"None")],-1)),n[720]||(n[720]=l("p",null,[l("strong",null,"Methods:")],-1)),n[721]||(n[721]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[722]||(n[722]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"cAllocationRadiation.rg_pot_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cAllocationRadiation, :rg_pot_max)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[723]||(n[723]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[724]||(n[724]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cAllocationRadiation.rg_pot_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cAllocationRadiation, :rg_pot_max)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_cloud"),o(": effect of cloud on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.rg_pot_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :rg_pot_max)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[725]||(n[725]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[726]||(n[726]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationRadiation_RgPot.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[727]||(n[727]=l("hr",null,null,-1)),n[728]||(n[728]=l("p",null,[l("strong",null,"Extended help")],-1)),n[729]||(n[729]=l("p",null,[l("em",null,"References")],-1)),n[730]||(n[730]=l("p",null,[l("em",null,"Versions")],-1)),n[731]||(n[731]=l("ul",null,[l("li",null,"1.0 on 07.05.2025 [skoirala]")],-1)),n[732]||(n[732]=l("p",null,[l("em",null,"Created by")],-1)),n[733]||(n[733]=l("ul",null,[l("li",null,"skoirala")],-1))])]),_:1}),e(s,{label:"cAllocationRadiation_gpp"},{default:i(()=>[l("details",Al,[l("summary",null,[n[734]||(n[734]=l("a",{id:"Sindbad.Models.cAllocationRadiation_gpp",href:"#Sindbad.Models.cAllocationRadiation_gpp"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationRadiation_gpp")],-1)),n[735]||(n[735]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[736]||(n[736]=l("p",null,"Sets the radiation effect on allocation equal to that for GPP.",-1)),n[737]||(n[737]=l("p",null,[l("strong",null,"Parameters")],-1)),n[738]||(n[738]=l("ul",null,[l("li",null,"None")],-1)),n[739]||(n[739]=l("p",null,[l("strong",null,"Methods:")],-1)),n[740]||(n[740]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[741]||(n[741]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_cloud"),o(": effect of cloud on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[742]||(n[742]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[743]||(n[743]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationRadiation_gpp.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[744]||(n[744]=l("hr",null,null,-1)),n[745]||(n[745]=l("p",null,[l("strong",null,"Extended help")],-1)),n[746]||(n[746]=l("p",null,[l("em",null,"References")],-1)),n[747]||(n[747]=l("p",null,[l("em",null,"Versions")],-1)),n[748]||(n[748]=l("ul",null,[l("li",null,"1.0 on 26.01.2021 [skoirala | @dr-ko]")],-1)),n[749]||(n[749]=l("p",null,[l("em",null,"Created by")],-1)),n[750]||(n[750]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"cAllocationRadiation_none"},{default:i(()=>[l("details",Pl,[l("summary",null,[n[751]||(n[751]=l("a",{id:"Sindbad.Models.cAllocationRadiation_none",href:"#Sindbad.Models.cAllocationRadiation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationRadiation_none")],-1)),n[752]||(n[752]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[753]||(n[753]=l("p",null,"Sets the radiation effect on allocation to 1 (no effect).",-1)),n[754]||(n[754]=l("p",null,[l("strong",null,"Parameters")],-1)),n[755]||(n[755]=l("ul",null,[l("li",null,"None")],-1)),n[756]||(n[756]=l("p",null,[l("strong",null,"Methods:")],-1)),n[757]||(n[757]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[758]||(n[758]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_cloud"),o(": effect of cloud on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[759]||(n[759]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[760]||(n[760]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationRadiation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[761]||(n[761]=l("hr",null,null,-1)),n[762]||(n[762]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4580]||(n[4580]=l("hr",null,null,-1)),n[4581]||(n[4581]=l("h3",{id:"cAllocationSoilT",tabindex:"-1"},[o("cAllocationSoilT "),l("a",{class:"header-anchor",href:"#cAllocationSoilT","aria-label":'Permalink to "cAllocationSoilT {#cAllocationSoilT}"'},"​")],-1)),l("details",Rl,[l("summary",null,[n[764]||(n[764]=l("a",{id:"Sindbad.Models.cAllocationSoilT",href:"#Sindbad.Models.cAllocationSoilT"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilT")],-1)),n[765]||(n[765]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[766]||(n[766]=u("",4))]),l("details",Vl,[n[834]||(n[834]=l("summary",null,"cAllocationSoilT approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationSoilT_Friedlingstein1999"},{default:i(()=>[l("details",Wl,[l("summary",null,[n[767]||(n[767]=l("a",{id:"Sindbad.Models.cAllocationSoilT_Friedlingstein1999",href:"#Sindbad.Models.cAllocationSoilT_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilT_Friedlingstein1999")],-1)),n[768]||(n[768]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[769]||(n[769]=l("p",null,"Calculates the partial temperature effect on decomposition and mineralization based on Friedlingstein et al. (1999).",-1)),n[770]||(n[770]=l("p",null,[l("strong",null,"Parameters")],-1)),n[771]||(n[771]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"min_f_soilT"),o(": 0.5 ∈ [0.0, 1.0] => minimum allocation coefficient from temperature stress ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_f_soilT"),o(": 1.0 ∈ [0.0, 1.0] => maximum allocation coefficient from temperature stress ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[772]||(n[772]=l("p",null,[l("strong",null,"Methods:")],-1)),n[773]||(n[773]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[774]||(n[774]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[775]||(n[775]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[776]||(n[776]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilT_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[777]||(n[777]=l("hr",null,null,-1)),n[778]||(n[778]=l("p",null,[l("strong",null,"Extended help")],-1)),n[779]||(n[779]=l("p",null,[l("em",null,"References")],-1)),n[780]||(n[780]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[781]||(n[781]=l("p",null,[l("em",null,"Versions")],-1)),n[782]||(n[782]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[783]||(n[783]=l("p",null,[l("em",null,"Created by")],-1)),n[784]||(n[784]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocationSoilT_gpp"},{default:i(()=>[l("details",Dl,[l("summary",null,[n[785]||(n[785]=l("a",{id:"Sindbad.Models.cAllocationSoilT_gpp",href:"#Sindbad.Models.cAllocationSoilT_gpp"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilT_gpp")],-1)),n[786]||(n[786]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[787]||(n[787]=l("p",null,"Sets the temperature effect on allocation equal to that for GPP.",-1)),n[788]||(n[788]=l("p",null,[l("strong",null,"Parameters")],-1)),n[789]||(n[789]=l("ul",null,[l("li",null,"None")],-1)),n[790]||(n[790]=l("p",null,[l("strong",null,"Methods:")],-1)),n[791]||(n[791]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[792]||(n[792]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[793]||(n[793]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[794]||(n[794]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilT_gpp.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[795]||(n[795]=l("hr",null,null,-1)),n[796]||(n[796]=l("p",null,[l("strong",null,"Extended help")],-1)),n[797]||(n[797]=l("p",null,[l("em",null,"References")],-1)),n[798]||(n[798]=l("p",null,[l("em",null,"Versions")],-1)),n[799]||(n[799]=l("ul",null,[l("li",null,"1.0 on 26.01.2021 [skoirala | @dr-ko]")],-1)),n[800]||(n[800]=l("p",null,[l("em",null,"Created by")],-1)),n[801]||(n[801]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"cAllocationSoilT_gppGSI"},{default:i(()=>[l("details",Fl,[l("summary",null,[n[802]||(n[802]=l("a",{id:"Sindbad.Models.cAllocationSoilT_gppGSI",href:"#Sindbad.Models.cAllocationSoilT_gppGSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilT_gppGSI")],-1)),n[803]||(n[803]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[804]||(n[804]=l("p",null,"Calculates the temperature effect on allocation as for GPP using the GSI approach.",-1)),n[805]||(n[805]=l("p",null,[l("strong",null,"Parameters")],-1)),n[806]||(n[806]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"τ_Tsoil"),o(": 0.2 ∈ [0.001, 1.0] => temporal change rate for the temperature-limiting function ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[807]||(n[807]=l("p",null,[l("strong",null,"Methods:")],-1)),n[808]||(n[808]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[809]||(n[809]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilT_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilT_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[810]||(n[810]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[811]||(n[811]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilT_prev)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilT_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[812]||(n[812]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[813]||(n[813]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilT_gppGSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[814]||(n[814]=l("hr",null,null,-1)),n[815]||(n[815]=l("p",null,[l("strong",null,"Extended help")],-1)),n[816]||(n[816]=l("p",null,[l("em",null,"References")],-1)),n[817]||(n[817]=l("ul",null,[l("li",null,[l("p",null,"Forkel M, Carvalhais N, Schaphoff S, von Bloh W, Migliavacca M, Thurner M, Thonicke K [2014] Identifying environmental controls on vegetation greenness phenology through model–data integration. Biogeosciences, 11, 7025–7050.")]),l("li",null,[l("p",null,"Forkel, M., Migliavacca, M., Thonicke, K., Reichstein, M., Schaphoff, S., Weber, U., Carvalhais, N. (2015). Codominant water control on global interannual variability and trends in land surface phenology & greenness.")]),l("li",null,[l("p",null,'Jolly, William M., Ramakrishna Nemani, & Steven W. Running. "A generalized, bioclimatic index to predict foliar phenology in response to climate." Global Change Biology 11.4 [2005]: 619-632.')])],-1)),n[818]||(n[818]=l("p",null,[l("em",null,"Versions")],-1)),n[819]||(n[819]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[820]||(n[820]=l("p",null,[l("em",null,"Created by")],-1)),n[821]||(n[821]=l("ul",null,[l("li",null,"ncarvalhais & sbesnard")],-1))])]),_:1}),e(s,{label:"cAllocationSoilT_none"},{default:i(()=>[l("details",Nl,[l("summary",null,[n[822]||(n[822]=l("a",{id:"Sindbad.Models.cAllocationSoilT_none",href:"#Sindbad.Models.cAllocationSoilT_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilT_none")],-1)),n[823]||(n[823]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[824]||(n[824]=l("p",null,"Sets the temperature effect on allocation to 1 (no effect).",-1)),n[825]||(n[825]=l("p",null,[l("strong",null,"Parameters")],-1)),n[826]||(n[826]=l("ul",null,[l("li",null,"None")],-1)),n[827]||(n[827]=l("p",null,[l("strong",null,"Methods:")],-1)),n[828]||(n[828]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[829]||(n[829]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[830]||(n[830]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[831]||(n[831]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilT_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[832]||(n[832]=l("hr",null,null,-1)),n[833]||(n[833]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4582]||(n[4582]=l("hr",null,null,-1)),n[4583]||(n[4583]=l("h3",{id:"cAllocationSoilW",tabindex:"-1"},[o("cAllocationSoilW "),l("a",{class:"header-anchor",href:"#cAllocationSoilW","aria-label":'Permalink to "cAllocationSoilW {#cAllocationSoilW}"'},"​")],-1)),l("details",Ol,[l("summary",null,[n[835]||(n[835]=l("a",{id:"Sindbad.Models.cAllocationSoilW",href:"#Sindbad.Models.cAllocationSoilW"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilW")],-1)),n[836]||(n[836]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[837]||(n[837]=u("",4))]),l("details",Bl,[n[905]||(n[905]=l("summary",null,"cAllocationSoilW approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationSoilW_Friedlingstein1999"},{default:i(()=>[l("details",Gl,[l("summary",null,[n[838]||(n[838]=l("a",{id:"Sindbad.Models.cAllocationSoilW_Friedlingstein1999",href:"#Sindbad.Models.cAllocationSoilW_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilW_Friedlingstein1999")],-1)),n[839]||(n[839]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[840]||(n[840]=l("p",null,"Calculates the partial moisture effect on decomposition and mineralization based on Friedlingstein et al. (1999).",-1)),n[841]||(n[841]=l("p",null,[l("strong",null,"Parameters")],-1)),n[842]||(n[842]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"min_f_soilW"),o(": 0.5 ∈ [0.0, 1.0] => minimum value for moisture stressor ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_f_soilW"),o(": 0.8 ∈ [0.0, 1.0] => maximum value for moisture stressor ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[843]||(n[843]=l("p",null,[l("strong",null,"Methods:")],-1)),n[844]||(n[844]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[845]||(n[845]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[846]||(n[846]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[847]||(n[847]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilW_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[848]||(n[848]=l("hr",null,null,-1)),n[849]||(n[849]=l("p",null,[l("strong",null,"Extended help")],-1)),n[850]||(n[850]=l("p",null,[l("em",null,"References")],-1)),n[851]||(n[851]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[852]||(n[852]=l("p",null,[l("em",null,"Versions")],-1)),n[853]||(n[853]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[854]||(n[854]=l("p",null,[l("em",null,"Created by")],-1)),n[855]||(n[855]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cAllocationSoilW_gpp"},{default:i(()=>[l("details",Ll,[l("summary",null,[n[856]||(n[856]=l("a",{id:"Sindbad.Models.cAllocationSoilW_gpp",href:"#Sindbad.Models.cAllocationSoilW_gpp"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilW_gpp")],-1)),n[857]||(n[857]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[858]||(n[858]=l("p",null,"Sets the moisture effect on allocation equal to that for GPP.",-1)),n[859]||(n[859]=l("p",null,[l("strong",null,"Parameters")],-1)),n[860]||(n[860]=l("ul",null,[l("li",null,"None")],-1)),n[861]||(n[861]=l("p",null,[l("strong",null,"Methods:")],-1)),n[862]||(n[862]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[863]||(n[863]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[864]||(n[864]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[865]||(n[865]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilW_gpp.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[866]||(n[866]=l("hr",null,null,-1)),n[867]||(n[867]=l("p",null,[l("strong",null,"Extended help")],-1)),n[868]||(n[868]=l("p",null,[l("em",null,"References")],-1)),n[869]||(n[869]=l("p",null,[l("em",null,"Versions")],-1)),n[870]||(n[870]=l("ul",null,[l("li",null,"1.0 on 26.01.2021 [skoirala | @dr-ko]")],-1)),n[871]||(n[871]=l("p",null,[l("em",null,"Created by")],-1)),n[872]||(n[872]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"cAllocationSoilW_gppGSI"},{default:i(()=>[l("details",zl,[l("summary",null,[n[873]||(n[873]=l("a",{id:"Sindbad.Models.cAllocationSoilW_gppGSI",href:"#Sindbad.Models.cAllocationSoilW_gppGSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilW_gppGSI")],-1)),n[874]||(n[874]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[875]||(n[875]=l("p",null,"Calculates the moisture effect on allocation as for GPP using the GSI approach.",-1)),n[876]||(n[876]=l("p",null,[l("strong",null,"Parameters")],-1)),n[877]||(n[877]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"τ_soilW"),o(": 0.8 ∈ [0.001, 1.0] => temporal change rate for the water-limiting function ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[878]||(n[878]=l("p",null,[l("strong",null,"Methods:")],-1)),n[879]||(n[879]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[880]||(n[880]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[881]||(n[881]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[882]||(n[882]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_allocation_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[883]||(n[883]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[884]||(n[884]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilW_gppGSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[885]||(n[885]=l("hr",null,null,-1)),n[886]||(n[886]=l("p",null,[l("strong",null,"Extended help")],-1)),n[887]||(n[887]=l("p",null,[l("em",null,"References")],-1)),n[888]||(n[888]=l("ul",null,[l("li",null,[l("p",null,"Forkel M, Carvalhais N, Schaphoff S, von Bloh W, Migliavacca M, Thurner M, Thonicke K [2014] Identifying environmental controls on vegetation greenness phenology through model–data integration. Biogeosciences, 11, 7025–7050.")]),l("li",null,[l("p",null,"Forkel, M., Migliavacca, M., Thonicke, K., Reichstein, M., Schaphoff, S., Weber, U., Carvalhais, N. (2015). Codominant water control on global interannual variability and trends in land surface phenology & greenness.")]),l("li",null,[l("p",null,'Jolly, William M., Ramakrishna Nemani, & Steven W. Running. "A generalized, bioclimatic index to predict foliar phenology in response to climate." Global Change Biology 11.4 [2005]: 619-632.')])],-1)),n[889]||(n[889]=l("p",null,[l("em",null,"Versions")],-1)),n[890]||(n[890]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[891]||(n[891]=l("p",null,[l("em",null,"Created by")],-1)),n[892]||(n[892]=l("ul",null,[l("li",null,"ncarvalhais & sbesnard")],-1))])]),_:1}),e(s,{label:"cAllocationSoilW_none"},{default:i(()=>[l("details",Ul,[l("summary",null,[n[893]||(n[893]=l("a",{id:"Sindbad.Models.cAllocationSoilW_none",href:"#Sindbad.Models.cAllocationSoilW_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationSoilW_none")],-1)),n[894]||(n[894]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[895]||(n[895]=l("p",null,"Sets the moisture effect on allocation to 1 (no effect).",-1)),n[896]||(n[896]=l("p",null,[l("strong",null,"Parameters")],-1)),n[897]||(n[897]=l("ul",null,[l("li",null,"None")],-1)),n[898]||(n[898]=l("p",null,[l("strong",null,"Methods:")],-1)),n[899]||(n[899]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[900]||(n[900]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])])])],-1)),n[901]||(n[901]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[902]||(n[902]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationSoilW_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[903]||(n[903]=l("hr",null,null,-1)),n[904]||(n[904]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4584]||(n[4584]=l("hr",null,null,-1)),n[4585]||(n[4585]=l("h3",{id:"cAllocationTreeFraction",tabindex:"-1"},[o("cAllocationTreeFraction "),l("a",{class:"header-anchor",href:"#cAllocationTreeFraction","aria-label":'Permalink to "cAllocationTreeFraction {#cAllocationTreeFraction}"'},"​")],-1)),l("details",Jl,[l("summary",null,[n[906]||(n[906]=l("a",{id:"Sindbad.Models.cAllocationTreeFraction",href:"#Sindbad.Models.cAllocationTreeFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationTreeFraction")],-1)),n[907]||(n[907]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[908]||(n[908]=u("",4))]),l("details",Kl,[n[929]||(n[929]=l("summary",null,"cAllocationTreeFraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cAllocationTreeFraction_Friedlingstein1999"},{default:i(()=>[l("details",Hl,[l("summary",null,[n[909]||(n[909]=l("a",{id:"Sindbad.Models.cAllocationTreeFraction_Friedlingstein1999",href:"#Sindbad.Models.cAllocationTreeFraction_Friedlingstein1999"},[l("span",{class:"jlbinding"},"Sindbad.Models.cAllocationTreeFraction_Friedlingstein1999")],-1)),n[910]||(n[910]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[911]||(n[911]=l("p",null,"Adjusts allocation coefficients according to the fraction of trees to herbaceous plants and fine to coarse root partitioning.",-1)),n[912]||(n[912]=l("p",null,[l("strong",null,"Parameters")],-1)),n[913]||(n[913]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"frac_fine_to_coarse"),o(": 1.0 ∈ [0.0, 1.0] => carbon fraction allocated to fine roots (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[914]||(n[914]=l("p",null,[l("strong",null,"Methods:")],-1)),n[915]||(n[915]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[916]||(n[916]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"cAllocationTreeFraction.cVeg_names_for_c_allocation_frac_tree"),o(": name of vegetation carbon pools used in tree fraction correction for carbon allocation")])])])],-1)),n[917]||(n[917]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[918]||(n[918]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.frac_tree"),o(": fractional coverage of grid with trees")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"cAllocationTreeFraction.cVeg_names_for_c_allocation_frac_tree"),o(": name of vegetation carbon pools used in tree fraction correction for carbon allocation")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])])])],-1)),n[919]||(n[919]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[920]||(n[920]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cAllocationTreeFraction_Friedlingstein1999.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[921]||(n[921]=l("hr",null,null,-1)),n[922]||(n[922]=l("p",null,[l("strong",null,"Extended help")],-1)),n[923]||(n[923]=l("p",null,[l("em",null,"References")],-1)),n[924]||(n[924]=l("ul",null,[l("li",null,"Friedlingstein; P.; G. Joel; C.B. Field; & I.Y. Fung; 1999: Toward an allocation scheme for global terrestrial carbon models. Glob. Change Biol.; 5; 755-770; doi:10.1046/j.1365-2486.1999.00269.x.")],-1)),n[925]||(n[925]=l("p",null,[l("em",null,"Versions")],-1)),n[926]||(n[926]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[927]||(n[927]=l("p",null,[l("em",null,"Created by")],-1)),n[928]||(n[928]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4586]||(n[4586]=l("hr",null,null,-1)),n[4587]||(n[4587]=l("h3",{id:"cBiomass",tabindex:"-1"},[o("cBiomass "),l("a",{class:"header-anchor",href:"#cBiomass","aria-label":'Permalink to "cBiomass {#cBiomass}"'},"​")],-1)),l("details",ql,[l("summary",null,[n[930]||(n[930]=l("a",{id:"Sindbad.Models.cBiomass",href:"#Sindbad.Models.cBiomass"},[l("span",{class:"jlbinding"},"Sindbad.Models.cBiomass")],-1)),n[931]||(n[931]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[932]||(n[932]=u("",4))]),l("details",Zl,[n[980]||(n[980]=l("summary",null,"cBiomass approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cBiomass_simple"},{default:i(()=>[l("details",Ql,[l("summary",null,[n[933]||(n[933]=l("a",{id:"Sindbad.Models.cBiomass_simple",href:"#Sindbad.Models.cBiomass_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.cBiomass_simple")],-1)),n[934]||(n[934]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[935]||(n[935]=l("p",null,[o("Calculates AGB "),l("code",null,"simply"),o(" as the sum of wood and leaf carbon pools.")],-1)),n[936]||(n[936]=l("p",null,[l("strong",null,"Parameters")],-1)),n[937]||(n[937]=l("ul",null,[l("li",null,"None")],-1)),n[938]||(n[938]=l("p",null,[l("strong",null,"Methods:")],-1)),n[939]||(n[939]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[940]||(n[940]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cVegWood"),o(": carbon content of cVegWood pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.aboveground_biomass"),o(": carbon content on the cVegWood component")])])])],-1)),n[941]||(n[941]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[942]||(n[942]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cBiomass_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[943]||(n[943]=l("hr",null,null,-1)),n[944]||(n[944]=l("p",null,[l("strong",null,"Extended help")],-1)),n[945]||(n[945]=l("p",null,[l("em",null,"References")],-1)),n[946]||(n[946]=l("p",null,[l("em",null,"Versions")],-1)),n[947]||(n[947]=l("p",null,[l("em",null,"Created by")],-1))])]),_:1}),e(s,{label:"cBiomass_treeGrass"},{default:i(()=>[l("details",Yl,[l("summary",null,[n[948]||(n[948]=l("a",{id:"Sindbad.Models.cBiomass_treeGrass",href:"#Sindbad.Models.cBiomass_treeGrass"},[l("span",{class:"jlbinding"},"Sindbad.Models.cBiomass_treeGrass")],-1)),n[949]||(n[949]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[950]||(n[950]=l("p",null,"Considers the tree-grass fraction to include different vegetation pools while calculating AGB. For Eddy Covariance sites with tree cover, AGB = leaf + wood biomass. For grass-only sites, AGB is set to the wood biomass, which is constrained to be near 0 after optimization.",-1)),n[951]||(n[951]=l("p",null,[l("strong",null,"Parameters")],-1)),n[952]||(n[952]=l("ul",null,[l("li",null,"None")],-1)),n[953]||(n[953]=l("p",null,[l("strong",null,"Methods:")],-1)),n[954]||(n[954]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[955]||(n[955]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cVegWood"),o(": carbon content of cVegWood pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_tree"),o(": fractional coverage of grid with trees")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.aboveground_biomass"),o(": carbon content on the cVegWood component")])])])],-1)),n[956]||(n[956]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[957]||(n[957]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cBiomass_treeGrass.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[958]||(n[958]=l("hr",null,null,-1)),n[959]||(n[959]=l("p",null,[l("strong",null,"Extended help")],-1)),n[960]||(n[960]=l("p",null,[l("em",null,"References")],-1)),n[961]||(n[961]=l("p",null,[l("em",null,"Versions")],-1)),n[962]||(n[962]=l("p",null,[l("em",null,"Created by")],-1))])]),_:1}),e(s,{label:"cBiomass_treeGrass_cVegReserveScaling"},{default:i(()=>[l("details",Xl,[l("summary",null,[n[963]||(n[963]=l("a",{id:"Sindbad.Models.cBiomass_treeGrass_cVegReserveScaling",href:"#Sindbad.Models.cBiomass_treeGrass_cVegReserveScaling"},[l("span",{class:"jlbinding"},"Sindbad.Models.cBiomass_treeGrass_cVegReserveScaling")],-1)),n[964]||(n[964]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[965]||(n[965]=l("p",null,[o("Same as "),l("code",null,"cBiomass_treeGrass"),o(".jl, but includes scaling for the relative fraction of the reserve carbon to not allow for large reserve compared to the rest of the vegetation carbol pool.")],-1)),n[966]||(n[966]=l("p",null,[l("strong",null,"Parameters")],-1)),n[967]||(n[967]=l("ul",null,[l("li",null,"None")],-1)),n[968]||(n[968]=l("p",null,[l("strong",null,"Methods:")],-1)),n[969]||(n[969]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[970]||(n[970]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cVegWood"),o(": carbon content of cVegWood pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegReserve"),o(": carbon content of cVegReserve pool(s) that does not respire")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegRoot"),o(": carbon content of cVegRoot pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_tree"),o(": fractional coverage of grid with trees")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.aboveground_biomass"),o(": carbon content on the cVegWood component")])])])],-1)),n[971]||(n[971]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[972]||(n[972]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cBiomass_treeGrass_cVegReserveScaling.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[973]||(n[973]=l("hr",null,null,-1)),n[974]||(n[974]=l("p",null,[l("strong",null,"Extended help")],-1)),n[975]||(n[975]=l("p",null,[l("em",null,"References")],-1)),n[976]||(n[976]=l("p",null,[l("em",null,"Versions")],-1)),n[977]||(n[977]=l("ul",null,[l("li",null,"1.0 on 07.05.2025 [skoirala]")],-1)),n[978]||(n[978]=l("p",null,[l("em",null,"Created by")],-1)),n[979]||(n[979]=l("ul",null,[l("li",null,"skoirala")],-1))])]),_:1})]),_:1})]),n[4588]||(n[4588]=l("hr",null,null,-1)),n[4589]||(n[4589]=l("h3",{id:"cCycle",tabindex:"-1"},[o("cCycle "),l("a",{class:"header-anchor",href:"#cCycle","aria-label":'Permalink to "cCycle {#cCycle}"'},"​")],-1)),l("details",$l,[l("summary",null,[n[981]||(n[981]=l("a",{id:"Sindbad.Models.cCycle",href:"#Sindbad.Models.cCycle"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycle")],-1)),n[982]||(n[982]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[983]||(n[983]=u("",4))]),l("details",hl,[n[1044]||(n[1044]=l("summary",null,"cCycle approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cCycle_CASA"},{default:i(()=>[l("details",_l,[l("summary",null,[n[984]||(n[984]=l("a",{id:"Sindbad.Models.cCycle_CASA",href:"#Sindbad.Models.cCycle_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycle_CASA")],-1)),n[985]||(n[985]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[986]||(n[986]=l("p",null,"Carbon cycle wtih components based on the CASA approach.",-1)),n[987]||(n[987]=l("p",null,[l("strong",null,"Parameters")],-1)),n[988]||(n[988]=l("ul",null,[l("li",null,"None")],-1)),n[989]||(n[989]=l("p",null,[l("strong",null,"Methods:")],-1)),n[990]||(n[990]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[991]||(n[991]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_efflux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_efflux)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_influx"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_influx)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_flow"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_flow)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[992]||(n[992]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[993]||(n[993]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_efflux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_efflux)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_influx"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_influx)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycle.c_eco_flow"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cCycle, :c_eco_flow)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_E_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_E_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_giver"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_giver)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_taker"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_taker)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.nee"),o(": net ecosystem carbon exchange for the ecosystem. negative value indicates carbon sink.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration"),o(": carbon loss due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.eco_respiration"),o(": carbon loss due to ecosystem respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.hetero_respiration"),o(": carbon loss due to heterotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"states.c_eco_efflux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_efflux)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.c_eco_flow"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_flow)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.c_eco_influx"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_influx)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.c_eco_out"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_out)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.c_eco_npp"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :c_eco_npp)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[994]||(n[994]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[995]||(n[995]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycle_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[996]||(n[996]=l("hr",null,null,-1)),n[997]||(n[997]=l("p",null,[l("strong",null,"Extended help")],-1)),n[998]||(n[998]=l("p",null,[l("em",null,"References")],-1)),n[999]||(n[999]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1e3]||(n[1e3]=l("p",null,[l("em",null,"Versions")],-1)),n[1001]||(n[1001]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [sbesnard]")],-1)),n[1002]||(n[1002]=l("p",null,[l("em",null,"Created by")],-1)),n[1003]||(n[1003]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycle_GSI"},{default:i(()=>[l("details",ln,[l("summary",null,[n[1004]||(n[1004]=l("a",{id:"Sindbad.Models.cCycle_GSI",href:"#Sindbad.Models.cCycle_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycle_GSI")],-1)),n[1005]||(n[1005]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1006]||(n[1006]=l("p",null,"Carbon cycle with components based on the GSI approach, including carbon allocation, transfers, and turnover rates.",-1)),n[1007]||(n[1007]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1008]||(n[1008]=l("ul",null,[l("li",null,"None")],-1)),n[1009]||(n[1009]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1010]||(n[1010]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1011]||(n[1011]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_flow"),o(": helper for resetting c_eco_flow in every time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_influx"),o(": helper for resetting c_eco_influx in every time step")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔcEco"),o(": change in water storage in cEco pool(s)")])])])])],-1)),n[1012]||(n[1012]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1013]||(n[1013]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation"),o(": fraction of gpp allocated to different (live) carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_flow"),o(": helper for resetting c_eco_flow in every time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_influx"),o(": helper for resetting c_eco_influx in every time step")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔcEco"),o(": change in water storage in cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.nee"),o(": net ecosystem carbon exchange for the ecosystem. negative value indicates carbon sink.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.npp"),o(": net primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration"),o(": carbon loss due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.eco_respiration"),o(": carbon loss due to ecosystem respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.hetero_respiration"),o(": carbon loss due to heterotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔcEco"),o(": change in water storage in cEco pool(s)")])])])])],-1)),n[1014]||(n[1014]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1015]||(n[1015]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycle_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1016]||(n[1016]=l("hr",null,null,-1)),n[1017]||(n[1017]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1018]||(n[1018]=l("p",null,[l("em",null,"References")],-1)),n[1019]||(n[1019]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1020]||(n[1020]=l("p",null,[l("em",null,"Versions")],-1)),n[1021]||(n[1021]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [sbesnard]")],-1)),n[1022]||(n[1022]=l("p",null,[l("em",null,"Created by")],-1)),n[1023]||(n[1023]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycle_simple"},{default:i(()=>[l("details",nn,[l("summary",null,[n[1024]||(n[1024]=l("a",{id:"Sindbad.Models.cCycle_simple",href:"#Sindbad.Models.cCycle_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycle_simple")],-1)),n[1025]||(n[1025]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1026]||(n[1026]=l("p",null,"Carbon cycle with components based on the simplified version of the CASA approach.",-1)),n[1027]||(n[1027]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1028]||(n[1028]=l("ul",null,[l("li",null,"None")],-1)),n[1029]||(n[1029]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1030]||(n[1030]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1031]||(n[1031]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycle.zixVeg"),o(": a vector of indices for vegetation pools within the array of carbon pools in cEco")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_flow"),o(": helper for resetting c_eco_flow in every time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_influx"),o(": helper for resetting c_eco_influx in every time step")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.nee"),o(": net ecosystem carbon exchange for the ecosystem. negative value indicates carbon sink.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.npp"),o(": net primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration"),o(": carbon loss due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.eco_respiration"),o(": carbon loss due to ecosystem respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.hetero_respiration"),o(": carbon loss due to heterotrophic respiration")])])])])],-1)),n[1032]||(n[1032]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1033]||(n[1033]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycle.zixVeg"),o(": a vector of indices for vegetation pools within the array of carbon pools in cEco")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_flow"),o(": helper for resetting c_eco_flow in every time step")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.zero_c_eco_influx"),o(": helper for resetting c_eco_influx in every time step")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔcEco"),o(": change in water storage in cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.nee"),o(": net ecosystem carbon exchange for the ecosystem. negative value indicates carbon sink.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.npp"),o(": net primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.auto_respiration"),o(": carbon loss due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.eco_respiration"),o(": carbon loss due to ecosystem respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.hetero_respiration"),o(": carbon loss due to heterotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_efflux"),o(": losss of carbon from (live) vegetation pools due to autotrophic respiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_flow"),o(": flow of carbon to a given carbon pool from other carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_influx"),o(": net influx from allocation and efflux (npp) to each (live) carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_out"),o(": outflux of carbon from each carbol pool")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.c_eco_npp"),o(": npp of each carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"states.cEco_prev"),o(": ecosystem carbon content of the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔcEco"),o(": change in water storage in cEco pool(s)")])])])])],-1)),n[1034]||(n[1034]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1035]||(n[1035]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycle_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1036]||(n[1036]=l("hr",null,null,-1)),n[1037]||(n[1037]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1038]||(n[1038]=l("p",null,[l("em",null,"References")],-1)),n[1039]||(n[1039]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1040]||(n[1040]=l("p",null,[l("em",null,"Versions")],-1)),n[1041]||(n[1041]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [sbesnard]")],-1)),n[1042]||(n[1042]=l("p",null,[l("em",null,"Created by")],-1)),n[1043]||(n[1043]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4590]||(n[4590]=l("hr",null,null,-1)),n[4591]||(n[4591]=l("h3",{id:"cCycleBase",tabindex:"-1"},[o("cCycleBase "),l("a",{class:"header-anchor",href:"#cCycleBase","aria-label":'Permalink to "cCycleBase {#cCycleBase}"'},"​")],-1)),l("details",on,[l("summary",null,[n[1045]||(n[1045]=l("a",{id:"Sindbad.Models.cCycleBase",href:"#Sindbad.Models.cCycleBase"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase")],-1)),n[1046]||(n[1046]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1047]||(n[1047]=u("",4))]),l("details",en,[n[1148]||(n[1148]=l("summary",null,"cCycleBase approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cCycleBase_CASA"},{default:i(()=>[l("details",tn,[l("summary",null,[n[1048]||(n[1048]=l("a",{id:"Sindbad.Models.cCycleBase_CASA",href:"#Sindbad.Models.cCycleBase_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase_CASA")],-1)),n[1049]||(n[1049]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1050]||(n[1050]=l("p",null,"Structure and properties of the carbon cycle components used in the CASA approach.",-1)),n[1051]||(n[1051]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1052]||(n[1052]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"annk"),o(": [1.0, 0.03, 0.03, 1.0, 14.8, 3.9, 18.5, 4.8, 0.2424, 0.2424, 6.0, 7.3, 0.2, 0.0045] ∈ [[0.05, 0.002, 0.002, 0.05, 1.48, 0.39, 1.85, 0.48, 0.02424, 0.02424, 0.6, 0.73, 0.02, 0.0045], [3.3, 0.5, 0.5, 3.3, 148.0, 39.0, 185.0, 48.0, 2.424, 2.424, 60.0, 73.0, 2.0, 0.045]] => turnover rate of ecosystem carbon pools (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_flow_E_array"),o(": [-1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.4 0.4 0.0 0.0 0.4 0.0 -1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.45 0.45 0.0 0.4 0.0 -1.0 0.45 0.45; 0.0 0.0 0.0 0.0 0.0 0.6 0.0 0.55 0.6 0.6 0.4 0.0 -1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.45 -1.0] ∈ [-Inf, Inf] => Transfer matrix for carbon at ecosystem level ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"cVegRootF_age_per_PFT"),o(": [1.8, 1.2, 1.2, 5.0, 1.8, 1.0, 1.0, 0.0, 1.0, 2.8, 1.0, 1.0] ∈ [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0]] => mean age of fine roots (units: "),l("code",null,"yr"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"cVegRootC_age_per_PFT"),o(": [41.0, 58.0, 58.0, 42.0, 27.0, 25.0, 25.0, 0.0, 5.5, 40.0, 1.0, 40.0] ∈ [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]] => mean age of coarse roots (units: "),l("code",null,"yr"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"cVegWood_age_per_PFT"),o(": [41.0, 58.0, 58.0, 42.0, 27.0, 25.0, 25.0, 0.0, 5.5, 40.0, 1.0, 40.0] ∈ [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]] => mean age of wood (units: "),l("code",null,"yr"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"cVegLeaf_age_per_PFT"),o(": [1.8, 1.2, 1.2, 5.0, 1.8, 1.0, 1.0, 0.0, 1.0, 2.8, 1.0, 1.0] ∈ [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0, 20.0]] => mean age of leafs (units: "),l("code",null,"yr"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"p_C_to_N_cVeg"),o(": [25.0, 260.0, 260.0, 25.0] ∈ [-Inf, Inf] => carbon to nitrogen ratio in vegetation pools (units: "),l("code",null,"gC/gN"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1053]||(n[1053]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1054]||(n[1054]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1055]||(n[1055]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_E_array"),o(": an array containing the efficiency of each flow in the c_flow_A_array")])])])])],-1)),n[1056]||(n[1056]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1057]||(n[1057]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])])])],-1)),n[1058]||(n[1058]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1059]||(n[1059]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleBase_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1060]||(n[1060]=l("hr",null,null,-1)),n[1061]||(n[1061]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1062]||(n[1062]=l("p",null,[l("em",null,"References")],-1)),n[1063]||(n[1063]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1064]||(n[1064]=l("p",null,[l("em",null,"Versions")],-1)),n[1065]||(n[1065]=l("ul",null,[l("li",null,"1.0 on 28.05.2022 [skoirala | @dr-ko]: migrate to julia")],-1)),n[1066]||(n[1066]=l("p",null,[l("em",null,"Created by")],-1)),n[1067]||(n[1067]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycleBase_GSI"},{default:i(()=>[l("details",sn,[l("summary",null,[n[1068]||(n[1068]=l("a",{id:"Sindbad.Models.cCycleBase_GSI",href:"#Sindbad.Models.cCycleBase_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase_GSI")],-1)),n[1069]||(n[1069]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1070]||(n[1070]=l("p",null,"Structure and properties of the carbon cycle components as needed for a dynamic phenology-based carbon cycle in the GSI approach.",-1)),n[1071]||(n[1071]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1072]||(n[1072]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"c_τ_Root"),o(": 1.0 ∈ [0.05, 3.3] => turnover rate of root carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Wood"),o(": 0.03 ∈ [0.001, 10.0] => turnover rate of wood carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Leaf"),o(": 1.0 ∈ [0.05, 10.0] => turnover rate of leaf carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Reserve"),o(": 1.0e-11 ∈ [1.0e-12, 1.0] => Reserve does not respire, but has a small value to avoid numerical error (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitFast"),o(": 14.8 ∈ [0.5, 148.0] => turnover rate of fast litter (leaf litter) carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitSlow"),o(": 3.9 ∈ [0.39, 39.0] => turnover rate of slow litter carbon (wood litter) pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilSlow"),o(": 0.2 ∈ [0.02, 2.0] => turnover rate of slow soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilOld"),o(": 0.0045 ∈ [0.00045, 0.045] => turnover rate of old soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_flow_A_array"),o(": [-1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 -1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 0.0 -1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 1.0 -1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 1.0 -1.0] ∈ [-Inf, Inf] => Transfer matrix for carbon at ecosystem level ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"p_C_to_N_cVeg"),o(": [25.0, 260.0, 260.0, 10.0] ∈ [-Inf, Inf] => carbon to nitrogen ratio in vegetation pools (units: "),l("code",null,"gC/gN"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηH"),o(": 1.0 ∈ [0.01, 100.0] => scaling factor for heterotrophic pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηA"),o(": 1.0 ∈ [0.01, 100.0] => scaling factor for vegetation pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_remain"),o(": 10.0 ∈ [0.1, 100.0] => remaining carbon after disturbance ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1073]||(n[1073]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1074]||(n[1074]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1075]||(n[1075]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])])])])],-1)),n[1076]||(n[1076]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[1077]||(n[1077]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηA"),o(": scalar of autotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηH"),o(": scalar of heterotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"states.c_remain"),o(": amount of carbon to keep in the ecosystem vegetation pools in case of disturbances")])])])])],-1)),n[1078]||(n[1078]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[1079]||(n[1079]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleBase_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1080]||(n[1080]=l("hr",null,null,-1)),n[1081]||(n[1081]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1082]||(n[1082]=l("p",null,[l("em",null,"References")],-1)),n[1083]||(n[1083]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1084]||(n[1084]=l("p",null,[l("em",null,"Versions")],-1)),n[1085]||(n[1085]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [skoirala | @dr-ko]")],-1)),n[1086]||(n[1086]=l("p",null,[l("em",null,"Created by")],-1)),n[1087]||(n[1087]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycleBase_GSI_PlantForm"},{default:i(()=>[l("details",un,[l("summary",null,[n[1088]||(n[1088]=l("a",{id:"Sindbad.Models.cCycleBase_GSI_PlantForm",href:"#Sindbad.Models.cCycleBase_GSI_PlantForm"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase_GSI_PlantForm")],-1)),n[1089]||(n[1089]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1090]||(n[1090]=l("p",null,"Same as GSI, additionally allowing for scaling of turnover parameters based on plant forms.",-1)),n[1091]||(n[1091]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1092]||(n[1092]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"c_τ_Root_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of root carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Wood_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of wood carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Leaf_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of leaf carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Litter_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of litter carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Reserve_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for Reserve does not respire, but has a small value to avoid numerical error (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Soil_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of soil carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_tree"),o(": [1.0, 0.02, 1.0, 1.0e-11] ∈ [[0.25, 0.005, 0.25, 2.5e-12], [4.0, 0.08, 4.0, 4.0e-11]] => turnover of different organs of trees (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_shrub"),o(": [1.0, 0.2, 1.0, 1.0e-11] ∈ [[0.25, 0.05, 0.25, 2.5e-12], [4.0, 0.8, 4.0, 4.0e-11]] => turnover of different organs of shrubs (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_herb"),o(": [1.3333333333333333, 1.3333333333333333, 1.3333333333333333, 1.3333333333333333e-11] ∈ [[0.3333333333333333, 0.3333333333333333, 0.3333333333333333, 3.333333333333333e-12], [5.333333333333333, 5.333333333333333, 5.333333333333333, 5.333333333333333e-11]] => turnover of different organs of herbs (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitFast"),o(": 14.8 ∈ [0.5, 148.0] => turnover rate of fast litter (leaf litter) carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitSlow"),o(": 3.9 ∈ [0.39, 39.0] => turnover rate of slow litter carbon (wood litter) pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilSlow"),o(": 0.2 ∈ [0.02, 2.0] => turnover rate of slow soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilOld"),o(": 0.0045 ∈ [0.00045, 0.045] => turnover rate of old soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_flow_A_array"),o(": [-1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 -1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 0.0 -1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 1.0 -1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 1.0 -1.0] ∈ [-Inf, Inf] => Transfer matrix for carbon at ecosystem level ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"p_C_to_N_cVeg"),o(": [25.0, 260.0, 260.0, 10.0] ∈ [-Inf, Inf] => carbon to nitrogen ratio in vegetation pools (units: "),l("code",null,"gC/gN"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηH"),o(": 1.0 ∈ [0.125, 8.0] => scaling factor for heterotrophic pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηA"),o(": 1.0 ∈ [0.25, 4.0] => scaling factor for vegetation pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_remain"),o(": 50.0 ∈ [0.1, 100.0] => remaining carbon after disturbance (units: "),l("code",null,"gC/m2"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1093]||(n[1093]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1094]||(n[1094]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1095]||(n[1095]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.zero_c_τ_pf"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :zero_c_τ_pf)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])])])])],-1)),n[1096]||(n[1096]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[1097]||(n[1097]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.zero_c_τ_pf"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :zero_c_τ_pf)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"states.plant_form"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :plant_form)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηA"),o(": scalar of autotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηH"),o(": scalar of heterotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"states.c_remain"),o(": amount of carbon to keep in the ecosystem vegetation pools in case of disturbances")])])])])],-1)),n[1098]||(n[1098]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[1099]||(n[1099]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleBase_GSI_PlantForm.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1100]||(n[1100]=l("hr",null,null,-1)),n[1101]||(n[1101]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1102]||(n[1102]=l("p",null,[l("em",null,"References")],-1)),n[1103]||(n[1103]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1104]||(n[1104]=l("p",null,[l("em",null,"Versions")],-1)),n[1105]||(n[1105]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [skoirala | @dr-ko]")],-1)),n[1106]||(n[1106]=l("p",null,[l("em",null,"Created by")],-1)),n[1107]||(n[1107]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycleBase_GSI_PlantForm_LargeKReserve"},{default:i(()=>[l("details",rn,[l("summary",null,[n[1108]||(n[1108]=l("a",{id:"Sindbad.Models.cCycleBase_GSI_PlantForm_LargeKReserve",href:"#Sindbad.Models.cCycleBase_GSI_PlantForm_LargeKReserve"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase_GSI_PlantForm_LargeKReserve")],-1)),n[1109]||(n[1109]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1110]||(n[1110]=l("p",null,"Same as cCycleBase_GSI_PlantForm, but with a default of larger turnover of reserve pool so that it respires and flows.",-1)),n[1111]||(n[1111]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1112]||(n[1112]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"c_τ_Root_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of root carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Wood_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of wood carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Leaf_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of leaf carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Litter_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of litter carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Reserve_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for Reserve does not respire, but has a small value to avoid numerical error (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_Soil_scalar"),o(": 1.0 ∈ [0.25, 4] => scalar for turnover rate of soil carbon pool (units: "),l("code",null,"-"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_tree"),o(": [1.0, 0.02, 1.0, 0.001] ∈ [[0.25, 0.005, 0.25, 0.00025], [4.0, 0.08, 4.0, 0.004]] => turnover of different organs of trees (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_shrub"),o(": [1.0, 0.2, 1.0, 0.001] ∈ [[0.25, 0.05, 0.25, 0.00025], [4.0, 0.8, 4.0, 0.004]] => turnover of different organs of shrubs (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_herb"),o(": [1.3333333333333333, 1.3333333333333333, 1.3333333333333333, 0.0013333333333333333] ∈ [[0.3333333333333333, 0.3333333333333333, 0.3333333333333333, 0.0003333333333333333], [5.333333333333333, 5.333333333333333, 5.333333333333333, 0.005333333333333333]] => turnover of different organs of herbs (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitFast"),o(": 14.8 ∈ [0.5, 148.0] => turnover rate of fast litter (leaf litter) carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_LitSlow"),o(": 3.9 ∈ [0.39, 39.0] => turnover rate of slow litter carbon (wood litter) pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilSlow"),o(": 0.2 ∈ [0.02, 2.0] => turnover rate of slow soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_τ_SoilOld"),o(": 0.0045 ∈ [0.00045, 0.045] => turnover rate of old soil carbon pool (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"year"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"c_flow_A_array"),o(": [-1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0; 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 -1.0 0.0 0.0 0.0 0.0; 1.0 0.0 1.0 0.0 -1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 1.0 -1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 1.0 -1.0] ∈ [-Inf, Inf] => Transfer matrix for carbon at ecosystem level ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"p_C_to_N_cVeg"),o(": [25.0, 260.0, 260.0, 10.0] ∈ [-Inf, Inf] => carbon to nitrogen ratio in vegetation pools (units: "),l("code",null,"gC/gN"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηH"),o(": 1.0 ∈ [0.125, 8.0] => scaling factor for heterotrophic pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ηA"),o(": 1.0 ∈ [0.25, 4.0] => scaling factor for vegetation pools after spinup ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_remain"),o(": 50.0 ∈ [0.1, 100.0] => remaining carbon after disturbance (units: "),l("code",null,"gC/m2"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1113]||(n[1113]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1114]||(n[1114]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1115]||(n[1115]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.zero_c_τ_pf"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :zero_c_τ_pf)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])])])])],-1)),n[1116]||(n[1116]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[1117]||(n[1117]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.zero_c_τ_pf"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :zero_c_τ_pf)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"states.plant_form"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :plant_form)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηA"),o(": scalar of autotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.ηH"),o(": scalar of heterotrophic carbon pool for steady state guess")])]),l("li",null,[l("p",null,[l("code",null,"states.c_remain"),o(": amount of carbon to keep in the ecosystem vegetation pools in case of disturbances")])])])])],-1)),n[1118]||(n[1118]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[1119]||(n[1119]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleBase_GSI_PlantForm_LargeKReserve.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1120]||(n[1120]=l("hr",null,null,-1)),n[1121]||(n[1121]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1122]||(n[1122]=l("p",null,[l("em",null,"References")],-1)),n[1123]||(n[1123]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1124]||(n[1124]=l("p",null,[l("em",null,"Versions")],-1)),n[1125]||(n[1125]=l("ul",null,[l("li",null,"1.0 on 28.02.2020 [skoirala | @dr-ko]")],-1)),n[1126]||(n[1126]=l("p",null,[l("em",null,"Created by")],-1)),n[1127]||(n[1127]=l("ul",null,[l("li",null,"skoirala based on cCycleBase_GSI_PlantForm.jl from ncarvalhais")],-1))])]),_:1}),e(s,{label:"cCycleBase_simple"},{default:i(()=>[l("details",an,[l("summary",null,[n[1128]||(n[1128]=l("a",{id:"Sindbad.Models.cCycleBase_simple",href:"#Sindbad.Models.cCycleBase_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleBase_simple")],-1)),n[1129]||(n[1129]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1130]||(n[1130]=l("p",null,"Structure and properties of the carbon cycle components as needed for a simplified version of the CASA approach.",-1)),n[1131]||(n[1131]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1132]||(n[1132]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"annk"),o(": [1.0, 0.03, 0.03, 1.0, 14.8, 3.9, 18.5, 4.8, 0.2424, 0.2424, 6.0, 7.3, 0.2, 0.0045] ∈ [[0.05, 0.002, 0.002, 0.05, 1.48, 0.39, 1.85, 0.48, 0.02424, 0.02424, 0.6, 0.73, 0.02, 0.0045], [3.3, 0.5, 0.5, 3.3, 148.0, 39.0, 185.0, 48.0, 2.424, 2.424, 60.0, 73.0, 2.0, 0.045]] => turnover rate of ecosystem carbon pools (units: "),l("code",null,"year-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_flow_A_array"),o(": [-1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.54 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.46 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.54 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.46 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -1.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.4 0.15 0.0 0.0 0.24 0.0 -1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.45 0.17 0.0 0.24 0.0 -1.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.43 0.0 0.43 0.28 0.28 0.4 0.43 -1.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.005 0.0026 -1.0] ∈ [-Inf, Inf] => Transfer matrix for carbon at ecosystem level ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"p_C_to_N_cVeg"),o(": [25.0, 260.0, 260.0, 25.0] ∈ [-Inf, Inf] => carbon to nitrogen ratio in vegetation pools (units: "),l("code",null,"gC/gN"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1133]||(n[1133]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1134]||(n[1134]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1135]||(n[1135]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])])])])],-1)),n[1136]||(n[1136]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1137]||(n[1137]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.C_to_N_cVeg"),o(": carbon to nitrogen ratio in the vegetation pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])])])])],-1)),n[1138]||(n[1138]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1139]||(n[1139]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleBase_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1140]||(n[1140]=l("hr",null,null,-1)),n[1141]||(n[1141]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1142]||(n[1142]=l("p",null,[l("em",null,"References")],-1)),n[1143]||(n[1143]=l("ul",null,[l("li",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")],-1)),n[1144]||(n[1144]=l("p",null,[l("em",null,"Versions")],-1)),n[1145]||(n[1145]=l("ul",null,[l("li",null,"1.0.0 on 28.02.2020.0 [sbesnard]")],-1)),n[1146]||(n[1146]=l("p",null,[l("em",null,"Created by")],-1)),n[1147]||(n[1147]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4592]||(n[4592]=l("hr",null,null,-1)),n[4593]||(n[4593]=l("h3",{id:"cCycleConsistency",tabindex:"-1"},[o("cCycleConsistency "),l("a",{class:"header-anchor",href:"#cCycleConsistency","aria-label":'Permalink to "cCycleConsistency {#cCycleConsistency}"'},"​")],-1)),l("details",dn,[l("summary",null,[n[1149]||(n[1149]=l("a",{id:"Sindbad.Models.cCycleConsistency",href:"#Sindbad.Models.cCycleConsistency"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleConsistency")],-1)),n[1150]||(n[1150]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1151]||(n[1151]=u("",4))]),l("details",pn,[n[1169]||(n[1169]=l("summary",null,"cCycleConsistency approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cCycleConsistency_simple"},{default:i(()=>[l("details",fn,[l("summary",null,[n[1152]||(n[1152]=l("a",{id:"Sindbad.Models.cCycleConsistency_simple",href:"#Sindbad.Models.cCycleConsistency_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleConsistency_simple")],-1)),n[1153]||(n[1153]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1154]||(n[1154]=l("p",null,"Checks consistency in the cCycle vector, including c_allocation and cFlow.",-1)),n[1155]||(n[1155]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1156]||(n[1156]=l("ul",null,[l("li",null,"None")],-1)),n[1157]||(n[1157]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1158]||(n[1158]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1159]||(n[1159]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycleConsistency.giver_lower_unique"),o(": unique indices of carbon pools whose flow is >0 below the diagonal in carbon flow matrix")])]),l("li",null,[l("p",null,[l("code",null,"cCycleConsistency.giver_lower_indices"),o(": indices of carbon pools whose flow is >0 below the diagonal in carbon flow matrix")])]),l("li",null,[l("p",null,[l("code",null,"cCycleConsistency.giver_upper_unique"),o(": unique indices of carbon pools whose flow is >0 above the diagonal in carbon flow matrix")])]),l("li",null,[l("p",null,[l("code",null,"cCycleConsistency.giver_upper_indices"),o(": indices of carbon pools whose flow is >0 above the diagonal in carbon flow matrix")])])])])],-1)),n[1160]||(n[1160]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1161]||(n[1161]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleConsistency_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1162]||(n[1162]=l("hr",null,null,-1)),n[1163]||(n[1163]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1164]||(n[1164]=l("p",null,[l("em",null,"References")],-1)),n[1165]||(n[1165]=l("p",null,[l("em",null,"Versions")],-1)),n[1166]||(n[1166]=l("ul",null,[l("li",null,"1.0 on 12.05.2022: skoirala: julia implementation")],-1)),n[1167]||(n[1167]=l("p",null,[l("em",null,"Created by")],-1)),n[1168]||(n[1168]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1})]),_:1})]),n[4594]||(n[4594]=l("hr",null,null,-1)),n[4595]||(n[4595]=l("h3",{id:"cCycleDisturbance",tabindex:"-1"},[o("cCycleDisturbance "),l("a",{class:"header-anchor",href:"#cCycleDisturbance","aria-label":'Permalink to "cCycleDisturbance {#cCycleDisturbance}"'},"​")],-1)),l("details",gn,[l("summary",null,[n[1170]||(n[1170]=l("a",{id:"Sindbad.Models.cCycleDisturbance",href:"#Sindbad.Models.cCycleDisturbance"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleDisturbance")],-1)),n[1171]||(n[1171]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1172]||(n[1172]=u("",4))]),l("details",mn,[n[1213]||(n[1213]=l("summary",null,"cCycleDisturbance approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cCycleDisturbance_WROASTED"},{default:i(()=>[l("details",bn,[l("summary",null,[n[1173]||(n[1173]=l("a",{id:"Sindbad.Models.cCycleDisturbance_WROASTED",href:"#Sindbad.Models.cCycleDisturbance_WROASTED"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleDisturbance_WROASTED")],-1)),n[1174]||(n[1174]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1175]||(n[1175]=l("p",null,"Moves carbon in reserve pool to slow litter pool, and all other carbon pools except reserve pool to their respective carbon flow target pools during disturbance events.",-1)),n[1176]||(n[1176]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1177]||(n[1177]=l("ul",null,[l("li",null,"None")],-1)),n[1178]||(n[1178]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1179]||(n[1179]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1180]||(n[1180]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.zix_veg_all"),o(": zix_veg_all_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.c_lose_to_zix_vec"),o(": c_lose_to_zix_vec_cCycleDisturbance")])])])])],-1)),n[1181]||(n[1181]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1182]||(n[1182]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_dist_intensity"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_dist_intensity)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.zix_veg_all"),o(": zix_veg_all_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.c_lose_to_zix_vec"),o(": c_lose_to_zix_vec_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"states.c_remain"),o(": amount of carbon to keep in the ecosystem vegetation pools in case of disturbances")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])],-1)),n[1183]||(n[1183]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1184]||(n[1184]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleDisturbance_WROASTED.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1185]||(n[1185]=l("hr",null,null,-1)),n[1186]||(n[1186]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1187]||(n[1187]=l("p",null,[l("em",null,"References")],-1)),n[1188]||(n[1188]=l("ul",null,[l("li",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")],-1)),n[1189]||(n[1189]=l("p",null,[l("em",null,"Versions")],-1)),n[1190]||(n[1190]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 23.04.2021 [skoirala | @dr-ko]")]),l("li",null,[l("p",null,"1.0 on 23.04.2021 [skoirala | @dr-ko]")]),l("li",null,[l("p",null,"1.1 on 29.11.2021 [skoirala | @dr-ko]: moved the scaling parameters to ccyclebase_gsi [land.diagnostics.ηA & land.diagnostics.ηH]")])],-1)),n[1191]||(n[1191]=l("p",null,[l("em",null,"Created by")],-1)),n[1192]||(n[1192]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"cCycleDisturbance_cFlow"},{default:i(()=>[l("details",yn,[l("summary",null,[n[1193]||(n[1193]=l("a",{id:"Sindbad.Models.cCycleDisturbance_cFlow",href:"#Sindbad.Models.cCycleDisturbance_cFlow"},[l("span",{class:"jlbinding"},"Sindbad.Models.cCycleDisturbance_cFlow")],-1)),n[1194]||(n[1194]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1195]||(n[1195]=l("p",null,"Moves carbon in all pools except reserve to their respective carbon flow target pools during disturbance events.",-1)),n[1196]||(n[1196]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1197]||(n[1197]=l("ul",null,[l("li",null,"None")],-1)),n[1198]||(n[1198]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1199]||(n[1199]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1200]||(n[1200]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVeg"),o(": carbon content of cVeg pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.zix_veg_all"),o(": zix_veg_all_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.c_lose_to_zix_vec"),o(": c_lose_to_zix_vec_cCycleDisturbance")])])])])],-1)),n[1201]||(n[1201]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1202]||(n[1202]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_dist_intensity"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_dist_intensity)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.zix_veg_all"),o(": zix_veg_all_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"cCycleDisturbance.c_lose_to_zix_vec"),o(": c_lose_to_zix_vec_cCycleDisturbance")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"models.c_model"),o(": a base carbon cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every carbon model realization")])]),l("li",null,[l("p",null,[l("code",null,"states.c_remain"),o(": amount of carbon to keep in the ecosystem vegetation pools in case of disturbances")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])],-1)),n[1203]||(n[1203]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1204]||(n[1204]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cCycleDisturbance_cFlow.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1205]||(n[1205]=l("hr",null,null,-1)),n[1206]||(n[1206]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1207]||(n[1207]=l("p",null,[l("em",null,"References")],-1)),n[1208]||(n[1208]=l("ul",null,[l("li",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")],-1)),n[1209]||(n[1209]=l("p",null,[l("em",null,"Versions")],-1)),n[1210]||(n[1210]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 23.04.2021 [skoirala | @dr-ko]")]),l("li",null,[l("p",null,"1.0 on 23.04.2021 [skoirala | @dr-ko]")]),l("li",null,[l("p",null,"1.1 on 29.11.2021 [skoirala | @dr-ko]: moved the scaling parameters to ccyclebase_gsi [land.diagnostics.ηA & land.diagnostics.ηH]")])],-1)),n[1211]||(n[1211]=l("p",null,[l("em",null,"Created by")],-1)),n[1212]||(n[1212]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4596]||(n[4596]=l("hr",null,null,-1)),n[4597]||(n[4597]=l("h3",{id:"cFlow",tabindex:"-1"},[o("cFlow "),l("a",{class:"header-anchor",href:"#cFlow","aria-label":'Permalink to "cFlow {#cFlow}"'},"​")],-1)),l("details",cn,[l("summary",null,[n[1214]||(n[1214]=l("a",{id:"Sindbad.Models.cFlow",href:"#Sindbad.Models.cFlow"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlow")],-1)),n[1215]||(n[1215]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1216]||(n[1216]=u("",4))]),l("details",vn,[n[1284]||(n[1284]=l("summary",null,"cFlow approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cFlow_CASA"},{default:i(()=>[l("details",kn,[l("summary",null,[n[1217]||(n[1217]=l("a",{id:"Sindbad.Models.cFlow_CASA",href:"#Sindbad.Models.cFlow_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlow_CASA")],-1)),n[1218]||(n[1218]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1219]||(n[1219]=l("p",null,"Carbon transfer rates between pools as modeled in CASA.",-1)),n[1220]||(n[1220]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1221]||(n[1221]=l("ul",null,[l("li",null,"None")],-1)),n[1222]||(n[1222]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1223]||(n[1223]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1224]||(n[1224]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_E_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_E_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_F_vec"),o(": carbon flow efficiency fraction")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_E_array"),o(": an array containing the efficiency of each flow in the c_flow_A_array")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.c_flow_A_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :c_flow_A_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_E_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_E_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_giver"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_giver)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_taker"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_taker)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[1225]||(n[1225]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1226]||(n[1226]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlow_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1227]||(n[1227]=l("hr",null,null,-1)),n[1228]||(n[1228]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1229]||(n[1229]=l("p",null,[l("em",null,"References")],-1)),n[1230]||(n[1230]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1231]||(n[1231]=l("p",null,[l("em",null,"Versions")],-1)),n[1232]||(n[1232]=l("ul",null,[l("li",null,"1.0 on 13.01.2020 [sbesnard]")],-1)),n[1233]||(n[1233]=l("p",null,[l("em",null,"Created by")],-1)),n[1234]||(n[1234]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cFlow_GSI"},{default:i(()=>[l("details",Sn,[l("summary",null,[n[1235]||(n[1235]=l("a",{id:"Sindbad.Models.cFlow_GSI",href:"#Sindbad.Models.cFlow_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlow_GSI")],-1)),n[1236]||(n[1236]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1237]||(n[1237]=l("p",null,"Carbon transfer rates between pools based on the GSI approach, using stressors such as soil moisture, temperature, and light.",-1)),n[1238]||(n[1238]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1239]||(n[1239]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"slope_leaf_root_to_reserve"),o(": 0.14 ∈ [0.033, 0.33] => Leaf-Root to Reserve (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"slope_reserve_to_leaf_root"),o(": 0.14 ∈ [0.033, 0.33] => Reserve to Leaf-Root (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"k_shedding"),o(": 0.14 ∈ [0.033, 0.33] => rate of shedding (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"day"),o(" timescale)")])]),l("li",null,[l("p",null,[l("code",null,"f_τ"),o(": 0.03 ∈ [0.01, 0.1] => contribution factor for current stressor (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])])],-1)),n[1240]||(n[1240]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1241]||(n[1241]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1242]||(n[1242]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_giver"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlow.c_flow_A_vec_ind"),o(": indices of flow from giver to taker for carbon flow vector")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.eco_stressor_prev"),o(": ecosystem stress on carbon flow in the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.slope_eco_stressor_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :slope_eco_stressor_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])])])])],-1)),n[1243]||(n[1243]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1244]||(n[1244]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlow.c_flow_A_vec_ind"),o(": indices of flow from giver to taker for carbon flow vector")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilW"),o(": effect of soil moisture on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_soilT"),o(": effect of soil temperature on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_allocation_f_cloud"),o(": effect of cloud on carbon allocation. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.eco_stressor_prev"),o(": ecosystem stress on carbon flow in the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.slope_eco_stressor_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :slope_eco_stressor_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.leaf_to_reserve"),o(": loss rate of carbon flow from leaf to reserve")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.leaf_to_reserve_frac"),o(": fraction of carbon loss from leaf that flows to leaf")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_to_reserve"),o(": loss rate of carbon flow from root to reserve")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_to_reserve_frac"),o(": fraction of carbon loss from root that flows to reserve")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.reserve_to_leaf"),o(": loss rate of carbon flow from reserve to root")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.reserve_to_leaf_frac"),o(": fraction of carbon loss from reserve that flows to leaf")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.reserve_to_root"),o(": loss rate of carbon flow from reserve to root")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.reserve_to_root_frac"),o(": fraction of carbon loss from reserve that flows to root")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.eco_stressor"),o(": ecosystem stress on carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_shedding_leaf"),o(": loss rate of carbon flow from leaf to litter")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_shedding_leaf_frac"),o(": fraction of carbon loss from leaf that flows to litter pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_shedding_root"),o(": loss rate of carbon flow from root to litter")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.k_shedding_root_frac"),o(": fraction of carbon loss from root that flows to litter pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.slope_eco_stressor"),o(": potential rate of change in ecosystem stress on carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.eco_stressor_prev"),o(": ecosystem stress on carbon flow in the previous time step")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.slope_eco_stressor_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :slope_eco_stressor_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])])])])],-1)),n[1245]||(n[1245]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1246]||(n[1246]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlow_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1247]||(n[1247]=l("hr",null,null,-1)),n[1248]||(n[1248]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1249]||(n[1249]=l("p",null,[l("em",null,"References")],-1)),n[1250]||(n[1250]=l("p",null,[l("em",null,"Versions")],-1)),n[1251]||(n[1251]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 13.01.2020 [sbesnard]")]),l("li",null,[l("p",null,"1.1 on 05.02.2021 [skoirala | @dr-ko]: changes with stressors & smoothing as well as handling the activation of leaf/root to reserve | reserve to leaf/root switches. Adjustment of total flow rates [cTau] of relevant pools")]),l("li",null,[l("p",null,"1.1 on 05.02.2021 [skoirala | @dr-ko]: move code from dyna. Add table etc.")])],-1)),n[1252]||(n[1252]=l("p",null,[l("em",null,"Created by")],-1)),n[1253]||(n[1253]=l("ul",null,[l("li",null,"ncarvalhais, sbesnard, skoirala")],-1)),n[1254]||(n[1254]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"cFlow_none"},{default:i(()=>[l("details",wn,[l("summary",null,[n[1255]||(n[1255]=l("a",{id:"Sindbad.Models.cFlow_none",href:"#Sindbad.Models.cFlow_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlow_none")],-1)),n[1256]||(n[1256]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1257]||(n[1257]=l("p",null,"Sets carbon transfers between pools to 0 (no transfer); sets c_giver and c_taker matrices to empty; retrieves the transfer matrix.",-1)),n[1258]||(n[1258]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1259]||(n[1259]=l("ul",null,[l("li",null,"None")],-1)),n[1260]||(n[1260]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1261]||(n[1261]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1262]||(n[1262]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_flow_A_vec"),o(": fraction of the carbon loss fron a (giver) pool that flows to a (taker) pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_F_vec"),o(": carbon flow efficiency fraction")])])])])],-1)),n[1263]||(n[1263]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1264]||(n[1264]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlow_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1265]||(n[1265]=l("hr",null,null,-1)),n[1266]||(n[1266]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1}),e(s,{label:"cFlow_simple"},{default:i(()=>[l("details",Tn,[l("summary",null,[n[1267]||(n[1267]=l("a",{id:"Sindbad.Models.cFlow_simple",href:"#Sindbad.Models.cFlow_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlow_simple")],-1)),n[1268]||(n[1268]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1269]||(n[1269]=l("p",null,"Carbon transfer rates between pools modeled a simplified version of CASA.",-1)),n[1270]||(n[1270]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1271]||(n[1271]=l("ul",null,[l("li",null,"None")],-1)),n[1272]||(n[1272]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1273]||(n[1273]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1274]||(n[1274]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_flow_A_array"),o(": an array indicating the flow direction and connections across different pools, with elements larger than 0 indicating flow from column pool to row pool")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_flow_order"),o(": order of pooling while calculating the carbon flow")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.c_flow_A_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :c_flow_A_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_giver"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_giver)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlow.p_taker"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlow, :p_taker)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[1275]||(n[1275]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1276]||(n[1276]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlow_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1277]||(n[1277]=l("hr",null,null,-1)),n[1278]||(n[1278]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1279]||(n[1279]=l("p",null,[l("em",null,"References")],-1)),n[1280]||(n[1280]=l("p",null,[l("em",null,"Versions")],-1)),n[1281]||(n[1281]=l("ul",null,[l("li",null,"1.0 on 13.01.2020 [sbesnard]")],-1)),n[1282]||(n[1282]=l("p",null,[l("em",null,"Created by")],-1)),n[1283]||(n[1283]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4598]||(n[4598]=l("hr",null,null,-1)),n[4599]||(n[4599]=l("h3",{id:"cFlowSoilProperties",tabindex:"-1"},[o("cFlowSoilProperties "),l("a",{class:"header-anchor",href:"#cFlowSoilProperties","aria-label":'Permalink to "cFlowSoilProperties {#cFlowSoilProperties}"'},"​")],-1)),l("details",jn,[l("summary",null,[n[1285]||(n[1285]=l("a",{id:"Sindbad.Models.cFlowSoilProperties",href:"#Sindbad.Models.cFlowSoilProperties"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowSoilProperties")],-1)),n[1286]||(n[1286]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1287]||(n[1287]=u("",4))]),l("details",En,[n[1320]||(n[1320]=l("summary",null,"cFlowSoilProperties approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cFlowSoilProperties_CASA"},{default:i(()=>[l("details",xn,[l("summary",null,[n[1288]||(n[1288]=l("a",{id:"Sindbad.Models.cFlowSoilProperties_CASA",href:"#Sindbad.Models.cFlowSoilProperties_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowSoilProperties_CASA")],-1)),n[1289]||(n[1289]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1290]||(n[1290]=l("p",null,"Effect of soil properties on carbon transfers between pools as modeled in CASA.",-1)),n[1291]||(n[1291]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1292]||(n[1292]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"effA"),o(": 0.85 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"effB"),o(": 0.68 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"effclay_cMicSoil_A"),o(": 0.003 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"effclay_cMicSoil_B"),o(": 0.032 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"effclay_cSoilSlow_A"),o(": 0.003 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"effclay_cSoilSlow_B"),o(": 0.009 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1293]||(n[1293]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1294]||(n[1294]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1295]||(n[1295]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])])])],-1)),n[1296]||(n[1296]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1297]||(n[1297]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_F_vec"),o(": carbon flow efficiency fraction")])])])])],-1)),n[1298]||(n[1298]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1299]||(n[1299]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlowSoilProperties_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1300]||(n[1300]=l("hr",null,null,-1)),n[1301]||(n[1301]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1302]||(n[1302]=l("p",null,[l("em",null,"References")],-1)),n[1303]||(n[1303]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1304]||(n[1304]=l("p",null,[l("em",null,"Versions")],-1)),n[1305]||(n[1305]=l("ul",null,[l("li",null,"1.0 on 13.01.2020 [sbesnard]")],-1)),n[1306]||(n[1306]=l("p",null,[l("em",null,"Created by")],-1)),n[1307]||(n[1307]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cFlowSoilProperties_none"},{default:i(()=>[l("details",Cn,[l("summary",null,[n[1308]||(n[1308]=l("a",{id:"Sindbad.Models.cFlowSoilProperties_none",href:"#Sindbad.Models.cFlowSoilProperties_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowSoilProperties_none")],-1)),n[1309]||(n[1309]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1310]||(n[1310]=l("p",null,"Sets carbon transfers between pools to 0 (no transfer).",-1)),n[1311]||(n[1311]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1312]||(n[1312]=l("ul",null,[l("li",null,"None")],-1)),n[1313]||(n[1313]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1314]||(n[1314]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1315]||(n[1315]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.p_E_vec"),o(": carbon flow efficiency")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_F_vec"),o(": carbon flow efficiency fraction")])])])])],-1)),n[1316]||(n[1316]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1317]||(n[1317]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlowSoilProperties_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1318]||(n[1318]=l("hr",null,null,-1)),n[1319]||(n[1319]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4600]||(n[4600]=l("hr",null,null,-1)),n[4601]||(n[4601]=l("h3",{id:"cFlowVegProperties",tabindex:"-1"},[o("cFlowVegProperties "),l("a",{class:"header-anchor",href:"#cFlowVegProperties","aria-label":'Permalink to "cFlowVegProperties {#cFlowVegProperties}"'},"​")],-1)),l("details",Mn,[l("summary",null,[n[1321]||(n[1321]=l("a",{id:"Sindbad.Models.cFlowVegProperties",href:"#Sindbad.Models.cFlowVegProperties"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowVegProperties")],-1)),n[1322]||(n[1322]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1323]||(n[1323]=u("",4))]),l("details",In,[n[1356]||(n[1356]=l("summary",null,"cFlowVegProperties approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cFlowVegProperties_CASA"},{default:i(()=>[l("details",An,[l("summary",null,[n[1324]||(n[1324]=l("a",{id:"Sindbad.Models.cFlowVegProperties_CASA",href:"#Sindbad.Models.cFlowVegProperties_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowVegProperties_CASA")],-1)),n[1325]||(n[1325]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1326]||(n[1326]=l("p",null,"Effect of vegetation properties on carbon transfers between pools as modeled in CASA.",-1)),n[1327]||(n[1327]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1328]||(n[1328]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"frac_lignin_wood"),o(": 0.4 ∈ [-Inf, Inf] => fraction of wood that is lignin ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1329]||(n[1329]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1330]||(n[1330]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1331]||(n[1331]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"cFlowVegProperties.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[1332]||(n[1332]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1333]||(n[1333]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_E_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_E_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[1334]||(n[1334]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1335]||(n[1335]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlowVegProperties_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1336]||(n[1336]=l("hr",null,null,-1)),n[1337]||(n[1337]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1338]||(n[1338]=l("p",null,[l("em",null,"References")],-1)),n[1339]||(n[1339]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1340]||(n[1340]=l("p",null,[l("em",null,"Versions")],-1)),n[1341]||(n[1341]=l("ul",null,[l("li",null,"1.0 on 13.01.2020 [sbesnard]")],-1)),n[1342]||(n[1342]=l("p",null,[l("em",null,"Created by")],-1)),n[1343]||(n[1343]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cFlowVegProperties_none"},{default:i(()=>[l("details",Pn,[l("summary",null,[n[1344]||(n[1344]=l("a",{id:"Sindbad.Models.cFlowVegProperties_none",href:"#Sindbad.Models.cFlowVegProperties_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cFlowVegProperties_none")],-1)),n[1345]||(n[1345]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1346]||(n[1346]=l("p",null,"Sets carbon transfers between pools to 0 (no transfer).",-1)),n[1347]||(n[1347]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1348]||(n[1348]=l("ul",null,[l("li",null,"None")],-1)),n[1349]||(n[1349]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1350]||(n[1350]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1351]||(n[1351]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.c_taker"),o(": index of the source carbon pool for a given flow")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_E_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_E_vec)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"cFlowVegProperties.p_F_vec"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:cFlowVegProperties, :p_F_vec)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[1352]||(n[1352]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1353]||(n[1353]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cFlowVegProperties_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1354]||(n[1354]=l("hr",null,null,-1)),n[1355]||(n[1355]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4602]||(n[4602]=l("hr",null,null,-1)),n[4603]||(n[4603]=l("h3",{id:"cTau",tabindex:"-1"},[o("cTau "),l("a",{class:"header-anchor",href:"#cTau","aria-label":'Permalink to "cTau {#cTau}"'},"​")],-1)),l("details",Rn,[l("summary",null,[n[1357]||(n[1357]=l("a",{id:"Sindbad.Models.cTau",href:"#Sindbad.Models.cTau"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTau")],-1)),n[1358]||(n[1358]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1359]||(n[1359]=u("",4))]),l("details",Vn,[n[1392]||(n[1392]=l("summary",null,"cTau approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTau_mult"},{default:i(()=>[l("details",Wn,[l("summary",null,[n[1360]||(n[1360]=l("a",{id:"Sindbad.Models.cTau_mult",href:"#Sindbad.Models.cTau_mult"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTau_mult")],-1)),n[1361]||(n[1361]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1362]||(n[1362]=l("p",null,"Combines all effects that change the turnover rates by multiplication.",-1)),n[1363]||(n[1363]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1364]||(n[1364]=l("ul",null,[l("li",null,"None")],-1)),n[1365]||(n[1365]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1366]||(n[1366]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1367]||(n[1367]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])])])],-1)),n[1368]||(n[1368]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1369]||(n[1369]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_veg_props"),o(": effect of veg_props on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soilT"),o(": effect of soil temperature on heterotrophic respiration respiration. 0: no decomposition, >1 increase in decomposition")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soil_props"),o(": effect of soil_props on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_LAI"),o(": effect of LAI on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_base"),o(": base carbon decomposition rate of the carbon pools")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])])])],-1)),n[1370]||(n[1370]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1371]||(n[1371]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTau_mult.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1372]||(n[1372]=l("hr",null,null,-1)),n[1373]||(n[1373]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1374]||(n[1374]=l("p",null,[l("em",null,"References")],-1)),n[1375]||(n[1375]=l("p",null,[l("em",null,"Versions")],-1)),n[1376]||(n[1376]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[1377]||(n[1377]=l("p",null,[l("em",null,"Created by")],-1)),n[1378]||(n[1378]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[1379]||(n[1379]=l("p",null,[l("em",null,"Notes:")],-1))])]),_:1}),e(s,{label:"cTau_none"},{default:i(()=>[l("details",Dn,[l("summary",null,[n[1380]||(n[1380]=l("a",{id:"Sindbad.Models.cTau_none",href:"#Sindbad.Models.cTau_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTau_none")],-1)),n[1381]||(n[1381]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1382]||(n[1382]=l("p",null,"Sets the decomposition/turnover rates of all carbon pools to 0, i.e., no carbon decomposition and flow.",-1)),n[1383]||(n[1383]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1384]||(n[1384]=l("ul",null,[l("li",null,"None")],-1)),n[1385]||(n[1385]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1386]||(n[1386]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1387]||(n[1387]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])])])],-1)),n[1388]||(n[1388]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1389]||(n[1389]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTau_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1390]||(n[1390]=l("hr",null,null,-1)),n[1391]||(n[1391]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4604]||(n[4604]=l("hr",null,null,-1)),n[4605]||(n[4605]=l("h3",{id:"cTauLAI",tabindex:"-1"},[o("cTauLAI "),l("a",{class:"header-anchor",href:"#cTauLAI","aria-label":'Permalink to "cTauLAI {#cTauLAI}"'},"​")],-1)),l("details",Fn,[l("summary",null,[n[1393]||(n[1393]=l("a",{id:"Sindbad.Models.cTauLAI",href:"#Sindbad.Models.cTauLAI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauLAI")],-1)),n[1394]||(n[1394]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1395]||(n[1395]=u("",4))]),l("details",Nn,[n[1428]||(n[1428]=l("summary",null,"cTauLAI approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTauLAI_CASA"},{default:i(()=>[l("details",On,[l("summary",null,[n[1396]||(n[1396]=l("a",{id:"Sindbad.Models.cTauLAI_CASA",href:"#Sindbad.Models.cTauLAI_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauLAI_CASA")],-1)),n[1397]||(n[1397]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1398]||(n[1398]=l("p",null,"Effect of LAI on turnover rates and computes the seasonal cycle of litterfall and root litterfall based on LAI variations, as modeled in CASA.",-1)),n[1399]||(n[1399]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1400]||(n[1400]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"max_min_LAI"),o(": 12.0 ∈ [11.0, 13.0] => maximum value for the minimum LAI for litter scalars (units: "),l("code",null,"m2/m2"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k_root_LAI"),o(": 0.3 ∈ [0.0, 1.0] => constant fraction of root litter inputs ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1401]||(n[1401]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1402]||(n[1402]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1403]||(n[1403]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_LAI"),o(": effect of LAI on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1404]||(n[1404]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1405]||(n[1405]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_LAI"),o(": effect of LAI on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"states.LAI"),o(": leaf area index")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k"),o(": decomposition rate of carbon per pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.p_LAI13"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :p_LAI13)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_cVegLeafZix"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :p_cVegLeafZix)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.p_cVegRootZix"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :p_cVegRootZix)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_LAI"),o(": effect of LAI on carbon decomposition rate. 1: no stress, 0: complete stress")])])])])],-1)),n[1406]||(n[1406]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1407]||(n[1407]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauLAI_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1408]||(n[1408]=l("hr",null,null,-1)),n[1409]||(n[1409]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1410]||(n[1410]=l("p",null,[l("em",null,"References")],-1)),n[1411]||(n[1411]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; J. T. Randerson; C. B. Field; P. A. Matson; P. M. Vitousek; H. A. Mooney; & S. A. Klooster. 1993. Terrestrial ecosystem production: A process model based on global satellite & surface data. Global Biogeochemical Cycles. 7: 811-841.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1412]||(n[1412]=l("p",null,[l("em",null,"Versions")],-1)),n[1413]||(n[1413]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 12.01.2020 [sbesnard]")]),l("li",null,[l("p",null,"1.0 on 12.01.2020 [sbesnard]")]),l("li",null,[l("p",null,"1.1 on 05.11.2020 [skoirala | @dr-ko]: speedup")])],-1)),n[1414]||(n[1414]=l("p",null,[l("em",null,"Created by")],-1)),n[1415]||(n[1415]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cTauLAI_none"},{default:i(()=>[l("details",Bn,[l("summary",null,[n[1416]||(n[1416]=l("a",{id:"Sindbad.Models.cTauLAI_none",href:"#Sindbad.Models.cTauLAI_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauLAI_none")],-1)),n[1417]||(n[1417]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1418]||(n[1418]=l("p",null,"Sets the litterfall scalar values to 1 (no LAI effect).",-1)),n[1419]||(n[1419]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1420]||(n[1420]=l("ul",null,[l("li",null,"None")],-1)),n[1421]||(n[1421]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1422]||(n[1422]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1423]||(n[1423]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_LAI"),o(": effect of LAI on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1424]||(n[1424]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1425]||(n[1425]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauLAI_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1426]||(n[1426]=l("hr",null,null,-1)),n[1427]||(n[1427]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4606]||(n[4606]=l("hr",null,null,-1)),n[4607]||(n[4607]=l("h3",{id:"cTauSoilProperties",tabindex:"-1"},[o("cTauSoilProperties "),l("a",{class:"header-anchor",href:"#cTauSoilProperties","aria-label":'Permalink to "cTauSoilProperties {#cTauSoilProperties}"'},"​")],-1)),l("details",Gn,[l("summary",null,[n[1429]||(n[1429]=l("a",{id:"Sindbad.Models.cTauSoilProperties",href:"#Sindbad.Models.cTauSoilProperties"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilProperties")],-1)),n[1430]||(n[1430]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1431]||(n[1431]=u("",4))]),l("details",Ln,[n[1464]||(n[1464]=l("summary",null,"cTauSoilProperties approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTauSoilProperties_CASA"},{default:i(()=>[l("details",zn,[l("summary",null,[n[1432]||(n[1432]=l("a",{id:"Sindbad.Models.cTauSoilProperties_CASA",href:"#Sindbad.Models.cTauSoilProperties_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilProperties_CASA")],-1)),n[1433]||(n[1433]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1434]||(n[1434]=l("p",null,"Compute soil texture effects on turnover rates [k] of cMicSoil",-1)),n[1435]||(n[1435]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1436]||(n[1436]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"TEXTEFFA"),o(": 0.75 ∈ [0.0, 1.0] => effect of soil texture on turnove times ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1437]||(n[1437]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1438]||(n[1438]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1439]||(n[1439]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soil_props"),o(": effect of soil_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1440]||(n[1440]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1441]||(n[1441]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soil_props"),o(": effect of soil_props on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soil_props"),o(": effect of soil_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1442]||(n[1442]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1443]||(n[1443]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilProperties_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1444]||(n[1444]=l("hr",null,null,-1)),n[1445]||(n[1445]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1446]||(n[1446]=l("p",null,[l("em",null,"References")],-1)),n[1447]||(n[1447]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1448]||(n[1448]=l("p",null,[l("em",null,"Versions")],-1)),n[1449]||(n[1449]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[1450]||(n[1450]=l("p",null,[l("em",null,"Created by")],-1)),n[1451]||(n[1451]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cTauSoilProperties_none"},{default:i(()=>[l("details",Un,[l("summary",null,[n[1452]||(n[1452]=l("a",{id:"Sindbad.Models.cTauSoilProperties_none",href:"#Sindbad.Models.cTauSoilProperties_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilProperties_none")],-1)),n[1453]||(n[1453]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1454]||(n[1454]=l("p",null,"Set soil texture effects to ones (ineficient, should be pix zix_mic)",-1)),n[1455]||(n[1455]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1456]||(n[1456]=l("ul",null,[l("li",null,"None")],-1)),n[1457]||(n[1457]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1458]||(n[1458]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1459]||(n[1459]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soil_props"),o(": effect of soil_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1460]||(n[1460]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1461]||(n[1461]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilProperties_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1462]||(n[1462]=l("hr",null,null,-1)),n[1463]||(n[1463]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4608]||(n[4608]=l("hr",null,null,-1)),n[4609]||(n[4609]=l("h3",{id:"cTauSoilT",tabindex:"-1"},[o("cTauSoilT "),l("a",{class:"header-anchor",href:"#cTauSoilT","aria-label":'Permalink to "cTauSoilT {#cTauSoilT}"'},"​")],-1)),l("details",Jn,[l("summary",null,[n[1465]||(n[1465]=l("a",{id:"Sindbad.Models.cTauSoilT",href:"#Sindbad.Models.cTauSoilT"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilT")],-1)),n[1466]||(n[1466]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1467]||(n[1467]=u("",4))]),l("details",Kn,[n[1498]||(n[1498]=l("summary",null,"cTauSoilT approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTauSoilT_Q10"},{default:i(()=>[l("details",Hn,[l("summary",null,[n[1468]||(n[1468]=l("a",{id:"Sindbad.Models.cTauSoilT_Q10",href:"#Sindbad.Models.cTauSoilT_Q10"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilT_Q10")],-1)),n[1469]||(n[1469]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1470]||(n[1470]=l("p",null,"Effect of soil temperature on decomposition rates using a Q10 function.",-1)),n[1471]||(n[1471]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1472]||(n[1472]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"Q10"),o(": 1.4 ∈ [1.05, 3.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ref_airT"),o(": 30.0 ∈ [0.01, 40.0] => (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Q10_base"),o(": 10.0 ∈ [-Inf, Inf] => base temperature difference (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1473]||(n[1473]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1474]||(n[1474]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1475]||(n[1475]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilT"),o(": effect of soil temperature on heterotrophic respiration respiration. 0: no decomposition, >1 increase in decomposition")])])])],-1)),n[1476]||(n[1476]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1477]||(n[1477]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilT_Q10.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1478]||(n[1478]=l("hr",null,null,-1)),n[1479]||(n[1479]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1480]||(n[1480]=l("p",null,[l("em",null,"References")],-1)),n[1481]||(n[1481]=l("p",null,[l("em",null,"Versions")],-1)),n[1482]||(n[1482]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[1483]||(n[1483]=l("p",null,[l("em",null,"Created by")],-1)),n[1484]||(n[1484]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[1485]||(n[1485]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"cTauSoilT_none"},{default:i(()=>[l("details",qn,[l("summary",null,[n[1486]||(n[1486]=l("a",{id:"Sindbad.Models.cTauSoilT_none",href:"#Sindbad.Models.cTauSoilT_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilT_none")],-1)),n[1487]||(n[1487]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1488]||(n[1488]=l("p",null,"Sets the effect of soil temperature on decomposition rates to 1 (no temperature effect).",-1)),n[1489]||(n[1489]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1490]||(n[1490]=l("ul",null,[l("li",null,"None")],-1)),n[1491]||(n[1491]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1492]||(n[1492]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1493]||(n[1493]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilT"),o(": effect of soil temperature on heterotrophic respiration respiration. 0: no decomposition, >1 increase in decomposition")])])])],-1)),n[1494]||(n[1494]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1495]||(n[1495]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilT_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1496]||(n[1496]=l("hr",null,null,-1)),n[1497]||(n[1497]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4610]||(n[4610]=l("hr",null,null,-1)),n[4611]||(n[4611]=l("h3",{id:"cTauSoilW",tabindex:"-1"},[o("cTauSoilW "),l("a",{class:"header-anchor",href:"#cTauSoilW","aria-label":'Permalink to "cTauSoilW {#cTauSoilW}"'},"​")],-1)),l("details",Zn,[l("summary",null,[n[1499]||(n[1499]=l("a",{id:"Sindbad.Models.cTauSoilW",href:"#Sindbad.Models.cTauSoilW"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilW")],-1)),n[1500]||(n[1500]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1501]||(n[1501]=u("",4))]),l("details",Qn,[n[1556]||(n[1556]=l("summary",null,"cTauSoilW approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTauSoilW_CASA"},{default:i(()=>[l("details",Yn,[l("summary",null,[n[1502]||(n[1502]=l("a",{id:"Sindbad.Models.cTauSoilW_CASA",href:"#Sindbad.Models.cTauSoilW_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilW_CASA")],-1)),n[1503]||(n[1503]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1504]||(n[1504]=l("p",null,"Effect of soil moisture on decomposition rates as modeled in CASA, using the belowground moisture effect (BGME) from the Century model.",-1)),n[1505]||(n[1505]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1506]||(n[1506]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"Aws"),o(": 1.0 ∈ [0.001, 1000.0] => curve (expansion/contraction) controlling parameter ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1507]||(n[1507]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1508]||(n[1508]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1509]||(n[1509]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1510]||(n[1510]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1511]||(n[1511]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:pools, :soilW_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.fsoilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :fsoilW_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.fsoilW"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :fsoilW)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[1512]||(n[1512]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1513]||(n[1513]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilW_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1514]||(n[1514]=l("hr",null,null,-1)),n[1515]||(n[1515]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1516]||(n[1516]=l("p",null,[l("em",null,"References")],-1)),n[1517]||(n[1517]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1518]||(n[1518]=l("p",null,[l("em",null,"Versions")],-1)),n[1519]||(n[1519]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[1520]||(n[1520]=l("p",null,[l("em",null,"Created by")],-1)),n[1521]||(n[1521]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[1522]||(n[1522]=l("p",null,"Notesthe BGME is used as a scalar dependent on soil moisture; as the sum of soil moisture for all layers. This can be partitioned into different soil layers in the soil & affect independently the decomposition processes of pools that are at the surface & deeper in the soils.",-1))])]),_:1}),e(s,{label:"cTauSoilW_GSI"},{default:i(()=>[l("details",Xn,[l("summary",null,[n[1523]||(n[1523]=l("a",{id:"Sindbad.Models.cTauSoilW_GSI",href:"#Sindbad.Models.cTauSoilW_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilW_GSI")],-1)),n[1524]||(n[1524]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1525]||(n[1525]=l("p",null,"Effect of soil moisture on decomposition rates based on the GSI approach.",-1)),n[1526]||(n[1526]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1527]||(n[1527]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"opt_soilW"),o(": 90.0 ∈ [60.0, 95.0] => Optimal moisture for decomposition (units: "),l("code",null,"percent degree of saturation"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"opt_soilW_A"),o(": 0.2 ∈ [0.1, 0.3] => slope of increase (units: "),l("code",null,"per percent"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"opt_soilW_B"),o(": 0.3 ∈ [0.15, 0.5] => slope of decrease (units: "),l("code",null,"per percent"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"w_exp"),o(": 10.0 ∈ [-Inf, Inf] => reference for exponent of sensitivity (units: "),l("code",null,"per percent"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"frac_to_perc"),o(": 100.0 ∈ [-Inf, Inf] => unit converter for fraction to percent ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1528]||(n[1528]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1529]||(n[1529]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1530]||(n[1530]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1531]||(n[1531]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1532]||(n[1532]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cLit"),o(": carbon content of cLit pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.cSoil"),o(": carbon content of cSoil pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1533]||(n[1533]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1534]||(n[1534]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilW_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1535]||(n[1535]=l("hr",null,null,-1)),n[1536]||(n[1536]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1537]||(n[1537]=l("p",null,[l("em",null,"References")],-1)),n[1538]||(n[1538]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1539]||(n[1539]=l("p",null,[l("em",null,"Versions")],-1)),n[1540]||(n[1540]=l("ul",null,[l("li",null,"1.0 on 12.02.2021 [skoirala | @dr-ko]")],-1)),n[1541]||(n[1541]=l("p",null,[l("em",null,"Created by")],-1)),n[1542]||(n[1542]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[1543]||(n[1543]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"cTauSoilW_none"},{default:i(()=>[l("details",$n,[l("summary",null,[n[1544]||(n[1544]=l("a",{id:"Sindbad.Models.cTauSoilW_none",href:"#Sindbad.Models.cTauSoilW_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauSoilW_none")],-1)),n[1545]||(n[1545]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1546]||(n[1546]=l("p",null,"Sets the effect of soil moisture on decomposition rates to 1 (no moisture effect).",-1)),n[1547]||(n[1547]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1548]||(n[1548]=l("ul",null,[l("li",null,"None")],-1)),n[1549]||(n[1549]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1550]||(n[1550]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1551]||(n[1551]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_soilW"),o(": effect of soil moisture on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1552]||(n[1552]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1553]||(n[1553]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauSoilW_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1554]||(n[1554]=l("hr",null,null,-1)),n[1555]||(n[1555]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4612]||(n[4612]=l("hr",null,null,-1)),n[4613]||(n[4613]=l("h3",{id:"cTauVegProperties",tabindex:"-1"},[o("cTauVegProperties "),l("a",{class:"header-anchor",href:"#cTauVegProperties","aria-label":'Permalink to "cTauVegProperties {#cTauVegProperties}"'},"​")],-1)),l("details",hn,[l("summary",null,[n[1557]||(n[1557]=l("a",{id:"Sindbad.Models.cTauVegProperties",href:"#Sindbad.Models.cTauVegProperties"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauVegProperties")],-1)),n[1558]||(n[1558]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1559]||(n[1559]=u("",4))]),l("details",_n,[n[1592]||(n[1592]=l("summary",null,"cTauVegProperties approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cTauVegProperties_CASA"},{default:i(()=>[l("details",lo,[l("summary",null,[n[1560]||(n[1560]=l("a",{id:"Sindbad.Models.cTauVegProperties_CASA",href:"#Sindbad.Models.cTauVegProperties_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauVegProperties_CASA")],-1)),n[1561]||(n[1561]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1562]||(n[1562]=l("p",null,"Effect of vegetation type on decomposition rates as modeled in CASA.",-1)),n[1563]||(n[1563]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1564]||(n[1564]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"LIGNIN_per_PFT"),o(": [0.2, 0.2, 0.22, 0.25, 0.2, 0.15, 0.1, 0.0, 0.2, 0.15, 0.15, 0.1] ∈ [-Inf, Inf] => fraction of litter that is lignin ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"NONSOL2SOLLIGNIN"),o(": 2.22 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"MTFA"),o(": 0.85 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"MTFB"),o(": 0.018 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"C2LIGNIN"),o(": 0.65 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"LIGEFFA"),o(": 3.0 ∈ [-Inf, Inf] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"LITC2N_per_PFT"),o(": [40.0, 50.0, 65.0, 80.0, 50.0, 50.0, 50.0, 0.0, 65.0, 50.0, 50.0, 40.0] ∈ [-Inf, Inf] => carbon-to-nitrogen ratio in litter ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1565]||(n[1565]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1566]||(n[1566]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1567]||(n[1567]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_eco_k_f_veg_props"),o(": effect of veg_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])],-1)),n[1568]||(n[1568]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1569]||(n[1569]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.PFT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:properties, :PFT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_veg_props"),o(": effect of veg_props on carbon decomposition rate. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_τ"),o(": number of years needed for carbon turnover per carbon pool")])]),l("li",null,[l("p",null,[l("code",null,"properties.C2LIGNIN"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:properties, :C2LIGNIN)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"properties.LIGEFF"),o(": LIGEFF_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.LIGNIN"),o(": LIGNIN_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.LITC2N"),o(": LITC2N_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.MTF"),o(": MTF_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.SCLIGNIN"),o(": SCLIGNIN_properties")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_veg_props"),o(": effect of veg_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])])],-1)),n[1570]||(n[1570]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1571]||(n[1571]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauVegProperties_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1572]||(n[1572]=l("hr",null,null,-1)),n[1573]||(n[1573]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1574]||(n[1574]=l("p",null,[l("em",null,"References")],-1)),n[1575]||(n[1575]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[1576]||(n[1576]=l("p",null,[l("em",null,"Versions")],-1)),n[1577]||(n[1577]=l("ul",null,[l("li",null,"1.0 on 12.01.2020 [sbesnard]")],-1)),n[1578]||(n[1578]=l("p",null,[l("em",null,"Created by")],-1)),n[1579]||(n[1579]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"cTauVegProperties_none"},{default:i(()=>[l("details",no,[l("summary",null,[n[1580]||(n[1580]=l("a",{id:"Sindbad.Models.cTauVegProperties_none",href:"#Sindbad.Models.cTauVegProperties_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.cTauVegProperties_none")],-1)),n[1581]||(n[1581]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1582]||(n[1582]=l("p",null,"Sets the effect of vegetation properties on decomposition rates to 1 (no vegetation effect).",-1)),n[1583]||(n[1583]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1584]||(n[1584]=l("ul",null,[l("li",null,"None")],-1)),n[1585]||(n[1585]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1586]||(n[1586]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1587]||(n[1587]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"pools.cEco"),o(": carbon content of cEco pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.LIGEFF"),o(": LIGEFF_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.LIGNIN"),o(": LIGNIN_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.LITC2N"),o(": LITC2N_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.MTF"),o(": MTF_properties")])]),l("li",null,[l("p",null,[l("code",null,"properties.SCLIGNIN"),o(": SCLIGNIN_properties")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.c_eco_k_f_veg_props"),o(": effect of veg_props on carbon decomposition rate. 1: no stress, 0: complete stress")])])])])],-1)),n[1588]||(n[1588]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1589]||(n[1589]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cTauVegProperties_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1590]||(n[1590]=l("hr",null,null,-1)),n[1591]||(n[1591]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4614]||(n[4614]=l("hr",null,null,-1)),n[4615]||(n[4615]=l("h3",{id:"cVegetationDieOff",tabindex:"-1"},[o("cVegetationDieOff "),l("a",{class:"header-anchor",href:"#cVegetationDieOff","aria-label":'Permalink to "cVegetationDieOff {#cVegetationDieOff}"'},"​")],-1)),l("details",oo,[l("summary",null,[n[1593]||(n[1593]=l("a",{id:"Sindbad.Models.cVegetationDieOff",href:"#Sindbad.Models.cVegetationDieOff"},[l("span",{class:"jlbinding"},"Sindbad.Models.cVegetationDieOff")],-1)),n[1594]||(n[1594]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1595]||(n[1595]=u("",4))]),l("details",eo,[n[1616]||(n[1616]=l("summary",null,"cVegetationDieOff approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"cVegetationDieOff_forcing"},{default:i(()=>[l("details",to,[l("summary",null,[n[1596]||(n[1596]=l("a",{id:"Sindbad.Models.cVegetationDieOff_forcing",href:"#Sindbad.Models.cVegetationDieOff_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.cVegetationDieOff_forcing")],-1)),n[1597]||(n[1597]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1598]||(n[1598]=l("p",null,"Get the fraction of vegetation that die off from forcing data.",-1)),n[1599]||(n[1599]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1600]||(n[1600]=l("ul",null,[l("li",null,"None")],-1)),n[1601]||(n[1601]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1602]||(n[1602]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1603]||(n[1603]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_dist_intensity"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_dist_intensity)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_fVegDieOff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_fVegDieOff)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[1604]||(n[1604]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1605]||(n[1605]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_dist_intensity"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_dist_intensity)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.c_fVegDieOff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :c_fVegDieOff)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[1606]||(n[1606]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1607]||(n[1607]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"cVegetationDieOff_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1608]||(n[1608]=l("hr",null,null,-1)),n[1609]||(n[1609]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1610]||(n[1610]=l("p",null,[l("em",null,"References")],-1)),n[1611]||(n[1611]=l("ul",null,[l("li",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")],-1)),n[1612]||(n[1612]=l("p",null,[l("em",null,"Versions")],-1)),n[1613]||(n[1613]=l("ul",null,[l("li",null,"1.0 on summer 2024")],-1)),n[1614]||(n[1614]=l("p",null,[l("em",null,"Created by:")],-1)),n[1615]||(n[1615]=l("ul",null,[l("li",null,"Nuno")],-1))])]),_:1})]),_:1})]),n[4616]||(n[4616]=l("hr",null,null,-1)),n[4617]||(n[4617]=l("h3",{id:"capillaryFlow",tabindex:"-1"},[o("capillaryFlow "),l("a",{class:"header-anchor",href:"#capillaryFlow","aria-label":'Permalink to "capillaryFlow {#capillaryFlow}"'},"​")],-1)),l("details",io,[l("summary",null,[n[1617]||(n[1617]=l("a",{id:"Sindbad.Models.capillaryFlow",href:"#Sindbad.Models.capillaryFlow"},[l("span",{class:"jlbinding"},"Sindbad.Models.capillaryFlow")],-1)),n[1618]||(n[1618]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1619]||(n[1619]=u("",4))]),l("details",so,[n[1640]||(n[1640]=l("summary",null,"capillaryFlow approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"capillaryFlow_VanDijk2010"},{default:i(()=>[l("details",uo,[l("summary",null,[n[1620]||(n[1620]=l("a",{id:"Sindbad.Models.capillaryFlow_VanDijk2010",href:"#Sindbad.Models.capillaryFlow_VanDijk2010"},[l("span",{class:"jlbinding"},"Sindbad.Models.capillaryFlow_VanDijk2010")],-1)),n[1621]||(n[1621]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1622]||(n[1622]=l("p",null,"Computes the upward capillary flux of water through soil layers using the Van Dijk (2010) method.",-1)),n[1623]||(n[1623]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1624]||(n[1624]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"max_frac"),o(": 0.95 ∈ [0.02, 0.98] => max fraction of soil moisture that can be lost as capillary flux ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1625]||(n[1625]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1626]||(n[1626]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1627]||(n[1627]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.soil_capillary_flux"),o(": soil capillary flux per layer")])])])],-1)),n[1628]||(n[1628]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1629]||(n[1629]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.soil_capillary_flux"),o(": soil capillary flux per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.soil_capillary_flux"),o(": soil capillary flux per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1630]||(n[1630]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1631]||(n[1631]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"capillaryFlow_VanDijk2010.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1632]||(n[1632]=l("hr",null,null,-1)),n[1633]||(n[1633]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1634]||(n[1634]=l("p",null,[l("em",null,"References")],-1)),n[1635]||(n[1635]=l("ul",null,[l("li",null,[l("p",null,"AIJM Van Dijk, 2010, The Australian Water Resources Assessment System Technical Report 3. Landscape Model [version 0.5] Technical Description")]),l("li",null,[l("p",null,[l("a",{href:"http://www.clw.csiro.au/publications/waterforahealthycountry/2010/wfhc-aus-water-resources-assessment-system.pdf",target:"_blank",rel:"noreferrer"},"http://www.clw.csiro.au/publications/waterforahealthycountry/2010/wfhc-aus-water-resources-assessment-system.pdf")])])],-1)),n[1636]||(n[1636]=l("p",null,[l("em",null,"Versions")],-1)),n[1637]||(n[1637]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[1638]||(n[1638]=l("p",null,[l("em",null,"Created by")],-1)),n[1639]||(n[1639]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4618]||(n[4618]=l("hr",null,null,-1)),n[4619]||(n[4619]=l("h3",{id:"constants",tabindex:"-1"},[o("constants "),l("a",{class:"header-anchor",href:"#constants","aria-label":'Permalink to "constants {#constants}"'},"​")],-1)),l("details",ro,[l("summary",null,[n[1641]||(n[1641]=l("a",{id:"Sindbad.Models.constants",href:"#Sindbad.Models.constants"},[l("span",{class:"jlbinding"},"Sindbad.Models.constants")],-1)),n[1642]||(n[1642]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1643]||(n[1643]=u("",4))]),l("details",ao,[n[1661]||(n[1661]=l("summary",null,"constants approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"constants_numbers"},{default:i(()=>[l("details",po,[l("summary",null,[n[1644]||(n[1644]=l("a",{id:"Sindbad.Models.constants_numbers",href:"#Sindbad.Models.constants_numbers"},[l("span",{class:"jlbinding"},"Sindbad.Models.constants_numbers")],-1)),n[1645]||(n[1645]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1646]||(n[1646]=l("p",null,"Includes constants for numbers such as 1 to 10.",-1)),n[1647]||(n[1647]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1648]||(n[1648]=l("ul",null,[l("li",null,"None")],-1)),n[1649]||(n[1649]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1650]||(n[1650]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1651]||(n[1651]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_two"),o(": a type stable 2")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_three"),o(": a type stable 3")])])])])],-1)),n[1652]||(n[1652]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1653]||(n[1653]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"constants_numbers.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1654]||(n[1654]=l("hr",null,null,-1)),n[1655]||(n[1655]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1656]||(n[1656]=l("p",null,[l("em",null,"References")],-1)),n[1657]||(n[1657]=l("p",null,[l("em",null,"Versions")],-1)),n[1658]||(n[1658]=l("ul",null,[l("li",null,"1.0 on 14.05.2025 [skoirala]")],-1)),n[1659]||(n[1659]=l("p",null,[l("em",null,"Created by")],-1)),n[1660]||(n[1660]=l("ul",null,[l("li",null,"skoirala")],-1))])]),_:1})]),_:1})]),n[4620]||(n[4620]=l("hr",null,null,-1)),n[4621]||(n[4621]=l("h3",{id:"deriveVariables",tabindex:"-1"},[o("deriveVariables "),l("a",{class:"header-anchor",href:"#deriveVariables","aria-label":'Permalink to "deriveVariables {#deriveVariables}"'},"​")],-1)),l("details",fo,[l("summary",null,[n[1662]||(n[1662]=l("a",{id:"Sindbad.Models.deriveVariables",href:"#Sindbad.Models.deriveVariables"},[l("span",{class:"jlbinding"},"Sindbad.Models.deriveVariables")],-1)),n[1663]||(n[1663]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1664]||(n[1664]=u("",4))]),l("details",go,[n[1680]||(n[1680]=l("summary",null,"deriveVariables approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"deriveVariables_simple"},{default:i(()=>[l("details",mo,[l("summary",null,[n[1665]||(n[1665]=l("a",{id:"Sindbad.Models.deriveVariables_simple",href:"#Sindbad.Models.deriveVariables_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.deriveVariables_simple")],-1)),n[1666]||(n[1666]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1667]||(n[1667]=l("p",null,"Incudes derivation of few variables that may be commonly needed for optimization against some datasets.",-1)),n[1668]||(n[1668]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1669]||(n[1669]=l("ul",null,[l("li",null,"None")],-1)),n[1670]||(n[1670]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1671]||(n[1671]=l("p",null,[l("code",null,"define, precompute, compute, update"),o(" methods are not defined")],-1)),n[1672]||(n[1672]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"deriveVariables_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1673]||(n[1673]=l("hr",null,null,-1)),n[1674]||(n[1674]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1675]||(n[1675]=l("p",null,[l("em",null,"References")],-1)),n[1676]||(n[1676]=l("p",null,[l("em",null,"Versions")],-1)),n[1677]||(n[1677]=l("ul",null,[l("li",null,"1.0 on 19.07.2023 [skoirala | @dr-ko]:")],-1)),n[1678]||(n[1678]=l("p",null,[l("em",null,"Created by")],-1)),n[1679]||(n[1679]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4622]||(n[4622]=l("hr",null,null,-1)),n[4623]||(n[4623]=l("h3",{id:"drainage",tabindex:"-1"},[o("drainage "),l("a",{class:"header-anchor",href:"#drainage","aria-label":'Permalink to "drainage {#drainage}"'},"​")],-1)),l("details",bo,[l("summary",null,[n[1681]||(n[1681]=l("a",{id:"Sindbad.Models.drainage",href:"#Sindbad.Models.drainage"},[l("span",{class:"jlbinding"},"Sindbad.Models.drainage")],-1)),n[1682]||(n[1682]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1683]||(n[1683]=u("",4))]),l("details",yo,[n[1741]||(n[1741]=l("summary",null,"drainage approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"drainage_dos"},{default:i(()=>[l("details",co,[l("summary",null,[n[1684]||(n[1684]=l("a",{id:"Sindbad.Models.drainage_dos",href:"#Sindbad.Models.drainage_dos"},[l("span",{class:"jlbinding"},"Sindbad.Models.drainage_dos")],-1)),n[1685]||(n[1685]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1686]||(n[1686]=l("p",null,"Drainage flux based on an exponential function of soil moisture degree of saturation.",-1)),n[1687]||(n[1687]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1688]||(n[1688]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"dos_exp"),o(": 1.5 ∈ [0.1, 3.0] => exponent of non-linearity for dos influence on drainage in soil ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1689]||(n[1689]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1690]||(n[1690]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1691]||(n[1691]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])])])],-1)),n[1692]||(n[1692]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1693]||(n[1693]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1694]||(n[1694]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1695]||(n[1695]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"drainage_dos.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1696]||(n[1696]=l("hr",null,null,-1)),n[1697]||(n[1697]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1698]||(n[1698]=l("p",null,[l("em",null,"References")],-1)),n[1699]||(n[1699]=l("p",null,[l("em",null,"Versions")],-1)),n[1700]||(n[1700]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[1701]||(n[1701]=l("p",null,[l("em",null,"Created by")],-1)),n[1702]||(n[1702]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"drainage_kUnsat"},{default:i(()=>[l("details",vo,[l("summary",null,[n[1703]||(n[1703]=l("a",{id:"Sindbad.Models.drainage_kUnsat",href:"#Sindbad.Models.drainage_kUnsat"},[l("span",{class:"jlbinding"},"Sindbad.Models.drainage_kUnsat")],-1)),n[1704]||(n[1704]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1705]||(n[1705]=l("p",null,"Drainage flux based on unsaturated hydraulic conductivity.",-1)),n[1706]||(n[1706]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1707]||(n[1707]=l("ul",null,[l("li",null,"None")],-1)),n[1708]||(n[1708]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1709]||(n[1709]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1710]||(n[1710]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])])])],-1)),n[1711]||(n[1711]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1712]||(n[1712]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,"None")])])],-1)),n[1713]||(n[1713]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1714]||(n[1714]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"drainage_kUnsat.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1715]||(n[1715]=l("hr",null,null,-1)),n[1716]||(n[1716]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1717]||(n[1717]=l("p",null,[l("em",null,"References")],-1)),n[1718]||(n[1718]=l("p",null,[l("em",null,"Versions")],-1)),n[1719]||(n[1719]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[1720]||(n[1720]=l("p",null,[l("em",null,"Created by")],-1)),n[1721]||(n[1721]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"drainage_wFC"},{default:i(()=>[l("details",ko,[l("summary",null,[n[1722]||(n[1722]=l("a",{id:"Sindbad.Models.drainage_wFC",href:"#Sindbad.Models.drainage_wFC"},[l("span",{class:"jlbinding"},"Sindbad.Models.drainage_wFC")],-1)),n[1723]||(n[1723]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1724]||(n[1724]=l("p",null,"Drainage flux based on overflow above field capacity.",-1)),n[1725]||(n[1725]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1726]||(n[1726]=l("ul",null,[l("li",null,"None")],-1)),n[1727]||(n[1727]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1728]||(n[1728]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1729]||(n[1729]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])])])],-1)),n[1730]||(n[1730]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1731]||(n[1731]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.drainage"),o(": soil moisture drainage per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.p_nsoilLayers"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:properties, :p_nsoilLayers)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,"None")])])],-1)),n[1732]||(n[1732]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1733]||(n[1733]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"drainage_wFC.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1734]||(n[1734]=l("hr",null,null,-1)),n[1735]||(n[1735]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1736]||(n[1736]=l("p",null,[l("em",null,"References")],-1)),n[1737]||(n[1737]=l("p",null,[l("em",null,"Versions")],-1)),n[1738]||(n[1738]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]: clean up & consistency")],-1)),n[1739]||(n[1739]=l("p",null,[l("em",null,"Created by")],-1)),n[1740]||(n[1740]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1})]),_:1})]),n[4624]||(n[4624]=l("hr",null,null,-1)),n[4625]||(n[4625]=l("h3",{id:"evaporation",tabindex:"-1"},[o("evaporation "),l("a",{class:"header-anchor",href:"#evaporation","aria-label":'Permalink to "evaporation {#evaporation}"'},"​")],-1)),l("details",So,[l("summary",null,[n[1742]||(n[1742]=l("a",{id:"Sindbad.Models.evaporation",href:"#Sindbad.Models.evaporation"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation")],-1)),n[1743]||(n[1743]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1744]||(n[1744]=u("",4))]),l("details",wo,[n[1848]||(n[1848]=l("summary",null,"evaporation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"evaporation_Snyder2000"},{default:i(()=>[l("details",To,[l("summary",null,[n[1745]||(n[1745]=l("a",{id:"Sindbad.Models.evaporation_Snyder2000",href:"#Sindbad.Models.evaporation_Snyder2000"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_Snyder2000")],-1)),n[1746]||(n[1746]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1747]||(n[1747]=l("p",null,"Bare soil evaporation using the relative drying rate of soil following Snyder (2000).",-1)),n[1748]||(n[1748]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1749]||(n[1749]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 1.0 ∈ [0.5, 1.5] => scaling factor for PET to account for maximum bare soil evaporation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β"),o(": 3.0 ∈ [1.0, 5.0] => soil moisture resistance factor for soil evapotranspiration (units: "),l("code",null,"mm^0.5"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1750]||(n[1750]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1751]||(n[1751]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1752]||(n[1752]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.sPET_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :sPET_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[1753]||(n[1753]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1754]||(n[1754]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sPET_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :sPET_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sET"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :sET)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sPET_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :sPET_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1755]||(n[1755]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1756]||(n[1756]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_Snyder2000.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1757]||(n[1757]=l("hr",null,null,-1)),n[1758]||(n[1758]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1759]||(n[1759]=l("p",null,[l("em",null,"References")],-1)),n[1760]||(n[1760]=l("ul",null,[l("li",null,"Snyder, R. L., Bali, K., Ventura, F., & Gomez-MacPherson, H. (2000). Estimating evaporation from bare - nearly bare soil. Journal of irrigation & drainage engineering, 126[6], 399-403.")],-1)),n[1761]||(n[1761]=l("p",null,[l("em",null,"Versions")],-1)),n[1762]||(n[1762]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: transfer from to accommodate land.states.fAPAR")],-1)),n[1763]||(n[1763]=l("p",null,[l("em",null,"Created by")],-1)),n[1764]||(n[1764]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1}),e(s,{label:"evaporation_bareFraction"},{default:i(()=>[l("details",jo,[l("summary",null,[n[1765]||(n[1765]=l("a",{id:"Sindbad.Models.evaporation_bareFraction",href:"#Sindbad.Models.evaporation_bareFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_bareFraction")],-1)),n[1766]||(n[1766]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1767]||(n[1767]=l("p",null,"Bare soil evaporation from the non-vegetated fraction of the grid as a linear function of soil moisture and potential evaporation.",-1)),n[1768]||(n[1768]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1769]||(n[1769]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"ks"),o(": 0.5 ∈ [0.1, 0.95] => resistance against soil evaporation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1770]||(n[1770]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1771]||(n[1771]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1772]||(n[1772]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET_evaporation"),o(": potential soil evaporation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1773]||(n[1773]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1774]||(n[1774]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_bareFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1775]||(n[1775]=l("hr",null,null,-1)),n[1776]||(n[1776]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1777]||(n[1777]=l("p",null,[l("em",null,"References")],-1)),n[1778]||(n[1778]=l("p",null,[l("em",null,"Versions")],-1)),n[1779]||(n[1779]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up the code & moved from prec to dyna to handle land.states.frac_vegetation")],-1)),n[1780]||(n[1780]=l("p",null,[l("em",null,"Created by")],-1)),n[1781]||(n[1781]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")]),l("li",null,[l("p",null,"ttraut")])],-1))])]),_:1}),e(s,{label:"evaporation_demandSupply"},{default:i(()=>[l("details",Eo,[l("summary",null,[n[1782]||(n[1782]=l("a",{id:"Sindbad.Models.evaporation_demandSupply",href:"#Sindbad.Models.evaporation_demandSupply"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_demandSupply")],-1)),n[1783]||(n[1783]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1784]||(n[1784]=l("p",null,"Bare soil evaporation using a demand-supply limited approach.",-1)),n[1785]||(n[1785]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1786]||(n[1786]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 1.0 ∈ [0.1, 3.0] => α coefficient of Priestley-Taylor formula for soil ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k_evaporation"),o(": 0.2 ∈ [0.05, 0.98] => fraction of soil water that can be used for soil evaporation (units: "),l("code",null,"day-1"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])])],-1)),n[1787]||(n[1787]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1788]||(n[1788]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1789]||(n[1789]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET_evaporation"),o(": potential soil evaporation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporationSupply"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :evaporationSupply)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1790]||(n[1790]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1791]||(n[1791]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_demandSupply.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1792]||(n[1792]=l("hr",null,null,-1)),n[1793]||(n[1793]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1794]||(n[1794]=l("p",null,[l("em",null,"References")],-1)),n[1795]||(n[1795]=l("ul",null,[l("li",null,"Teuling et al.")],-1)),n[1796]||(n[1796]=l("p",null,[l("em",null,"Versions")],-1)),n[1797]||(n[1797]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up the code")]),l("li",null,[l("p",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up the code")])],-1)),n[1798]||(n[1798]=l("p",null,[l("em",null,"Created by")],-1)),n[1799]||(n[1799]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")]),l("li",null,[l("p",null,"ttraut")])],-1)),n[1800]||(n[1800]=l("p",null,[l("em",null,"Notes")],-1)),n[1801]||(n[1801]=l("ul",null,[l("li",null,"considers that the soil evaporation can occur from the whole grid & not only the non-vegetated fraction of the grid cell")],-1))])]),_:1}),e(s,{label:"evaporation_fAPAR"},{default:i(()=>[l("details",xo,[l("summary",null,[n[1802]||(n[1802]=l("a",{id:"Sindbad.Models.evaporation_fAPAR",href:"#Sindbad.Models.evaporation_fAPAR"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_fAPAR")],-1)),n[1803]||(n[1803]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1804]||(n[1804]=l("p",null,"Bare soil evaporation from the non-absorbed fAPAR (as a proxy for vegetation fraction) and potential evaporation.",-1)),n[1805]||(n[1805]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1806]||(n[1806]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 1.0 ∈ [0.1, 3.0] => α coefficient of Priestley-Taylor formula for soil ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k_evaporation"),o(": 0.2 ∈ [0.05, 0.95] => fraction of soil water that can be used for soil evaporation (units: "),l("code",null,"day-1"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])])],-1)),n[1807]||(n[1807]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1808]||(n[1808]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1809]||(n[1809]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET_evaporation"),o(": potential soil evaporation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1810]||(n[1810]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1811]||(n[1811]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_fAPAR.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1812]||(n[1812]=l("hr",null,null,-1)),n[1813]||(n[1813]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1814]||(n[1814]=l("p",null,[l("em",null,"References")],-1)),n[1815]||(n[1815]=l("p",null,[l("em",null,"Versions")],-1)),n[1816]||(n[1816]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up the code & moved from prec to dyna to handle land.states.frac_vegetation")],-1)),n[1817]||(n[1817]=l("p",null,[l("em",null,"Created by")],-1)),n[1818]||(n[1818]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1}),e(s,{label:"evaporation_none"},{default:i(()=>[l("details",Co,[l("summary",null,[n[1819]||(n[1819]=l("a",{id:"Sindbad.Models.evaporation_none",href:"#Sindbad.Models.evaporation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_none")],-1)),n[1820]||(n[1820]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1821]||(n[1821]=l("p",null,"Bare soil evaporation set to 0.",-1)),n[1822]||(n[1822]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1823]||(n[1823]=l("ul",null,[l("li",null,"None")],-1)),n[1824]||(n[1824]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1825]||(n[1825]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1826]||(n[1826]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])])])],-1)),n[1827]||(n[1827]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[1828]||(n[1828]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1829]||(n[1829]=l("hr",null,null,-1)),n[1830]||(n[1830]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1}),e(s,{label:"evaporation_vegFraction"},{default:i(()=>[l("details",Mo,[l("summary",null,[n[1831]||(n[1831]=l("a",{id:"Sindbad.Models.evaporation_vegFraction",href:"#Sindbad.Models.evaporation_vegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.evaporation_vegFraction")],-1)),n[1832]||(n[1832]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1833]||(n[1833]=l("p",null,"Bare soil evaporation from the non-vegetated fraction and potential evaporation.",-1)),n[1834]||(n[1834]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1835]||(n[1835]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 1.0 ∈ [0.0, 3.0] => α coefficient of Priestley-Taylor formula for soil ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k_evaporation"),o(": 0.2 ∈ [0.03, 0.98] => fraction of soil water that can be used for soil evaporation (units: "),l("code",null,"day-1"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])])],-1)),n[1836]||(n[1836]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1837]||(n[1837]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1838]||(n[1838]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.PET_evaporation"),o(": potential soil evaporation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[1839]||(n[1839]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1840]||(n[1840]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evaporation_vegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1841]||(n[1841]=l("hr",null,null,-1)),n[1842]||(n[1842]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1843]||(n[1843]=l("p",null,[l("em",null,"References")],-1)),n[1844]||(n[1844]=l("p",null,[l("em",null,"Versions")],-1)),n[1845]||(n[1845]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up the code & moved from prec to dyna to handle land.states.frac_vegetation")],-1)),n[1846]||(n[1846]=l("p",null,[l("em",null,"Created by")],-1)),n[1847]||(n[1847]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1})]),_:1})]),n[4626]||(n[4626]=l("hr",null,null,-1)),n[4627]||(n[4627]=l("h3",{id:"evapotranspiration",tabindex:"-1"},[o("evapotranspiration "),l("a",{class:"header-anchor",href:"#evapotranspiration","aria-label":'Permalink to "evapotranspiration {#evapotranspiration}"'},"​")],-1)),l("details",Io,[l("summary",null,[n[1849]||(n[1849]=l("a",{id:"Sindbad.Models.evapotranspiration",href:"#Sindbad.Models.evapotranspiration"},[l("span",{class:"jlbinding"},"Sindbad.Models.evapotranspiration")],-1)),n[1850]||(n[1850]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1851]||(n[1851]=u("",4))]),l("details",Ao,[n[1871]||(n[1871]=l("summary",null,"evapotranspiration approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"evapotranspiration_sum"},{default:i(()=>[l("details",Po,[l("summary",null,[n[1852]||(n[1852]=l("a",{id:"Sindbad.Models.evapotranspiration_sum",href:"#Sindbad.Models.evapotranspiration_sum"},[l("span",{class:"jlbinding"},"Sindbad.Models.evapotranspiration_sum")],-1)),n[1853]||(n[1853]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1854]||(n[1854]=l("p",null,"Evapotranspiration as a sum of all potential components",-1)),n[1855]||(n[1855]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1856]||(n[1856]=l("ul",null,[l("li",null,"None")],-1)),n[1857]||(n[1857]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1858]||(n[1858]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[1859]||(n[1859]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evapotranspiration"),o(": total land evaporation including soil evaporation, vegetation transpiration, snow sublimation, and interception loss")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sublimation"),o(": sublimation of the snow")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])])])])],-1)),n[1860]||(n[1860]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1861]||(n[1861]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sublimation"),o(": sublimation of the snow")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.evapotranspiration"),o(": total land evaporation including soil evaporation, vegetation transpiration, snow sublimation, and interception loss")])])])],-1)),n[1862]||(n[1862]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[1863]||(n[1863]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"evapotranspiration_sum.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1864]||(n[1864]=l("hr",null,null,-1)),n[1865]||(n[1865]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1866]||(n[1866]=l("p",null,[l("em",null,"References")],-1)),n[1867]||(n[1867]=l("p",null,[l("em",null,"Versions")],-1)),n[1868]||(n[1868]=l("ul",null,[l("li",null,"1.0 on 01.04.2022")],-1)),n[1869]||(n[1869]=l("p",null,[l("em",null,"Created by")],-1)),n[1870]||(n[1870]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4628]||(n[4628]=l("hr",null,null,-1)),n[4629]||(n[4629]=l("h3",{id:"fAPAR",tabindex:"-1"},[o("fAPAR "),l("a",{class:"header-anchor",href:"#fAPAR","aria-label":'Permalink to "fAPAR {#fAPAR}"'},"​")],-1)),l("details",Ro,[l("summary",null,[n[1872]||(n[1872]=l("a",{id:"Sindbad.Models.fAPAR",href:"#Sindbad.Models.fAPAR"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR")],-1)),n[1873]||(n[1873]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1874]||(n[1874]=u("",4))]),l("details",Vo,[n[1994]||(n[1994]=l("summary",null,"fAPAR approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"fAPAR_EVI"},{default:i(()=>[l("details",Wo,[l("summary",null,[n[1875]||(n[1875]=l("a",{id:"Sindbad.Models.fAPAR_EVI",href:"#Sindbad.Models.fAPAR_EVI"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_EVI")],-1)),n[1876]||(n[1876]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1877]||(n[1877]=l("p",null,"fAPAR as a linear function of EVI.",-1)),n[1878]||(n[1878]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1879]||(n[1879]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"EVI_to_fAPAR_c"),o(": 0.0 ∈ [-0.2, 0.3] => intercept of the linear function ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"EVI_to_fAPAR_m"),o(": 1.0 ∈ [0.5, 5] => slope of the linear function ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[1880]||(n[1880]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1881]||(n[1881]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1882]||(n[1882]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.EVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :EVI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1883]||(n[1883]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1884]||(n[1884]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_EVI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1885]||(n[1885]=l("hr",null,null,-1)),n[1886]||(n[1886]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1887]||(n[1887]=l("p",null,[l("em",null,"References")],-1)),n[1888]||(n[1888]=l("p",null,[l("em",null,"Versions")],-1)),n[1889]||(n[1889]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[1890]||(n[1890]=l("p",null,[l("em",null,"Created by")],-1)),n[1891]||(n[1891]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"fAPAR_LAI"},{default:i(()=>[l("details",Do,[l("summary",null,[n[1892]||(n[1892]=l("a",{id:"Sindbad.Models.fAPAR_LAI",href:"#Sindbad.Models.fAPAR_LAI"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_LAI")],-1)),n[1893]||(n[1893]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1894]||(n[1894]=l("p",null,"fAPAR as a function of LAI.",-1)),n[1895]||(n[1895]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1896]||(n[1896]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_extinction"),o(": 0.5 ∈ [1.0e-5, 0.99] => effective light extinction coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1897]||(n[1897]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1898]||(n[1898]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1899]||(n[1899]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.LAI"),o(": leaf area index")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1900]||(n[1900]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1901]||(n[1901]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_LAI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1902]||(n[1902]=l("hr",null,null,-1)),n[1903]||(n[1903]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1904]||(n[1904]=l("p",null,[l("em",null,"References")],-1)),n[1905]||(n[1905]=l("p",null,[l("em",null,"Versions")],-1)),n[1906]||(n[1906]=l("ul",null,[l("li",null,"1.0 on 24.02.2021 [skoirala | @dr-ko]")],-1)),n[1907]||(n[1907]=l("p",null,[l("em",null,"Created by")],-1)),n[1908]||(n[1908]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"fAPAR_cVegLeaf"},{default:i(()=>[l("details",Fo,[l("summary",null,[n[1909]||(n[1909]=l("a",{id:"Sindbad.Models.fAPAR_cVegLeaf",href:"#Sindbad.Models.fAPAR_cVegLeaf"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_cVegLeaf")],-1)),n[1910]||(n[1910]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1911]||(n[1911]=l("p",null,"fAPAR based on the carbon pool of leaves, specific leaf area (SLA), and kLAI.",-1)),n[1912]||(n[1912]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1913]||(n[1913]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_extinction"),o(": 0.005 ∈ [0.0005, 0.05] => effective light extinction coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1914]||(n[1914]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1915]||(n[1915]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1916]||(n[1916]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1917]||(n[1917]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1918]||(n[1918]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_cVegLeaf.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1919]||(n[1919]=l("hr",null,null,-1)),n[1920]||(n[1920]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1921]||(n[1921]=l("p",null,[l("em",null,"References")],-1)),n[1922]||(n[1922]=l("p",null,[l("em",null,"Versions")],-1)),n[1923]||(n[1923]=l("ul",null,[l("li",null,"1.0 on 24.04.2021 [skoirala | @dr-ko]")],-1)),n[1924]||(n[1924]=l("p",null,[l("em",null,"Created by")],-1)),n[1925]||(n[1925]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"fAPAR_cVegLeafBareFrac"},{default:i(()=>[l("details",No,[l("summary",null,[n[1926]||(n[1926]=l("a",{id:"Sindbad.Models.fAPAR_cVegLeafBareFrac",href:"#Sindbad.Models.fAPAR_cVegLeafBareFrac"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_cVegLeafBareFrac")],-1)),n[1927]||(n[1927]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1928]||(n[1928]=l("p",null,"fAPAR based on the carbon pool of leaves, but only for the vegetated fraction.",-1)),n[1929]||(n[1929]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1930]||(n[1930]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_extinction"),o(": 0.005 ∈ [0.0005, 0.05] => effective light extinction coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1931]||(n[1931]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1932]||(n[1932]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1933]||(n[1933]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.cVegLeaf"),o(": carbon content of cVegLeaf pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states # TODO: now use fAPAR_bare as the output for the cost function!.fAPAR_bare"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states # TODO: now use fAPAR_bare as the output for the cost function!, :fAPAR_bare)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states # TODO: now use fAPAR_bare as the output for the cost function!.fAPAR"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states # TODO: now use fAPAR_bare as the output for the cost function!, :fAPAR)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[1934]||(n[1934]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1935]||(n[1935]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_cVegLeafBareFrac.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1936]||(n[1936]=l("hr",null,null,-1)),n[1937]||(n[1937]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1938]||(n[1938]=l("p",null,[l("em",null,"References")],-1)),n[1939]||(n[1939]=l("p",null,[l("em",null,"Versions")],-1)),n[1940]||(n[1940]=l("ul",null,[l("li",null,"1.0 on 24.04.2021 [skoirala | @dr-ko]")],-1)),n[1941]||(n[1941]=l("p",null,[l("em",null,"Created by:")],-1)),n[1942]||(n[1942]=l("ul",null,[l("li",null,"Nuno & skoirala")],-1))])]),_:1}),e(s,{label:"fAPAR_constant"},{default:i(()=>[l("details",Oo,[l("summary",null,[n[1943]||(n[1943]=l("a",{id:"Sindbad.Models.fAPAR_constant",href:"#Sindbad.Models.fAPAR_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_constant")],-1)),n[1944]||(n[1944]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1945]||(n[1945]=l("p",null,"Sets fAPAR as a constant value.",-1)),n[1946]||(n[1946]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1947]||(n[1947]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_fAPAR"),o(": 0.2 ∈ [0.0, 1.0] => a constant fAPAR ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1948]||(n[1948]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1949]||(n[1949]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[1950]||(n[1950]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1951]||(n[1951]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[1952]||(n[1952]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1953]||(n[1953]=l("hr",null,null,-1)),n[1954]||(n[1954]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1955]||(n[1955]=l("p",null,[l("em",null,"References")],-1)),n[1956]||(n[1956]=l("p",null,[l("em",null,"Versions")],-1)),n[1957]||(n[1957]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[1958]||(n[1958]=l("p",null,[l("em",null,"Created by")],-1)),n[1959]||(n[1959]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"fAPAR_forcing"},{default:i(()=>[l("details",Bo,[l("summary",null,[n[1960]||(n[1960]=l("a",{id:"Sindbad.Models.fAPAR_forcing",href:"#Sindbad.Models.fAPAR_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_forcing")],-1)),n[1961]||(n[1961]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1962]||(n[1962]=l("p",null,"Gets fAPAR from forcing data.",-1)),n[1963]||(n[1963]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1964]||(n[1964]=l("ul",null,[l("li",null,"None")],-1)),n[1965]||(n[1965]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1966]||(n[1966]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1967]||(n[1967]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_fAPAR"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_fAPAR)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1968]||(n[1968]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1969]||(n[1969]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1970]||(n[1970]=l("hr",null,null,-1)),n[1971]||(n[1971]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1972]||(n[1972]=l("p",null,[l("em",null,"References")],-1)),n[1973]||(n[1973]=l("p",null,[l("em",null,"Versions")],-1)),n[1974]||(n[1974]=l("ul",null,[l("li",null,"1.0 on 23.11.2019 [skoirala | @dr-ko]: new approach")],-1)),n[1975]||(n[1975]=l("p",null,[l("em",null,"Created by")],-1)),n[1976]||(n[1976]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"fAPAR_vegFraction"},{default:i(()=>[l("details",Go,[l("summary",null,[n[1977]||(n[1977]=l("a",{id:"Sindbad.Models.fAPAR_vegFraction",href:"#Sindbad.Models.fAPAR_vegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.fAPAR_vegFraction")],-1)),n[1978]||(n[1978]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1979]||(n[1979]=l("p",null,"fAPAR as a linear function of vegetation fraction.",-1)),n[1980]||(n[1980]=l("p",null,[l("strong",null,"Parameters")],-1)),n[1981]||(n[1981]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"frac_vegetation_to_fAPAR"),o(": 0.989 ∈ [1.0e-5, 0.99] => linear fraction of fAPAR and frac_vegetation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[1982]||(n[1982]=l("p",null,[l("strong",null,"Methods:")],-1)),n[1983]||(n[1983]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[1984]||(n[1984]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])],-1)),n[1985]||(n[1985]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[1986]||(n[1986]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"fAPAR_vegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[1987]||(n[1987]=l("hr",null,null,-1)),n[1988]||(n[1988]=l("p",null,[l("strong",null,"Extended help")],-1)),n[1989]||(n[1989]=l("p",null,[l("em",null,"References")],-1)),n[1990]||(n[1990]=l("p",null,[l("em",null,"Versions")],-1)),n[1991]||(n[1991]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[1992]||(n[1992]=l("p",null,[l("em",null,"Created by")],-1)),n[1993]||(n[1993]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4630]||(n[4630]=l("hr",null,null,-1)),n[4631]||(n[4631]=l("h3",{id:"getPools",tabindex:"-1"},[o("getPools "),l("a",{class:"header-anchor",href:"#getPools","aria-label":'Permalink to "getPools {#getPools}"'},"​")],-1)),l("details",Lo,[l("summary",null,[n[1995]||(n[1995]=l("a",{id:"Sindbad.Models.getPools",href:"#Sindbad.Models.getPools"},[l("span",{class:"jlbinding"},"Sindbad.Models.getPools")],-1)),n[1996]||(n[1996]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[1997]||(n[1997]=u("",4))]),l("details",zo,[n[2017]||(n[2017]=l("summary",null,"getPools approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"getPools_simple"},{default:i(()=>[l("details",Uo,[l("summary",null,[n[1998]||(n[1998]=l("a",{id:"Sindbad.Models.getPools_simple",href:"#Sindbad.Models.getPools_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.getPools_simple")],-1)),n[1999]||(n[1999]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2e3]||(n[2e3]=l("p",null,"Simply take throughfall as the maximum available water.",-1)),n[2001]||(n[2001]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2002]||(n[2002]=l("ul",null,[l("li",null,"None")],-1)),n[2003]||(n[2003]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2004]||(n[2004]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2005]||(n[2005]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])],-1)),n[2006]||(n[2006]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2007]||(n[2007]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])],-1)),n[2008]||(n[2008]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2009]||(n[2009]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"getPools_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2010]||(n[2010]=l("hr",null,null,-1)),n[2011]||(n[2011]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2012]||(n[2012]=l("p",null,[l("em",null,"References")],-1)),n[2013]||(n[2013]=l("p",null,[l("em",null,"Versions")],-1)),n[2014]||(n[2014]=l("ul",null,[l("li",null,"1.0 on 19.11.2019 [skoirala | @dr-ko]: added the documentation & cleaned the code, added json with development stage")],-1)),n[2015]||(n[2015]=l("p",null,[l("em",null,"Created by")],-1)),n[2016]||(n[2016]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1})]),_:1})]),n[4632]||(n[4632]=l("hr",null,null,-1)),n[4633]||(n[4633]=l("h3",{id:"gpp",tabindex:"-1"},[o("gpp "),l("a",{class:"header-anchor",href:"#gpp","aria-label":'Permalink to "gpp {#gpp}"'},"​")],-1)),l("details",Jo,[l("summary",null,[n[2018]||(n[2018]=l("a",{id:"Sindbad.Models.gpp",href:"#Sindbad.Models.gpp"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp")],-1)),n[2019]||(n[2019]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2020]||(n[2020]=u("",4))]),l("details",Ko,[n[2112]||(n[2112]=l("summary",null,"gpp approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gpp_coupled"},{default:i(()=>[l("details",Ho,[l("summary",null,[n[2021]||(n[2021]=l("a",{id:"Sindbad.Models.gpp_coupled",href:"#Sindbad.Models.gpp_coupled"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp_coupled")],-1)),n[2022]||(n[2022]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2023]||(n[2023]=l("p",null,"GPP based on transpiration supply and water use efficiency (coupled).",-1)),n[2024]||(n[2024]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2025]||(n[2025]=l("ul",null,[l("li",null,"None")],-1)),n[2026]||(n[2026]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2027]||(n[2027]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2028]||(n[2028]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_demand"),o(": demand driven gross primary prorDuctivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])])])],-1)),n[2029]||(n[2029]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2030]||(n[2030]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gpp_coupled.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2031]||(n[2031]=l("hr",null,null,-1)),n[2032]||(n[2032]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2033]||(n[2033]=l("p",null,[l("em",null,"References")],-1)),n[2034]||(n[2034]=l("p",null,[l("em",null,"Versions")],-1)),n[2035]||(n[2035]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[2036]||(n[2036]=l("p",null,[l("em",null,"Created by")],-1)),n[2037]||(n[2037]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[2038]||(n[2038]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gpp_min"},{default:i(()=>[l("details",qo,[l("summary",null,[n[2039]||(n[2039]=l("a",{id:"Sindbad.Models.gpp_min",href:"#Sindbad.Models.gpp_min"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp_min")],-1)),n[2040]||(n[2040]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2041]||(n[2041]=l("p",null,"GPP with potential scaled by the minimum stress scalar of demand and supply for uncoupled model structures.",-1)),n[2042]||(n[2042]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2043]||(n[2043]=l("ul",null,[l("li",null,"None")],-1)),n[2044]||(n[2044]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2045]||(n[2045]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2046]||(n[2046]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_climate"),o(": effect of climate on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"gpp.AllScGPP"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:gpp, :AllScGPP)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2047]||(n[2047]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2048]||(n[2048]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gpp_min.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2049]||(n[2049]=l("hr",null,null,-1)),n[2050]||(n[2050]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2051]||(n[2051]=l("p",null,[l("em",null,"References")],-1)),n[2052]||(n[2052]=l("p",null,[l("em",null,"Versions")],-1)),n[2053]||(n[2053]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2054]||(n[2054]=l("p",null,[l("em",null,"Created by")],-1)),n[2055]||(n[2055]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2056]||(n[2056]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gpp_mult"},{default:i(()=>[l("details",Zo,[l("summary",null,[n[2057]||(n[2057]=l("a",{id:"Sindbad.Models.gpp_mult",href:"#Sindbad.Models.gpp_mult"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp_mult")],-1)),n[2058]||(n[2058]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2059]||(n[2059]=l("p",null,"GPP with potential scaled by the product of stress scalars of demand and supply for uncoupled model structures.",-1)),n[2060]||(n[2060]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2061]||(n[2061]=l("ul",null,[l("li",null,"None")],-1)),n[2062]||(n[2062]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2063]||(n[2063]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2064]||(n[2064]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"gpp.AllScGPP"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:gpp, :AllScGPP)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])])])])],-1)),n[2065]||(n[2065]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2066]||(n[2066]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_climate"),o(": effect of climate on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"gpp.AllScGPP"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:gpp, :AllScGPP)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2067]||(n[2067]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2068]||(n[2068]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gpp_mult.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2069]||(n[2069]=l("hr",null,null,-1)),n[2070]||(n[2070]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2071]||(n[2071]=l("p",null,[l("em",null,"References")],-1)),n[2072]||(n[2072]=l("p",null,[l("em",null,"Versions")],-1)),n[2073]||(n[2073]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2074]||(n[2074]=l("p",null,[l("em",null,"Created by")],-1)),n[2075]||(n[2075]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2076]||(n[2076]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gpp_none"},{default:i(()=>[l("details",Qo,[l("summary",null,[n[2077]||(n[2077]=l("a",{id:"Sindbad.Models.gpp_none",href:"#Sindbad.Models.gpp_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp_none")],-1)),n[2078]||(n[2078]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2079]||(n[2079]=l("p",null,"Sets GPP to 0.",-1)),n[2080]||(n[2080]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2081]||(n[2081]=l("ul",null,[l("li",null,"None")],-1)),n[2082]||(n[2082]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2083]||(n[2083]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2084]||(n[2084]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])])])],-1)),n[2085]||(n[2085]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2086]||(n[2086]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gpp_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2087]||(n[2087]=l("hr",null,null,-1)),n[2088]||(n[2088]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2089]||(n[2089]=l("p",null,[l("em",null,"References")],-1)),n[2090]||(n[2090]=l("p",null,[l("em",null,"Versions")],-1)),n[2091]||(n[2091]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2092]||(n[2092]=l("p",null,[l("em",null,"Created by")],-1)),n[2093]||(n[2093]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"gpp_transpirationWUE"},{default:i(()=>[l("details",Yo,[l("summary",null,[n[2094]||(n[2094]=l("a",{id:"Sindbad.Models.gpp_transpirationWUE",href:"#Sindbad.Models.gpp_transpirationWUE"},[l("span",{class:"jlbinding"},"Sindbad.Models.gpp_transpirationWUE")],-1)),n[2095]||(n[2095]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2096]||(n[2096]=l("p",null,"GPP based on transpiration and water use efficiency.",-1)),n[2097]||(n[2097]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2098]||(n[2098]=l("ul",null,[l("li",null,"None")],-1)),n[2099]||(n[2099]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2100]||(n[2100]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2101]||(n[2101]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])])])],-1)),n[2102]||(n[2102]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2103]||(n[2103]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gpp_transpirationWUE.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2104]||(n[2104]=l("hr",null,null,-1)),n[2105]||(n[2105]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2106]||(n[2106]=l("p",null,[l("em",null,"References")],-1)),n[2107]||(n[2107]=l("p",null,[l("em",null,"Versions")],-1)),n[2108]||(n[2108]=l("ul",null,[l("li",null,"1.0 on 22.11.2023 [skoirala | @dr-ko]")],-1)),n[2109]||(n[2109]=l("p",null,[l("em",null,"Created by")],-1)),n[2110]||(n[2110]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[2111]||(n[2111]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1})]),_:1})]),n[4634]||(n[4634]=l("hr",null,null,-1)),n[4635]||(n[4635]=l("h3",{id:"gppAirT",tabindex:"-1"},[o("gppAirT "),l("a",{class:"header-anchor",href:"#gppAirT","aria-label":'Permalink to "gppAirT {#gppAirT}"'},"​")],-1)),l("details",Xo,[l("summary",null,[n[2113]||(n[2113]=l("a",{id:"Sindbad.Models.gppAirT",href:"#Sindbad.Models.gppAirT"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT")],-1)),n[2114]||(n[2114]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2115]||(n[2115]=u("",4))]),l("details",$o,[n[2250]||(n[2250]=l("summary",null,"gppAirT approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppAirT_CASA"},{default:i(()=>[l("details",ho,[l("summary",null,[n[2116]||(n[2116]=l("a",{id:"Sindbad.Models.gppAirT_CASA",href:"#Sindbad.Models.gppAirT_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_CASA")],-1)),n[2117]||(n[2117]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2118]||(n[2118]=l("p",null,"Temperature effect on GPP based as implemented in CASA.",-1)),n[2119]||(n[2119]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2120]||(n[2120]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"opt_airT"),o(": 25.0 ∈ [5.0, 35.0] => check in CASA code (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"opt_airT_A"),o(": 0.2 ∈ [0.01, 0.3] => increasing slope of sensitivity ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"opt_airT_B"),o(": 0.3 ∈ [0.01, 0.5] => decreasing slope of sensitivity ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"exp_airT"),o(": 10.0 ∈ [9.0, 11.0] => reference for exponent of sensitivity ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2121]||(n[2121]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2122]||(n[2122]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2123]||(n[2123]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2124]||(n[2124]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2125]||(n[2125]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2126]||(n[2126]=l("hr",null,null,-1)),n[2127]||(n[2127]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2128]||(n[2128]=l("p",null,[l("em",null,"References")],-1)),n[2129]||(n[2129]=l("ul",null,[l("li",null,[l("p",null,"Carvalhais; N.; Reichstein; M.; Seixas; J.; Collatz; G. J.; Pereira; J. S.; Berbigier; P. & Rambal, S. (2008). Implications of the carbon cycle steady state assumption for biogeochemical modeling performance & inverse parameter retrieval. Global Biogeochemical Cycles, 22[2].")]),l("li",null,[l("p",null,"Potter, C., Klooster, S., Myneni, R., Genovese, V., Tan, P. N., & Kumar, V. (2003). Continental-scale comparisons of terrestrial carbon sinks estimated from satellite data & ecosystem modeling 1982–1998. Global & Planetary Change, 39[3-4], 201-213.")]),l("li",null,[l("p",null,"Potter; C. S.; Randerson; J. T.; Field; C. B.; Matson; P. A.; Vitousek; P. M.; Mooney; H. A. & Klooster, S. A. (1993). Terrestrial ecosystem production: a process model based on global satellite & surface data. Global Biogeochemical Cycles, 7[4], 811-841.")])],-1)),n[2130]||(n[2130]=l("p",null,[l("em",null,"Versions")],-1)),n[2131]||(n[2131]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2132]||(n[2132]=l("p",null,[l("em",null,"Created by")],-1)),n[2133]||(n[2133]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2134]||(n[2134]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppAirT_GSI"},{default:i(()=>[l("details",_o,[l("summary",null,[n[2135]||(n[2135]=l("a",{id:"Sindbad.Models.gppAirT_GSI",href:"#Sindbad.Models.gppAirT_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_GSI")],-1)),n[2136]||(n[2136]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2137]||(n[2137]=l("p",null,"Temperature effect on GPP based on the GSI implementation of LPJ.",-1)),n[2138]||(n[2138]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2139]||(n[2139]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"f_airT_c_τ"),o(": 0.2 ∈ [0.01, 1.0] => contribution factor for current stressor for cold stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_airT_c_slope"),o(": 0.25 ∈ [0.0, 100.0] => slope of sigmoid for cold stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_airT_c_base"),o(": 7.0 ∈ [1.0, 15.0] => base of sigmoid for cold stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_airT_h_τ"),o(": 0.2 ∈ [0.01, 1.0] => contribution factor for current stressor for heat stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_airT_h_slope"),o(": 1.74 ∈ [0.0, 100.0] => slope of sigmoid for heat stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_airT_h_base"),o(": 41.51 ∈ [25.0, 65.0] => base of sigmoid for heat stress (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2140]||(n[2140]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2141]||(n[2141]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2142]||(n[2142]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_c"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_c)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_h"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_h)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.f_smooth"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :f_smooth)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2143]||(n[2143]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2144]||(n[2144]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_c"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_c)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_h"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_h)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.f_smooth"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :f_smooth)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.cScGPP"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :cScGPP)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.hScGPP"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :hScGPP)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_c"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_c)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT_h"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_airT_h)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2145]||(n[2145]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2146]||(n[2146]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2147]||(n[2147]=l("hr",null,null,-1)),n[2148]||(n[2148]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2149]||(n[2149]=l("p",null,[l("em",null,"References")],-1)),n[2150]||(n[2150]=l("ul",null,[l("li",null,[o("Forkel; M.; Carvalhais; N.; Schaphoff; S.; v. Bloh; W.; Migliavacca; M. Thurner; M.; & Thonicke; K.: Identifying environmental controls on vegetation greenness phenology through model–data integration Biogeosciences; 11; 7025–7050; "),l("a",{href:"https://doi.org/10.5194/bg-11-7025-2014;2014",target:"_blank",rel:"noreferrer"},"https://doi.org/10.5194/bg-11-7025-2014;2014"),o(".")])],-1)),n[2151]||(n[2151]=l("p",null,[l("em",null,"Versions")],-1)),n[2152]||(n[2152]=l("ul",null,[l("li",null,"1.1 on 22.01.2021 (skoirala")],-1)),n[2153]||(n[2153]=l("p",null,[l("em",null,"Created by")],-1)),n[2154]||(n[2154]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[2155]||(n[2155]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppAirT_MOD17"},{default:i(()=>[l("details",le,[l("summary",null,[n[2156]||(n[2156]=l("a",{id:"Sindbad.Models.gppAirT_MOD17",href:"#Sindbad.Models.gppAirT_MOD17"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_MOD17")],-1)),n[2157]||(n[2157]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2158]||(n[2158]=l("p",null,"Temperature effect on GPP based on the MOD17 model.",-1)),n[2159]||(n[2159]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2160]||(n[2160]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"Tmax"),o(": 20.0 ∈ [10.0, 35.0] => temperature for max GPP (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Tmin"),o(": 5.0 ∈ [0.0, 15.0] => temperature for min GPP (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2161]||(n[2161]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2162]||(n[2162]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2163]||(n[2163]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2164]||(n[2164]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2165]||(n[2165]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_MOD17.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2166]||(n[2166]=l("hr",null,null,-1)),n[2167]||(n[2167]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2168]||(n[2168]=l("p",null,[l("em",null,"References")],-1)),n[2169]||(n[2169]=l("ul",null,[l("li",null,[l("p",null,[o("MOD17 User guide: "),l("a",{href:"https://lpdaac.usgs.gov/documents/495/MOD17_User_Guide_V6.pdf",target:"_blank",rel:"noreferrer"},"https://lpdaac.usgs.gov/documents/495/MOD17_User_Guide_V6.pdf")])]),l("li",null,[l("p",null,"Running; S. W.; Nemani; R. R.; Heinsch; F. A.; Zhao; M.; Reeves; M. & Hashimoto, H. (2004). A continuous satellite-derived measure of global terrestrial primary production. Bioscience, 54[6], 547-560.")]),l("li",null,[l("p",null,"Zhao, M., Heinsch, F. A., Nemani, R. R., & Running, S. W. (2005). Improvements of the MODIS terrestrial gross & net primary production global data set. Remote sensing of Environment, 95[2], 164-176.")])],-1)),n[2170]||(n[2170]=l("p",null,[l("em",null,"Versions")],-1)),n[2171]||(n[2171]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2172]||(n[2172]=l("p",null,[l("em",null,"Created by")],-1)),n[2173]||(n[2173]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2174]||(n[2174]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppAirT_Maekelae2008"},{default:i(()=>[l("details",ne,[l("summary",null,[n[2175]||(n[2175]=l("a",{id:"Sindbad.Models.gppAirT_Maekelae2008",href:"#Sindbad.Models.gppAirT_Maekelae2008"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_Maekelae2008")],-1)),n[2176]||(n[2176]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2177]||(n[2177]=l("p",null,"Temperature effect on GPP based on Maekelae (2008).",-1)),n[2178]||(n[2178]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2179]||(n[2179]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"TimConst"),o(": 5.0 ∈ [1.0, 20.0] => time constant for temp delay (units: "),l("code",null,"days"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"X0"),o(": -5.0 ∈ [-15.0, 1.0] => threshold of delay temperature (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"s_max"),o(": 20.0 ∈ [10.0, 30.0] => temperature at saturation (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2180]||(n[2180]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2181]||(n[2181]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2182]||(n[2182]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.X_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :X_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2183]||(n[2183]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2184]||(n[2184]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.X_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :X_prev)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.X_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :X_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2185]||(n[2185]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2186]||(n[2186]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_Maekelae2008.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2187]||(n[2187]=l("hr",null,null,-1)),n[2188]||(n[2188]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2189]||(n[2189]=l("p",null,[l("em",null,"References")],-1)),n[2190]||(n[2190]=l("ul",null,[l("li",null,"Mäkelä, A., Pulkkinen, M., Kolari, P., et al. (2008). Developing an empirical model of stand GPP with the LUE approachanalysis of eddy covariance data at five contrasting conifer sites in Europe. Global change biology, 14[1], 92-108.")],-1)),n[2191]||(n[2191]=l("p",null,[l("em",null,"Versions")],-1)),n[2192]||(n[2192]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2193]||(n[2193]=l("p",null,[l("em",null,"Created by")],-1)),n[2194]||(n[2194]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2195]||(n[2195]=l("p",null,[l("em",null,"Notes")],-1)),n[2196]||(n[2196]=l("ul",null,[l("li",null,"Tmin < Tmax ALWAYS!!!")],-1))])]),_:1}),e(s,{label:"gppAirT_TEM"},{default:i(()=>[l("details",oe,[l("summary",null,[n[2197]||(n[2197]=l("a",{id:"Sindbad.Models.gppAirT_TEM",href:"#Sindbad.Models.gppAirT_TEM"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_TEM")],-1)),n[2198]||(n[2198]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2199]||(n[2199]=l("p",null,"Temperature effect on GPP based on the TEM model.",-1)),n[2200]||(n[2200]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2201]||(n[2201]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"Tmin"),o(": 5.0 ∈ [-10.0, 15.0] => minimum temperature at which GPP ceases (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Tmax"),o(": 20.0 ∈ [10.0, 45.0] => maximum temperature at which GPP ceases (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"opt_airT"),o(": 15.0 ∈ [5.0, 30.0] => optimal temperature for GPP (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2202]||(n[2202]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2203]||(n[2203]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2204]||(n[2204]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_two"),o(": a type stable 2")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2205]||(n[2205]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2206]||(n[2206]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_TEM.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2207]||(n[2207]=l("hr",null,null,-1)),n[2208]||(n[2208]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2209]||(n[2209]=l("p",null,[l("em",null,"References")],-1)),n[2210]||(n[2210]=l("p",null,[l("em",null,"Versions")],-1)),n[2211]||(n[2211]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2212]||(n[2212]=l("p",null,[l("em",null,"Created by")],-1)),n[2213]||(n[2213]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2214]||(n[2214]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppAirT_Wang2014"},{default:i(()=>[l("details",ee,[l("summary",null,[n[2215]||(n[2215]=l("a",{id:"Sindbad.Models.gppAirT_Wang2014",href:"#Sindbad.Models.gppAirT_Wang2014"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_Wang2014")],-1)),n[2216]||(n[2216]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2217]||(n[2217]=l("p",null,"Temperature effect on GPP based on Wang (2014).",-1)),n[2218]||(n[2218]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2219]||(n[2219]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"Tmax"),o(": 10.0 ∈ [5.0, 45.0] => maximum temperature at which GPP ceases (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2220]||(n[2220]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2221]||(n[2221]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2222]||(n[2222]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.z_zero"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :z_zero)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.o_one"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :o_one)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2223]||(n[2223]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2224]||(n[2224]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_Wang2014.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2225]||(n[2225]=l("hr",null,null,-1)),n[2226]||(n[2226]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2227]||(n[2227]=l("p",null,[l("em",null,"References")],-1)),n[2228]||(n[2228]=l("ul",null,[l("li",null,"Wang, H., Prentice, I. C., & Davis, T. W. (2014). Biophsyical constraints on gross primary production by the terrestrial biosphere. Biogeosciences, 11[20], 5987.")],-1)),n[2229]||(n[2229]=l("p",null,[l("em",null,"Versions")],-1)),n[2230]||(n[2230]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2231]||(n[2231]=l("p",null,[l("em",null,"Created by")],-1)),n[2232]||(n[2232]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1}),e(s,{label:"gppAirT_none"},{default:i(()=>[l("details",te,[l("summary",null,[n[2233]||(n[2233]=l("a",{id:"Sindbad.Models.gppAirT_none",href:"#Sindbad.Models.gppAirT_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppAirT_none")],-1)),n[2234]||(n[2234]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2235]||(n[2235]=l("p",null,"Sets temperature stress on GPP to 1 (no stress).",-1)),n[2236]||(n[2236]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2237]||(n[2237]=l("ul",null,[l("li",null,"None")],-1)),n[2238]||(n[2238]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2239]||(n[2239]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2240]||(n[2240]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2241]||(n[2241]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2242]||(n[2242]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppAirT_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2243]||(n[2243]=l("hr",null,null,-1)),n[2244]||(n[2244]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2245]||(n[2245]=l("p",null,[l("em",null,"References")],-1)),n[2246]||(n[2246]=l("p",null,[l("em",null,"Versions")],-1)),n[2247]||(n[2247]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2248]||(n[2248]=l("p",null,[l("em",null,"Created by")],-1)),n[2249]||(n[2249]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4636]||(n[4636]=l("hr",null,null,-1)),n[4637]||(n[4637]=l("h3",{id:"gppDemand",tabindex:"-1"},[o("gppDemand "),l("a",{class:"header-anchor",href:"#gppDemand","aria-label":'Permalink to "gppDemand {#gppDemand}"'},"​")],-1)),l("details",ie,[l("summary",null,[n[2251]||(n[2251]=l("a",{id:"Sindbad.Models.gppDemand",href:"#Sindbad.Models.gppDemand"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDemand")],-1)),n[2252]||(n[2252]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2253]||(n[2253]=u("",4))]),l("details",se,[n[2311]||(n[2311]=l("summary",null,"gppDemand approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppDemand_min"},{default:i(()=>[l("details",ue,[l("summary",null,[n[2254]||(n[2254]=l("a",{id:"Sindbad.Models.gppDemand_min",href:"#Sindbad.Models.gppDemand_min"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDemand_min")],-1)),n[2255]||(n[2255]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2256]||(n[2256]=l("p",null,"Demand GPP as the minimum of all stress scalars (most limiting factor).",-1)),n[2257]||(n[2257]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2258]||(n[2258]=l("ul",null,[l("li",null,"None")],-1)),n[2259]||(n[2259]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2260]||(n[2260]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2261]||(n[2261]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"land.land_pools = pools"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:land, :land_pools = pools)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_climate_stressors"),o(": a collection of all gpp climate stressors including light, temperature, radiation, and vpd")])])])],-1)),n[2262]||(n[2262]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2263]||(n[2263]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_light"),o(": effect of light on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_climate_stressors"),o(": a collection of all gpp climate stressors including light, temperature, radiation, and vpd")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_climate"),o(": effect of climate on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_demand"),o(": demand driven gross primary prorDuctivity")])])])])],-1)),n[2264]||(n[2264]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2265]||(n[2265]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDemand_min.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2266]||(n[2266]=l("hr",null,null,-1)),n[2267]||(n[2267]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2268]||(n[2268]=l("p",null,[l("em",null,"References")],-1)),n[2269]||(n[2269]=l("p",null,[l("em",null,"Versions")],-1)),n[2270]||(n[2270]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2271]||(n[2271]=l("p",null,[l("em",null,"Created by")],-1)),n[2272]||(n[2272]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2273]||(n[2273]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppDemand_mult"},{default:i(()=>[l("details",re,[l("summary",null,[n[2274]||(n[2274]=l("a",{id:"Sindbad.Models.gppDemand_mult",href:"#Sindbad.Models.gppDemand_mult"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDemand_mult")],-1)),n[2275]||(n[2275]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2276]||(n[2276]=l("p",null,"Demand GPP as the product of all stress scalars.",-1)),n[2277]||(n[2277]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2278]||(n[2278]=l("ul",null,[l("li",null,"None")],-1)),n[2279]||(n[2279]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2280]||(n[2280]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2281]||(n[2281]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_climate_stressors"),o(": a collection of all gpp climate stressors including light, temperature, radiation, and vpd")])])])],-1)),n[2282]||(n[2282]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2283]||(n[2283]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_light"),o(": effect of light on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_climate_stressors"),o(": a collection of all gpp climate stressors including light, temperature, radiation, and vpd")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_airT"),o(": effect of air temperature on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_climate_stressors"),o(": a collection of all gpp climate stressors including light, temperature, radiation, and vpd")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_climate"),o(": effect of climate on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_demand"),o(": demand driven gross primary prorDuctivity")])])])])],-1)),n[2284]||(n[2284]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2285]||(n[2285]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDemand_mult.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2286]||(n[2286]=l("hr",null,null,-1)),n[2287]||(n[2287]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2288]||(n[2288]=l("p",null,[l("em",null,"References")],-1)),n[2289]||(n[2289]=l("p",null,[l("em",null,"Versions")],-1)),n[2290]||(n[2290]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2291]||(n[2291]=l("p",null,[l("em",null,"Created by")],-1)),n[2292]||(n[2292]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2293]||(n[2293]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppDemand_none"},{default:i(()=>[l("details",ae,[l("summary",null,[n[2294]||(n[2294]=l("a",{id:"Sindbad.Models.gppDemand_none",href:"#Sindbad.Models.gppDemand_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDemand_none")],-1)),n[2295]||(n[2295]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2296]||(n[2296]=l("p",null,"Sets the scalar for demand GPP to 1 and demand GPP to 0.",-1)),n[2297]||(n[2297]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2298]||(n[2298]=l("ul",null,[l("li",null,"None")],-1)),n[2299]||(n[2299]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2300]||(n[2300]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2301]||(n[2301]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_climate"),o(": effect of climate on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_demand"),o(": demand driven gross primary prorDuctivity")])])])])],-1)),n[2302]||(n[2302]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2303]||(n[2303]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDemand_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2304]||(n[2304]=l("hr",null,null,-1)),n[2305]||(n[2305]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2306]||(n[2306]=l("p",null,[l("em",null,"References")],-1)),n[2307]||(n[2307]=l("p",null,[l("em",null,"Versions")],-1)),n[2308]||(n[2308]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2309]||(n[2309]=l("p",null,[l("em",null,"Created by")],-1)),n[2310]||(n[2310]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4638]||(n[4638]=l("hr",null,null,-1)),n[4639]||(n[4639]=l("h3",{id:"gppDiffRadiation",tabindex:"-1"},[o("gppDiffRadiation "),l("a",{class:"header-anchor",href:"#gppDiffRadiation","aria-label":'Permalink to "gppDiffRadiation {#gppDiffRadiation}"'},"​")],-1)),l("details",de,[l("summary",null,[n[2312]||(n[2312]=l("a",{id:"Sindbad.Models.gppDiffRadiation",href:"#Sindbad.Models.gppDiffRadiation"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDiffRadiation")],-1)),n[2313]||(n[2313]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2314]||(n[2314]=u("",4))]),l("details",pe,[n[2395]||(n[2395]=l("summary",null,"gppDiffRadiation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppDiffRadiation_GSI"},{default:i(()=>[l("details",fe,[l("summary",null,[n[2315]||(n[2315]=l("a",{id:"Sindbad.Models.gppDiffRadiation_GSI",href:"#Sindbad.Models.gppDiffRadiation_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDiffRadiation_GSI")],-1)),n[2316]||(n[2316]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2317]||(n[2317]=l("p",null,"Cloudiness scalar (radiation diffusion) on GPP potential based on the GSI implementation of LPJ.",-1)),n[2318]||(n[2318]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2319]||(n[2319]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fR_τ"),o(": 0.2 ∈ [0.01, 1.0] => contribution factor for current stressor (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"fR_slope"),o(": 58.0 ∈ [1.0, 100.0] => slope of sigmoid (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"fR_base"),o(": 59.78 ∈ [1.0, 120.0] => base of sigmoid (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2320]||(n[2320]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2321]||(n[2321]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2322]||(n[2322]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.MJ_to_W"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :MJ_to_W)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2323]||(n[2323]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2324]||(n[2324]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.MJ_to_W"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :MJ_to_W)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_cloud_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2325]||(n[2325]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2326]||(n[2326]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDiffRadiation_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2327]||(n[2327]=l("hr",null,null,-1)),n[2328]||(n[2328]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2329]||(n[2329]=l("p",null,[l("em",null,"References")],-1)),n[2330]||(n[2330]=l("ul",null,[l("li",null,[o("Forkel; M.; Carvalhais; N.; Schaphoff; S.; v. Bloh; W.; Migliavacca; M. Thurner; M.; & Thonicke; K.: Identifying environmental controls on vegetation greenness phenology through model–data integration Biogeosciences; 11; 7025–7050; "),l("a",{href:"https://doi.org/10.5194/bg-11-7025-2014;2014",target:"_blank",rel:"noreferrer"},"https://doi.org/10.5194/bg-11-7025-2014;2014"),o(".")])],-1)),n[2331]||(n[2331]=l("p",null,[l("em",null,"Versions")],-1)),n[2332]||(n[2332]=l("ul",null,[l("li",null,"1.1 on 22.01.2021 (skoirala")],-1)),n[2333]||(n[2333]=l("p",null,[l("em",null,"Created by")],-1)),n[2334]||(n[2334]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[2335]||(n[2335]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppDiffRadiation_Turner2006"},{default:i(()=>[l("details",ge,[l("summary",null,[n[2336]||(n[2336]=l("a",{id:"Sindbad.Models.gppDiffRadiation_Turner2006",href:"#Sindbad.Models.gppDiffRadiation_Turner2006"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDiffRadiation_Turner2006")],-1)),n[2337]||(n[2337]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2338]||(n[2338]=l("p",null,"Cloudiness scalar (radiation diffusion) on GPP potential based on Turner (2006).",-1)),n[2339]||(n[2339]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2340]||(n[2340]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"rue_ratio"),o(": 0.5 ∈ [0.0001, 1.0] => ratio of clear sky LUE to max LUE ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2341]||(n[2341]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2342]||(n[2342]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2343]||(n[2343]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_min"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_min)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_max)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2344]||(n[2344]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2345]||(n[2345]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_min"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_min)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_max)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_min"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_min)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.CI_max"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :CI_max)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2346]||(n[2346]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2347]||(n[2347]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDiffRadiation_Turner2006.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2348]||(n[2348]=l("hr",null,null,-1)),n[2349]||(n[2349]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2350]||(n[2350]=l("p",null,[l("em",null,"References")],-1)),n[2351]||(n[2351]=l("ul",null,[l("li",null,"Turner, D. P., Ritts, W. D., Styles, J. M., Yang, Z., Cohen, W. B., Law, B. E., & Thornton, P. E. (2006). A diagnostic carbon flux model to monitor the effects of disturbance & interannual variation in climate on regional NEP. Tellus B: Chemical & Physical Meteorology, 58[5], 476-490. DOI: 10.1111/j.1600-0889.2006.00221.x")],-1)),n[2352]||(n[2352]=l("p",null,[l("em",null,"Versions")],-1)),n[2353]||(n[2353]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2354]||(n[2354]=l("p",null,[l("em",null,"Created by")],-1)),n[2355]||(n[2355]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1))])]),_:1}),e(s,{label:"gppDiffRadiation_Wang2015"},{default:i(()=>[l("details",me,[l("summary",null,[n[2356]||(n[2356]=l("a",{id:"Sindbad.Models.gppDiffRadiation_Wang2015",href:"#Sindbad.Models.gppDiffRadiation_Wang2015"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDiffRadiation_Wang2015")],-1)),n[2357]||(n[2357]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2358]||(n[2358]=l("p",null,"Cloudiness scalar (radiation diffusion) on GPP potential based on Wang (2015).",-1)),n[2359]||(n[2359]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2360]||(n[2360]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"μ"),o(": 0.46 ∈ [0.0001, 1.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2361]||(n[2361]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2362]||(n[2362]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2363]||(n[2363]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_min"),o(": minimum of cloudiness index until the time step from the beginning of simulation (including spinup)")])]),l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_max"),o(": maximum of cloudiness index until the time step from the beginning of simulation (including spinup)")])])])])],-1)),n[2364]||(n[2364]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[2365]||(n[2365]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2366]||(n[2366]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2367]||(n[2367]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_rg_pot"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rg_pot)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_min"),o(": minimum of cloudiness index until the time step from the beginning of simulation (including spinup)")])]),l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_max"),o(": maximum of cloudiness index until the time step from the beginning of simulation (including spinup)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_min"),o(": minimum of cloudiness index until the time step from the beginning of simulation (including spinup)")])]),l("li",null,[l("p",null,[l("code",null,"gppDiffRadiation.CI_max"),o(": maximum of cloudiness index until the time step from the beginning of simulation (including spinup)")])])])])],-1)),n[2368]||(n[2368]=l("p",null,[l("code",null,"update"),o(" methods are not defined")],-1)),n[2369]||(n[2369]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDiffRadiation_Wang2015.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2370]||(n[2370]=l("hr",null,null,-1)),n[2371]||(n[2371]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2372]||(n[2372]=l("p",null,[l("em",null,"References")],-1)),n[2373]||(n[2373]=l("ul",null,[l("li",null,"Turner, D. P., Ritts, W. D., Styles, J. M., Yang, Z., Cohen, W. B., Law, B. E., & Thornton, P. E. (2006). A diagnostic carbon flux model to monitor the effects of disturbance & interannual variation in climate on regional NEP. Tellus B: Chemical & Physical Meteorology, 58[5], 476-490. DOI: 10.1111/j.1600-0889.2006.00221.x")],-1)),n[2374]||(n[2374]=l("p",null,[l("em",null,"Versions")],-1)),n[2375]||(n[2375]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")]),l("li",null,[l("p",null,"1.1 on 22.01.2021 [skoirala | @dr-ko]: minimum & maximum function had [] missing & were not working")])],-1)),n[2376]||(n[2376]=l("p",null,[l("em",null,"Created by")],-1)),n[2377]||(n[2377]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1))])]),_:1}),e(s,{label:"gppDiffRadiation_none"},{default:i(()=>[l("details",be,[l("summary",null,[n[2378]||(n[2378]=l("a",{id:"Sindbad.Models.gppDiffRadiation_none",href:"#Sindbad.Models.gppDiffRadiation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDiffRadiation_none")],-1)),n[2379]||(n[2379]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2380]||(n[2380]=l("p",null,"Sets the cloudiness scalar (radiation diffusion) for GPP potential to 1.",-1)),n[2381]||(n[2381]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2382]||(n[2382]=l("ul",null,[l("li",null,"None")],-1)),n[2383]||(n[2383]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2384]||(n[2384]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2385]||(n[2385]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_cloud"),o(": effect of cloud on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2386]||(n[2386]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2387]||(n[2387]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDiffRadiation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2388]||(n[2388]=l("hr",null,null,-1)),n[2389]||(n[2389]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2390]||(n[2390]=l("p",null,[l("em",null,"References")],-1)),n[2391]||(n[2391]=l("p",null,[l("em",null,"Versions")],-1)),n[2392]||(n[2392]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2393]||(n[2393]=l("p",null,[l("em",null,"Created by")],-1)),n[2394]||(n[2394]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1))])]),_:1})]),_:1})]),n[4640]||(n[4640]=l("hr",null,null,-1)),n[4641]||(n[4641]=l("h3",{id:"gppDirRadiation",tabindex:"-1"},[o("gppDirRadiation "),l("a",{class:"header-anchor",href:"#gppDirRadiation","aria-label":'Permalink to "gppDirRadiation {#gppDirRadiation}"'},"​")],-1)),l("details",ye,[l("summary",null,[n[2396]||(n[2396]=l("a",{id:"Sindbad.Models.gppDirRadiation",href:"#Sindbad.Models.gppDirRadiation"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDirRadiation")],-1)),n[2397]||(n[2397]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2398]||(n[2398]=u("",4))]),l("details",ce,[n[2436]||(n[2436]=l("summary",null,"gppDirRadiation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppDirRadiation_Maekelae2008"},{default:i(()=>[l("details",ve,[l("summary",null,[n[2399]||(n[2399]=l("a",{id:"Sindbad.Models.gppDirRadiation_Maekelae2008",href:"#Sindbad.Models.gppDirRadiation_Maekelae2008"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDirRadiation_Maekelae2008")],-1)),n[2400]||(n[2400]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2401]||(n[2401]=l("p",null,"Light saturation scalar (light effect) on GPP potential based on Maekelae (2008).",-1)),n[2402]||(n[2402]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2403]||(n[2403]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"γ"),o(": 0.04 ∈ [0.001, 0.1] => empirical light response parameter ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2404]||(n[2404]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2405]||(n[2405]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2406]||(n[2406]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_PAR"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_PAR)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_light"),o(": effect of light on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2407]||(n[2407]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2408]||(n[2408]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDirRadiation_Maekelae2008.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2409]||(n[2409]=l("hr",null,null,-1)),n[2410]||(n[2410]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2411]||(n[2411]=l("p",null,[l("em",null,"References")],-1)),n[2412]||(n[2412]=l("ul",null,[l("li",null,"Mäkelä, A., Pulkkinen, M., Kolari, P., et al. (2008). Developing an empirical model of stand GPP with the LUE approachanalysis of eddy covariance data at five contrasting conifer sites in Europe. Global change biology, 14[1], 92-108.")],-1)),n[2413]||(n[2413]=l("p",null,[l("em",null,"Versions")],-1)),n[2414]||(n[2414]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2415]||(n[2415]=l("p",null,[l("em",null,"Created by")],-1)),n[2416]||(n[2416]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1)),n[2417]||(n[2417]=l("p",null,[l("em",null,"Notes")],-1)),n[2418]||(n[2418]=l("ul",null,[l("li",null,"γ is between [0.007 0.05], median !0.04 [m2/mol] in Maekelae et al 2008.")],-1))])]),_:1}),e(s,{label:"gppDirRadiation_none"},{default:i(()=>[l("details",ke,[l("summary",null,[n[2419]||(n[2419]=l("a",{id:"Sindbad.Models.gppDirRadiation_none",href:"#Sindbad.Models.gppDirRadiation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppDirRadiation_none")],-1)),n[2420]||(n[2420]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2421]||(n[2421]=l("p",null,"Sets the light saturation scalar (light effect) on GPP potential to 1.",-1)),n[2422]||(n[2422]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2423]||(n[2423]=l("ul",null,[l("li",null,"None")],-1)),n[2424]||(n[2424]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2425]||(n[2425]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2426]||(n[2426]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_light"),o(": effect of light on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2427]||(n[2427]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2428]||(n[2428]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppDirRadiation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2429]||(n[2429]=l("hr",null,null,-1)),n[2430]||(n[2430]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2431]||(n[2431]=l("p",null,[l("em",null,"References")],-1)),n[2432]||(n[2432]=l("p",null,[l("em",null,"Versions")],-1)),n[2433]||(n[2433]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2434]||(n[2434]=l("p",null,[l("em",null,"Created by")],-1)),n[2435]||(n[2435]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1))])]),_:1})]),_:1})]),n[4642]||(n[4642]=l("hr",null,null,-1)),n[4643]||(n[4643]=l("h3",{id:"gppPotential",tabindex:"-1"},[o("gppPotential "),l("a",{class:"header-anchor",href:"#gppPotential","aria-label":'Permalink to "gppPotential {#gppPotential}"'},"​")],-1)),l("details",Se,[l("summary",null,[n[2437]||(n[2437]=l("a",{id:"Sindbad.Models.gppPotential",href:"#Sindbad.Models.gppPotential"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppPotential")],-1)),n[2438]||(n[2438]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2439]||(n[2439]=u("",4))]),l("details",we,[n[2459]||(n[2459]=l("summary",null,"gppPotential approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppPotential_Monteith"},{default:i(()=>[l("details",Te,[l("summary",null,[n[2440]||(n[2440]=l("a",{id:"Sindbad.Models.gppPotential_Monteith",href:"#Sindbad.Models.gppPotential_Monteith"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppPotential_Monteith")],-1)),n[2441]||(n[2441]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2442]||(n[2442]=l("p",null,"Potential GPP based on radiation use efficiency model/concept of Monteith.",-1)),n[2443]||(n[2443]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2444]||(n[2444]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"εmax"),o(": 2.0 ∈ [0.1, 5.0] => Maximum Radiation Use Efficiency (units: "),l("code",null,"gC/MJ"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2445]||(n[2445]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2446]||(n[2446]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2447]||(n[2447]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_PAR"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_PAR)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_potential"),o(": potential gross primary prorDcutivity")])])])],-1)),n[2448]||(n[2448]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2449]||(n[2449]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppPotential_Monteith.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2450]||(n[2450]=l("hr",null,null,-1)),n[2451]||(n[2451]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2452]||(n[2452]=l("p",null,[l("em",null,"References")],-1)),n[2453]||(n[2453]=l("p",null,[l("em",null,"Versions")],-1)),n[2454]||(n[2454]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2455]||(n[2455]=l("p",null,[l("em",null,"Created by")],-1)),n[2456]||(n[2456]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"ncarvalhais")])],-1)),n[2457]||(n[2457]=l("p",null,[l("em",null,"Notes")],-1)),n[2458]||(n[2458]=l("ul",null,[l("li",null,[l("p",null,"no crontrols for fPAR | meteo factors")]),l("li",null,[l("p",null,"set the potential GPP as maxRUE * f_PAR [gC/m2/dat]")]),l("li",null,[l("p",null,"usually GPP = e_max x f[clim] x FAPAR x f_PAR here GPP = GPPpot x f[clim] x FAPAR GPPpot = e_max x f_PAR f[clim] & FAPAR are [maybe] calculated dynamically")])],-1))])]),_:1})]),_:1})]),n[4644]||(n[4644]=l("hr",null,null,-1)),n[4645]||(n[4645]=l("h3",{id:"gppSoilW",tabindex:"-1"},[o("gppSoilW "),l("a",{class:"header-anchor",href:"#gppSoilW","aria-label":'Permalink to "gppSoilW {#gppSoilW}"'},"​")],-1)),l("details",je,[l("summary",null,[n[2460]||(n[2460]=l("a",{id:"Sindbad.Models.gppSoilW",href:"#Sindbad.Models.gppSoilW"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW")],-1)),n[2461]||(n[2461]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2462]||(n[2462]=u("",4))]),l("details",Ee,[n[2561]||(n[2561]=l("summary",null,"gppSoilW approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppSoilW_CASA"},{default:i(()=>[l("details",xe,[l("summary",null,[n[2463]||(n[2463]=l("a",{id:"Sindbad.Models.gppSoilW_CASA",href:"#Sindbad.Models.gppSoilW_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW_CASA")],-1)),n[2464]||(n[2464]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2465]||(n[2465]=l("p",null,"Soil moisture stress on GPP potential based on base stress and the relative ratio of PET and PAW (CASA).",-1)),n[2466]||(n[2466]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2467]||(n[2467]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"base_f_soilW"),o(": 0.2 ∈ [0, 1] => base water stress ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2468]||(n[2468]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2469]||(n[2469]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2470]||(n[2470]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2471]||(n[2471]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2472]||(n[2472]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.OmBweOPET"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :OmBweOPET)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2473]||(n[2473]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2474]||(n[2474]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppSoilW_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2475]||(n[2475]=l("hr",null,null,-1)),n[2476]||(n[2476]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2477]||(n[2477]=l("p",null,[l("em",null,"References")],-1)),n[2478]||(n[2478]=l("ul",null,[l("li",null,[o("Forkel; M.; Carvalhais; N.; Schaphoff; S.; v. Bloh; W.; Migliavacca; M. Thurner; M.; & Thonicke; K.: Identifying environmental controls on vegetation greenness phenology through model–data integration Biogeosciences; 11; 7025–7050; "),l("a",{href:"https://doi.org/10.5194/bg-11-7025-2014;2014",target:"_blank",rel:"noreferrer"},"https://doi.org/10.5194/bg-11-7025-2014;2014"),o(".")])],-1)),n[2479]||(n[2479]=l("p",null,[l("em",null,"Versions")],-1)),n[2480]||(n[2480]=l("ul",null,[l("li",null,"1.1 on 22.01.2021 [skoirala | @dr-ko]")],-1)),n[2481]||(n[2481]=l("p",null,[l("em",null,"Created by")],-1)),n[2482]||(n[2482]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[2483]||(n[2483]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppSoilW_GSI"},{default:i(()=>[l("details",Ce,[l("summary",null,[n[2484]||(n[2484]=l("a",{id:"Sindbad.Models.gppSoilW_GSI",href:"#Sindbad.Models.gppSoilW_GSI"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW_GSI")],-1)),n[2485]||(n[2485]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2486]||(n[2486]=l("p",null,"Soil moisture stress on GPP potential based on the GSI implementation of LPJ.",-1)),n[2487]||(n[2487]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2488]||(n[2488]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"f_soilW_τ"),o(": 0.8 ∈ [0.01, 1.0] => contribution factor for current stressor (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_soilW_slope"),o(": 5.24 ∈ [1.0, 10.0] => slope of sigmoid (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_soilW_slope_mult"),o(": 100.0 ∈ [-Inf, Inf] => multiplier for the slope of sigmoid (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_soilW_base"),o(": 0.2096 ∈ [0.1, 0.8] => base of sigmoid (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2489]||(n[2489]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2490]||(n[2490]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2491]||(n[2491]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2492]||(n[2492]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2493]||(n[2493]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.∑w_awc"),o(": total amount of water available for vegetation/transpiration")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.gpp_f_soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :gpp_f_soilW_prev)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2494]||(n[2494]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2495]||(n[2495]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppSoilW_GSI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2496]||(n[2496]=l("hr",null,null,-1)),n[2497]||(n[2497]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2498]||(n[2498]=l("p",null,[l("em",null,"References")],-1)),n[2499]||(n[2499]=l("ul",null,[l("li",null,[o("Forkel; M.; Carvalhais; N.; Schaphoff; S.; v. Bloh; W.; Migliavacca; M. Thurner; M.; & Thonicke; K.: Identifying environmental controls on vegetation greenness phenology through model–data integration Biogeosciences; 11; 7025–7050; "),l("a",{href:"https://doi.org/10.5194/bg-11-7025-2014;2014",target:"_blank",rel:"noreferrer"},"https://doi.org/10.5194/bg-11-7025-2014;2014"),o(".")])],-1)),n[2500]||(n[2500]=l("p",null,[l("em",null,"Versions")],-1)),n[2501]||(n[2501]=l("ul",null,[l("li",null,"1.1 on 22.01.2021 [skoirala | @dr-ko]")],-1)),n[2502]||(n[2502]=l("p",null,[l("em",null,"Created by")],-1)),n[2503]||(n[2503]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[2504]||(n[2504]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppSoilW_Keenan2009"},{default:i(()=>[l("details",Me,[l("summary",null,[n[2505]||(n[2505]=l("a",{id:"Sindbad.Models.gppSoilW_Keenan2009",href:"#Sindbad.Models.gppSoilW_Keenan2009"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW_Keenan2009")],-1)),n[2506]||(n[2506]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2507]||(n[2507]=l("p",null,"Soil moisture stress on GPP potential based on Keenan (2009).",-1)),n[2508]||(n[2508]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2509]||(n[2509]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"q"),o(": 0.6 ∈ [0.0, 15.0] => sensitivity of GPP to soil moisture ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_s_max"),o(": 0.7 ∈ [0.2, 1.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f_s_min"),o(": 0.5 ∈ [0.01, 0.95] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2510]||(n[2510]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2511]||(n[2511]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2512]||(n[2512]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2513]||(n[2513]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2514]||(n[2514]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppSoilW_Keenan2009.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2515]||(n[2515]=l("hr",null,null,-1)),n[2516]||(n[2516]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2517]||(n[2517]=l("p",null,[l("em",null,"References")],-1)),n[2518]||(n[2518]=l("ul",null,[l("li",null,"Keenan; T.; García; R.; Friend; A. D.; Zaehle; S.; Gracia C.; & Sabate; S.: Improved understanding of drought controls on seasonal variation in Mediterranean forest canopy CO2 & water fluxes through combined in situ measurements & ecosystem modelling; Biogeosciences; 6; 1423–1444")],-1)),n[2519]||(n[2519]=l("p",null,[l("em",null,"Versions")],-1)),n[2520]||(n[2520]=l("ul",null,[l("li",null,"1.0 on 10.03.2020 [sbesnard]")],-1)),n[2521]||(n[2521]=l("p",null,[l("em",null,"Created by")],-1)),n[2522]||(n[2522]=l("ul",null,[l("li",null,"ncarvalhais & sbesnard")],-1)),n[2523]||(n[2523]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppSoilW_Stocker2020"},{default:i(()=>[l("details",Ie,[l("summary",null,[n[2524]||(n[2524]=l("a",{id:"Sindbad.Models.gppSoilW_Stocker2020",href:"#Sindbad.Models.gppSoilW_Stocker2020"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW_Stocker2020")],-1)),n[2525]||(n[2525]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2526]||(n[2526]=l("p",null,"Soil moisture stress on GPP potential based on Stocker (2020).",-1)),n[2527]||(n[2527]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2528]||(n[2528]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"q"),o(": 1.0 ∈ [0.01, 4.0] => sensitivity of GPP to soil moisture ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"θstar"),o(": 0.6 ∈ [0.1, 1.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2529]||(n[2529]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2530]||(n[2530]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2531]||(n[2531]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2532]||(n[2532]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2533]||(n[2533]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.∑w_fc"),o(": total amount of water in the soil at field capacity")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_two"),o(": a type stable 2")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2534]||(n[2534]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2535]||(n[2535]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppSoilW_Stocker2020.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2536]||(n[2536]=l("hr",null,null,-1)),n[2537]||(n[2537]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2538]||(n[2538]=l("p",null,[l("em",null,"References")],-1)),n[2539]||(n[2539]=l("ul",null,[l("li",null,"Stocker, B. D., Wang, H., Smith, N. G., Harrison, S. P., Keenan, T. F., Sandoval, D., & Prentice, I. C. (2020). P-model v1. 0: an optimality-based light use efficiency model for simulating ecosystem gross primary production. Geoscientific Model Development, 13(3), 1545-1581.")],-1)),n[2540]||(n[2540]=l("p",null,[l("em",null,"Versions")],-1)),n[2541]||(n[2541]=l("p",null,[l("em",null,"Created by")],-1)),n[2542]||(n[2542]=l("ul",null,[l("li",null,"ncarvalhais & Shanning Bao [sbao]")],-1)),n[2543]||(n[2543]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppSoilW_none"},{default:i(()=>[l("details",Ae,[l("summary",null,[n[2544]||(n[2544]=l("a",{id:"Sindbad.Models.gppSoilW_none",href:"#Sindbad.Models.gppSoilW_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppSoilW_none")],-1)),n[2545]||(n[2545]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2546]||(n[2546]=l("p",null,"Sets soil moisture stress on GPP potential to 1 (no stress).",-1)),n[2547]||(n[2547]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2548]||(n[2548]=l("ul",null,[l("li",null,"None")],-1)),n[2549]||(n[2549]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2550]||(n[2550]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2551]||(n[2551]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_soilW"),o(": effect of soil moisture on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2552]||(n[2552]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2553]||(n[2553]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppSoilW_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2554]||(n[2554]=l("hr",null,null,-1)),n[2555]||(n[2555]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2556]||(n[2556]=l("p",null,[l("em",null,"References")],-1)),n[2557]||(n[2557]=l("p",null,[l("em",null,"Versions")],-1)),n[2558]||(n[2558]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2559]||(n[2559]=l("p",null,[l("em",null,"Created by")],-1)),n[2560]||(n[2560]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4646]||(n[4646]=l("hr",null,null,-1)),n[4647]||(n[4647]=l("h3",{id:"gppVPD",tabindex:"-1"},[o("gppVPD "),l("a",{class:"header-anchor",href:"#gppVPD","aria-label":'Permalink to "gppVPD {#gppVPD}"'},"​")],-1)),l("details",Pe,[l("summary",null,[n[2562]||(n[2562]=l("a",{id:"Sindbad.Models.gppVPD",href:"#Sindbad.Models.gppVPD"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD")],-1)),n[2563]||(n[2563]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2564]||(n[2564]=u("",4))]),l("details",Re,[n[2659]||(n[2659]=l("summary",null,"gppVPD approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"gppVPD_MOD17"},{default:i(()=>[l("details",Ve,[l("summary",null,[n[2565]||(n[2565]=l("a",{id:"Sindbad.Models.gppVPD_MOD17",href:"#Sindbad.Models.gppVPD_MOD17"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD_MOD17")],-1)),n[2566]||(n[2566]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2567]||(n[2567]=l("p",null,"VPD stress on GPP potential based on the MOD17 model.",-1)),n[2568]||(n[2568]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2569]||(n[2569]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"VPD_max"),o(": 4.0 ∈ [2.0, 8.0] => Max VPD with GPP > 0 (units: "),l("code",null,"kPa"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"VPD_min"),o(": 0.65 ∈ [0.0, 1.0] => Min VPD with GPP > 0 (units: "),l("code",null,"kPa"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2570]||(n[2570]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2571]||(n[2571]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2572]||(n[2572]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2573]||(n[2573]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2574]||(n[2574]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppVPD_MOD17.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2575]||(n[2575]=l("hr",null,null,-1)),n[2576]||(n[2576]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2577]||(n[2577]=l("p",null,[l("em",null,"References")],-1)),n[2578]||(n[2578]=l("ul",null,[l("li",null,[l("p",null,[o("MOD17 User guide: "),l("a",{href:"https://lpdaac.usgs.gov/documents/495/MOD17_User_Guide_V6.pdf",target:"_blank",rel:"noreferrer"},"https://lpdaac.usgs.gov/documents/495/MOD17_User_Guide_V6.pdf")])]),l("li",null,[l("p",null,"Running; S. W.; Nemani; R. R.; Heinsch; F. A.; Zhao; M.; Reeves; M. & Hashimoto, H. (2004). A continuous satellite-derived measure of global terrestrial primary production. Bioscience, 54[6], 547-560.")]),l("li",null,[l("p",null,"Zhao, M., Heinsch, F. A., Nemani, R. R., & Running, S. W. (2005) Improvements of the MODIS terrestrial gross & net primary production global data set. Remote sensing of Environment, 95[2], 164-176.")])],-1)),n[2579]||(n[2579]=l("p",null,[l("em",null,"Versions")],-1)),n[2580]||(n[2580]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2581]||(n[2581]=l("p",null,[l("em",null,"Created by")],-1)),n[2582]||(n[2582]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2583]||(n[2583]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"gppVPD_Maekelae2008"},{default:i(()=>[l("details",We,[l("summary",null,[n[2584]||(n[2584]=l("a",{id:"Sindbad.Models.gppVPD_Maekelae2008",href:"#Sindbad.Models.gppVPD_Maekelae2008"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD_Maekelae2008")],-1)),n[2585]||(n[2585]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2586]||(n[2586]=l("p",null,"VPD stress on GPP potential based on Maekelae (2008).",-1)),n[2587]||(n[2587]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2588]||(n[2588]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k"),o(": 0.4 ∈ [0.06, 0.7] => empirical parameter assuming typically negative values (units: "),l("code",null,"kPa-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2589]||(n[2589]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2590]||(n[2590]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2591]||(n[2591]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2592]||(n[2592]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2593]||(n[2593]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppVPD_Maekelae2008.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2594]||(n[2594]=l("hr",null,null,-1)),n[2595]||(n[2595]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2596]||(n[2596]=l("p",null,[l("em",null,"References")],-1)),n[2597]||(n[2597]=l("p",null,[l("em",null,"Versions")],-1)),n[2598]||(n[2598]=l("p",null,[l("em",null,"Created by")],-1)),n[2599]||(n[2599]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2600]||(n[2600]=l("p",null,[l("em",null,"Notes")],-1)),n[2601]||(n[2601]=l("ul",null,[l("li",null,"Equation 5. a negative exponent is introduced to have positive parameter values")],-1))])]),_:1}),e(s,{label:"gppVPD_PRELES"},{default:i(()=>[l("details",De,[l("summary",null,[n[2602]||(n[2602]=l("a",{id:"Sindbad.Models.gppVPD_PRELES",href:"#Sindbad.Models.gppVPD_PRELES"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD_PRELES")],-1)),n[2603]||(n[2603]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2604]||(n[2604]=l("p",null,"VPD stress on GPP potential based on Maekelae (2008) and includes the CO₂ effect based on the PRELES model.",-1)),n[2605]||(n[2605]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2606]||(n[2606]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"κ"),o(": 0.4 ∈ [0.06, 0.7] => (units: "),l("code",null,"kPa-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_κ"),o(": 0.4 ∈ [-50.0, 10.0] => ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"base_ambient_CO2"),o(": 295.0 ∈ [250.0, 500.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sat_ambient_CO2"),o(": 2000.0 ∈ [400.0, 4000.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2607]||(n[2607]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2608]||(n[2608]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2609]||(n[2609]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2610]||(n[2610]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2611]||(n[2611]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppVPD_PRELES.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2612]||(n[2612]=l("hr",null,null,-1)),n[2613]||(n[2613]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2614]||(n[2614]=l("p",null,[l("em",null,"References")],-1)),n[2615]||(n[2615]=l("ul",null,[l("li",null,[l("p",null,"Mäkelä, A., Pulkkinen, M., Kolari, P., et al. (2008). Developing an empirical model of stand GPP with the LUE approachanalysis of eddy covariance data at five contrasting conifer sites in Europe. Global change biology, 14[1], 92-108.")]),l("li",null,[l("p",null,[l("a",{href:"http://www.metla.fi/julkaisut/workingpapers/2012/mwp247.pdf",target:"_blank",rel:"noreferrer"},"http://www.metla.fi/julkaisut/workingpapers/2012/mwp247.pdf")])])],-1)),n[2616]||(n[2616]=l("p",null,[l("em",null,"Versions")],-1)),n[2617]||(n[2617]=l("ul",null,[l("li",null,"1.1 on 22.11.2020 [skoirala | @dr-ko]: changing units to kpa for vpd & sign of κ to match with Maekaelae2008")],-1)),n[2618]||(n[2618]=l("p",null,[l("em",null,"Created by")],-1)),n[2619]||(n[2619]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2620]||(n[2620]=l("p",null,[l("em",null,"Notes")],-1)),n[2621]||(n[2621]=l("ul",null,[l("li",null,"sign of exponent is changed to have κ parameter as positive values")],-1))])]),_:1}),e(s,{label:"gppVPD_expco2"},{default:i(()=>[l("details",Fe,[l("summary",null,[n[2622]||(n[2622]=l("a",{id:"Sindbad.Models.gppVPD_expco2",href:"#Sindbad.Models.gppVPD_expco2"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD_expco2")],-1)),n[2623]||(n[2623]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2624]||(n[2624]=l("p",null,"VPD stress on GPP potential based on Maekelae (2008) and includes the CO₂ effect.",-1)),n[2625]||(n[2625]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2626]||(n[2626]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"κ"),o(": 0.4 ∈ [0.06, 0.7] => (units: "),l("code",null,"kPa-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c_κ"),o(": 0.4 ∈ [-50.0, 10.0] => exponent of co2 modulation of vpd effect ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"base_ambient_CO2"),o(": 380.0 ∈ [300.0, 500.0] => (units: "),l("code",null,"ppm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2627]||(n[2627]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2628]||(n[2628]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2629]||(n[2629]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_VPD_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_VPD_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.ambient_CO2"),o(": ambient co2 concentration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2630]||(n[2630]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2631]||(n[2631]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppVPD_expco2.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2632]||(n[2632]=l("hr",null,null,-1)),n[2633]||(n[2633]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2634]||(n[2634]=l("p",null,[l("em",null,"References")],-1)),n[2635]||(n[2635]=l("ul",null,[l("li",null,[l("p",null,"Mäkelä, A., Pulkkinen, M., Kolari, P., et al. (2008). Developing an empirical model of stand GPP with the LUE approachanalysis of eddy covariance data at five contrasting conifer sites in Europe. Global change biology, 14[1], 92-108.")]),l("li",null,[l("p",null,[l("a",{href:"http://www.metla.fi/julkaisut/workingpapers/2012/mwp247.pdf",target:"_blank",rel:"noreferrer"},"http://www.metla.fi/julkaisut/workingpapers/2012/mwp247.pdf")])])],-1)),n[2636]||(n[2636]=l("p",null,[l("em",null,"Versions")],-1)),n[2637]||(n[2637]=l("ul",null,[l("li",null,"1.1 on 22.11.2020 [skoirala | @dr-ko]: changing units to kpa for vpd & sign of κ to match with Maekaelae2008")],-1)),n[2638]||(n[2638]=l("p",null,[l("em",null,"Created by")],-1)),n[2639]||(n[2639]=l("ul",null,[l("li",null,"ncarvalhais")],-1)),n[2640]||(n[2640]=l("p",null,[l("em",null,"Notes")],-1)),n[2641]||(n[2641]=l("ul",null,[l("li",null,"sign of exponent is changed to have κ parameter as positive values")],-1))])]),_:1}),e(s,{label:"gppVPD_none"},{default:i(()=>[l("details",Ne,[l("summary",null,[n[2642]||(n[2642]=l("a",{id:"Sindbad.Models.gppVPD_none",href:"#Sindbad.Models.gppVPD_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.gppVPD_none")],-1)),n[2643]||(n[2643]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2644]||(n[2644]=l("p",null,"Sets VPD stress on GPP potential to 1 (no stress).",-1)),n[2645]||(n[2645]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2646]||(n[2646]=l("ul",null,[l("li",null,"None")],-1)),n[2647]||(n[2647]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2648]||(n[2648]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2649]||(n[2649]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.gpp_f_vpd"),o(": effect of vpd on gpp. 1: no stress, 0: complete stress")])])])],-1)),n[2650]||(n[2650]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2651]||(n[2651]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"gppVPD_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2652]||(n[2652]=l("hr",null,null,-1)),n[2653]||(n[2653]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2654]||(n[2654]=l("p",null,[l("em",null,"References")],-1)),n[2655]||(n[2655]=l("p",null,[l("em",null,"Versions")],-1)),n[2656]||(n[2656]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: documentation & clean up")],-1)),n[2657]||(n[2657]=l("p",null,[l("em",null,"Created by")],-1)),n[2658]||(n[2658]=l("ul",null,[l("li",null,"ncarvalhais")],-1))])]),_:1})]),_:1})]),n[4648]||(n[4648]=l("hr",null,null,-1)),n[4649]||(n[4649]=l("h3",{id:"groundWRecharge",tabindex:"-1"},[o("groundWRecharge "),l("a",{class:"header-anchor",href:"#groundWRecharge","aria-label":'Permalink to "groundWRecharge {#groundWRecharge}"'},"​")],-1)),l("details",Oe,[l("summary",null,[n[2660]||(n[2660]=l("a",{id:"Sindbad.Models.groundWRecharge",href:"#Sindbad.Models.groundWRecharge"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWRecharge")],-1)),n[2661]||(n[2661]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2662]||(n[2662]=u("",4))]),l("details",Be,[n[2728]||(n[2728]=l("summary",null,"groundWRecharge approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"groundWRecharge_dos"},{default:i(()=>[l("details",Ge,[l("summary",null,[n[2663]||(n[2663]=l("a",{id:"Sindbad.Models.groundWRecharge_dos",href:"#Sindbad.Models.groundWRecharge_dos"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWRecharge_dos")],-1)),n[2664]||(n[2664]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2665]||(n[2665]=l("p",null,"Groundwater recharge as an exponential function of the degree of saturation of the lowermost soil layer.",-1)),n[2666]||(n[2666]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2667]||(n[2667]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"dos_exp"),o(": 1.5 ∈ [1.0, 3.0] => exponent of non-linearity for dos influence on drainage to groundwater ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2668]||(n[2668]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2669]||(n[2669]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2670]||(n[2670]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])],-1)),n[2671]||(n[2671]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2672]||(n[2672]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2673]||(n[2673]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2674]||(n[2674]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWRecharge_dos.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2675]||(n[2675]=l("hr",null,null,-1)),n[2676]||(n[2676]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2677]||(n[2677]=l("p",null,[l("em",null,"References")],-1)),n[2678]||(n[2678]=l("p",null,[l("em",null,"Versions")],-1)),n[2679]||(n[2679]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up")],-1)),n[2680]||(n[2680]=l("p",null,[l("em",null,"Created by")],-1)),n[2681]||(n[2681]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"groundWRecharge_fraction"},{default:i(()=>[l("details",Le,[l("summary",null,[n[2682]||(n[2682]=l("a",{id:"Sindbad.Models.groundWRecharge_fraction",href:"#Sindbad.Models.groundWRecharge_fraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWRecharge_fraction")],-1)),n[2683]||(n[2683]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2684]||(n[2684]=l("p",null,"Groundwater recharge as a fraction of the moisture in the lowermost soil layer.",-1)),n[2685]||(n[2685]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2686]||(n[2686]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"rf"),o(": 0.1 ∈ [0.02, 0.98] => fraction of land runoff that percolates to groundwater ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2687]||(n[2687]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2688]||(n[2688]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2689]||(n[2689]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2690]||(n[2690]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2691]||(n[2691]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWRecharge_fraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2692]||(n[2692]=l("hr",null,null,-1)),n[2693]||(n[2693]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2694]||(n[2694]=l("p",null,[l("em",null,"References")],-1)),n[2695]||(n[2695]=l("p",null,[l("em",null,"Versions")],-1)),n[2696]||(n[2696]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up")],-1)),n[2697]||(n[2697]=l("p",null,[l("em",null,"Created by")],-1)),n[2698]||(n[2698]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"groundWRecharge_kUnsat"},{default:i(()=>[l("details",ze,[l("summary",null,[n[2699]||(n[2699]=l("a",{id:"Sindbad.Models.groundWRecharge_kUnsat",href:"#Sindbad.Models.groundWRecharge_kUnsat"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWRecharge_kUnsat")],-1)),n[2700]||(n[2700]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2701]||(n[2701]=l("p",null,"Groundwater recharge as the unsaturated hydraulic conductivity of the lowermost soil layer.",-1)),n[2702]||(n[2702]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2703]||(n[2703]=l("ul",null,[l("li",null,"None")],-1)),n[2704]||(n[2704]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2705]||(n[2705]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2706]||(n[2706]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2707]||(n[2707]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2708]||(n[2708]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWRecharge_kUnsat.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2709]||(n[2709]=l("hr",null,null,-1)),n[2710]||(n[2710]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2711]||(n[2711]=l("p",null,[l("em",null,"References")],-1)),n[2712]||(n[2712]=l("p",null,[l("em",null,"Versions")],-1)),n[2713]||(n[2713]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: clean up")],-1)),n[2714]||(n[2714]=l("p",null,[l("em",null,"Created by")],-1)),n[2715]||(n[2715]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"groundWRecharge_none"},{default:i(()=>[l("details",Ue,[l("summary",null,[n[2716]||(n[2716]=l("a",{id:"Sindbad.Models.groundWRecharge_none",href:"#Sindbad.Models.groundWRecharge_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWRecharge_none")],-1)),n[2717]||(n[2717]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2718]||(n[2718]=l("p",null,"Sets groundwater recharge to 0.",-1)),n[2719]||(n[2719]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2720]||(n[2720]=l("ul",null,[l("li",null,"None")],-1)),n[2721]||(n[2721]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2722]||(n[2722]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2723]||(n[2723]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])],-1)),n[2724]||(n[2724]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2725]||(n[2725]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWRecharge_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2726]||(n[2726]=l("hr",null,null,-1)),n[2727]||(n[2727]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4650]||(n[4650]=l("hr",null,null,-1)),n[4651]||(n[4651]=l("h3",{id:"groundWSoilWInteraction",tabindex:"-1"},[o("groundWSoilWInteraction "),l("a",{class:"header-anchor",href:"#groundWSoilWInteraction","aria-label":'Permalink to "groundWSoilWInteraction {#groundWSoilWInteraction}"'},"​")],-1)),l("details",Je,[l("summary",null,[n[2729]||(n[2729]=l("a",{id:"Sindbad.Models.groundWSoilWInteraction",href:"#Sindbad.Models.groundWSoilWInteraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSoilWInteraction")],-1)),n[2730]||(n[2730]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2731]||(n[2731]=u("",4))]),l("details",Ke,[n[2802]||(n[2802]=l("summary",null,"groundWSoilWInteraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"groundWSoilWInteraction_VanDijk2010"},{default:i(()=>[l("details",He,[l("summary",null,[n[2732]||(n[2732]=l("a",{id:"Sindbad.Models.groundWSoilWInteraction_VanDijk2010",href:"#Sindbad.Models.groundWSoilWInteraction_VanDijk2010"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSoilWInteraction_VanDijk2010")],-1)),n[2733]||(n[2733]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2734]||(n[2734]=l("p",null,"Upward flow of water from groundwater to the lowermost soil layer using the Van Dijk (2010) method.",-1)),n[2735]||(n[2735]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2736]||(n[2736]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"max_fraction"),o(": 0.5 ∈ [0.001, 0.98] => fraction of groundwater that can be lost to capillary flux ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2737]||(n[2737]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2738]||(n[2738]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2739]||(n[2739]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])],-1)),n[2740]||(n[2740]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2741]||(n[2741]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_capillary_flux"),o(": capillary flux from top groundwater layer to the lowermost soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2742]||(n[2742]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2743]||(n[2743]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSoilWInteraction_VanDijk2010.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2744]||(n[2744]=l("hr",null,null,-1)),n[2745]||(n[2745]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2746]||(n[2746]=l("p",null,[l("em",null,"References")],-1)),n[2747]||(n[2747]=l("ul",null,[l("li",null,[l("p",null,"AIJM Van Dijk, 2010, The Australian Water Resources Assessment System Technical Report 3. Landscape Model [version 0.5] Technical Description")]),l("li",null,[l("p",null,[l("a",{href:"http://www.clw.csiro.au/publications/waterforahealthycountry/2010/wfhc-aus-water-resources-assessment-system.pdf",target:"_blank",rel:"noreferrer"},"http://www.clw.csiro.au/publications/waterforahealthycountry/2010/wfhc-aus-water-resources-assessment-system.pdf")])])],-1)),n[2748]||(n[2748]=l("p",null,[l("em",null,"Versions")],-1)),n[2749]||(n[2749]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[2750]||(n[2750]=l("p",null,[l("em",null,"Created by")],-1)),n[2751]||(n[2751]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"groundWSoilWInteraction_gradient"},{default:i(()=>[l("details",qe,[l("summary",null,[n[2752]||(n[2752]=l("a",{id:"Sindbad.Models.groundWSoilWInteraction_gradient",href:"#Sindbad.Models.groundWSoilWInteraction_gradient"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSoilWInteraction_gradient")],-1)),n[2753]||(n[2753]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2754]||(n[2754]=l("p",null,"Delayed/Buffer storage that gives water to the soil when the soil is dry and receives water from the soil when the buffer is low.",-1)),n[2755]||(n[2755]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2756]||(n[2756]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"smax_scale"),o(": 0.5 ∈ [0.0, 50.0] => scale param to yield storage capacity of wGW ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_flux"),o(": 10.0 ∈ [0.0, 20.0] => maximum flux between wGW and wSoil (units: "),l("code",null,"[mm d]"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2757]||(n[2757]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2758]||(n[2758]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2759]||(n[2759]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])],-1)),n[2760]||(n[2760]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2761]||(n[2761]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_groundW"),o(": total number of layers in groundwater pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_capillary_flux"),o(": capillary flux from top groundwater layer to the lowermost soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2762]||(n[2762]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2763]||(n[2763]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSoilWInteraction_gradient.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2764]||(n[2764]=l("hr",null,null,-1)),n[2765]||(n[2765]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2766]||(n[2766]=l("p",null,[l("em",null,"References")],-1)),n[2767]||(n[2767]=l("p",null,[l("em",null,"Versions")],-1)),n[2768]||(n[2768]=l("ul",null,[l("li",null,"1.0 on 04.02.2020 [ttraut]")],-1)),n[2769]||(n[2769]=l("p",null,[l("em",null,"Created by")],-1)),n[2770]||(n[2770]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"groundWSoilWInteraction_gradientNeg"},{default:i(()=>[l("details",Ze,[l("summary",null,[n[2771]||(n[2771]=l("a",{id:"Sindbad.Models.groundWSoilWInteraction_gradientNeg",href:"#Sindbad.Models.groundWSoilWInteraction_gradientNeg"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSoilWInteraction_gradientNeg")],-1)),n[2772]||(n[2772]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2773]||(n[2773]=l("p",null,"Delayed/Buffer storage that does not give water to the soil when the soil is dry, but receives water from the soil when the soil is wet and the buffer is low.",-1)),n[2774]||(n[2774]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2775]||(n[2775]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"smax_scale"),o(": 0.5 ∈ [0.0, 50.0] => scale param to yield storage capacity of wGW ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_flux"),o(": 10.0 ∈ [0.0, 20.0] => maximum flux between wGW and wSoil (units: "),l("code",null,"[mm d]"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2776]||(n[2776]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2777]||(n[2777]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2778]||(n[2778]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])],-1)),n[2779]||(n[2779]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2780]||(n[2780]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_groundW"),o(": total number of layers in groundwater pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_capillary_flux"),o(": capillary flux from top groundwater layer to the lowermost soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.gw_recharge"),o(": net groundwater recharge from the lowermost soil layer, positive => soil to groundwater")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2781]||(n[2781]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[2782]||(n[2782]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSoilWInteraction_gradientNeg.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2783]||(n[2783]=l("hr",null,null,-1)),n[2784]||(n[2784]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2785]||(n[2785]=l("p",null,[l("em",null,"References")],-1)),n[2786]||(n[2786]=l("p",null,[l("em",null,"Versions")],-1)),n[2787]||(n[2787]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 04.02.2020 [ttraut]")]),l("li",null,[l("p",null,"1.0 on 23.09.2020 [ttraut]")])],-1)),n[2788]||(n[2788]=l("p",null,[l("em",null,"Created by")],-1)),n[2789]||(n[2789]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"groundWSoilWInteraction_none"},{default:i(()=>[l("details",Qe,[l("summary",null,[n[2790]||(n[2790]=l("a",{id:"Sindbad.Models.groundWSoilWInteraction_none",href:"#Sindbad.Models.groundWSoilWInteraction_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSoilWInteraction_none")],-1)),n[2791]||(n[2791]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2792]||(n[2792]=l("p",null,"Sets groundwater capillary flux to 0 for no interaction between soil moisture and groundwater.",-1)),n[2793]||(n[2793]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2794]||(n[2794]=l("ul",null,[l("li",null,"None")],-1)),n[2795]||(n[2795]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2796]||(n[2796]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2797]||(n[2797]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.gw_capillary_flux"),o(": capillary flux from top groundwater layer to the lowermost soil layer")])])])],-1)),n[2798]||(n[2798]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2799]||(n[2799]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSoilWInteraction_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2800]||(n[2800]=l("hr",null,null,-1)),n[2801]||(n[2801]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4652]||(n[4652]=l("hr",null,null,-1)),n[4653]||(n[4653]=l("h3",{id:"groundWSurfaceWInteraction",tabindex:"-1"},[o("groundWSurfaceWInteraction "),l("a",{class:"header-anchor",href:"#groundWSurfaceWInteraction","aria-label":'Permalink to "groundWSurfaceWInteraction {#groundWSurfaceWInteraction}"'},"​")],-1)),l("details",Ye,[l("summary",null,[n[2803]||(n[2803]=l("a",{id:"Sindbad.Models.groundWSurfaceWInteraction",href:"#Sindbad.Models.groundWSurfaceWInteraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSurfaceWInteraction")],-1)),n[2804]||(n[2804]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2805]||(n[2805]=u("",4))]),l("details",Xe,[n[2840]||(n[2840]=l("summary",null,"groundWSurfaceWInteraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"groundWSurfaceWInteraction_fracGradient"},{default:i(()=>[l("details",$e,[l("summary",null,[n[2806]||(n[2806]=l("a",{id:"Sindbad.Models.groundWSurfaceWInteraction_fracGradient",href:"#Sindbad.Models.groundWSurfaceWInteraction_fracGradient"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSurfaceWInteraction_fracGradient")],-1)),n[2807]||(n[2807]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2808]||(n[2808]=l("p",null,"Moisture exchange between groundwater and surface water as a fraction of the difference between their storages.",-1)),n[2809]||(n[2809]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2810]||(n[2810]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_gw_to_suw"),o(": 0.001 ∈ [0.0001, 0.01] => maximum transfer rate between GW and surface water (units: "),l("code",null,"/d"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2811]||(n[2811]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2812]||(n[2812]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2813]||(n[2813]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_surfaceW"),o(": total number of layers in surface water pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_groundW"),o(": total number of layers in groundwater pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_to_suw_flux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :gw_to_suw_flux)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2814]||(n[2814]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2815]||(n[2815]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSurfaceWInteraction_fracGradient.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2816]||(n[2816]=l("hr",null,null,-1)),n[2817]||(n[2817]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2818]||(n[2818]=l("p",null,[l("em",null,"References")],-1)),n[2819]||(n[2819]=l("p",null,[l("em",null,"Versions")],-1)),n[2820]||(n[2820]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[2821]||(n[2821]=l("p",null,[l("em",null,"Created by")],-1)),n[2822]||(n[2822]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"groundWSurfaceWInteraction_fracGroundW"},{default:i(()=>[l("details",he,[l("summary",null,[n[2823]||(n[2823]=l("a",{id:"Sindbad.Models.groundWSurfaceWInteraction_fracGroundW",href:"#Sindbad.Models.groundWSurfaceWInteraction_fracGroundW"},[l("span",{class:"jlbinding"},"Sindbad.Models.groundWSurfaceWInteraction_fracGroundW")],-1)),n[2824]||(n[2824]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2825]||(n[2825]=l("p",null,"Depletion of groundwater to surface water as a fraction of groundwater storage.",-1)),n[2826]||(n[2826]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2827]||(n[2827]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_gw_to_suw"),o(": 0.5 ∈ [0.0001, 0.999] => scale parameter for drainage from wGW to wSurf (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2828]||(n[2828]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2829]||(n[2829]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2830]||(n[2830]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_surfaceW"),o(": total number of layers in surface water pool")])]),l("li",null,[l("p",null,[l("code",null,"constants.n_groundW"),o(": total number of layers in groundwater pool")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gw_to_suw_flux"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :gw_to_suw_flux)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[2831]||(n[2831]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2832]||(n[2832]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"groundWSurfaceWInteraction_fracGroundW.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2833]||(n[2833]=l("hr",null,null,-1)),n[2834]||(n[2834]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2835]||(n[2835]=l("p",null,[l("em",null,"References")],-1)),n[2836]||(n[2836]=l("p",null,[l("em",null,"Versions")],-1)),n[2837]||(n[2837]=l("ul",null,[l("li",null,"1.0 on 04.02.2020 [ttraut]")],-1)),n[2838]||(n[2838]=l("p",null,[l("em",null,"Created by")],-1)),n[2839]||(n[2839]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1})]),_:1})]),n[4654]||(n[4654]=l("hr",null,null,-1)),n[4655]||(n[4655]=l("h3",{id:"interception",tabindex:"-1"},[o("interception "),l("a",{class:"header-anchor",href:"#interception","aria-label":'Permalink to "interception {#interception}"'},"​")],-1)),l("details",_e,[l("summary",null,[n[2841]||(n[2841]=l("a",{id:"Sindbad.Models.interception",href:"#Sindbad.Models.interception"},[l("span",{class:"jlbinding"},"Sindbad.Models.interception")],-1)),n[2842]||(n[2842]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2843]||(n[2843]=u("",4))]),l("details",lt,[n[2909]||(n[2909]=l("summary",null,"interception approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"interception_Miralles2010"},{default:i(()=>[l("details",nt,[l("summary",null,[n[2844]||(n[2844]=l("a",{id:"Sindbad.Models.interception_Miralles2010",href:"#Sindbad.Models.interception_Miralles2010"},[l("span",{class:"jlbinding"},"Sindbad.Models.interception_Miralles2010")],-1)),n[2845]||(n[2845]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2846]||(n[2846]=l("p",null,"Interception loss according to the Gash model of Miralles, 2010.",-1)),n[2847]||(n[2847]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2848]||(n[2848]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"canopy_storage"),o(": 1.2 ∈ [0.4, 2.0] => Canopy storage (units: "),l("code",null,"mm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"fte"),o(": 0.02 ∈ [0.02, 0.02] => fraction of trunk evaporation ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"evap_rate"),o(": 0.3 ∈ [0.1, 0.5] => mean evaporation rate (units: "),l("code",null,"mm/hr"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"trunk_capacity"),o(": 0.02 ∈ [0.02, 0.02] => trunk capacity (units: "),l("code",null,"mm"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"pd"),o(": 0.02 ∈ [0.02, 0.02] => fraction rain to trunks ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[2849]||(n[2849]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2850]||(n[2850]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2851]||(n[2851]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"states.rainInt"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :rainInt)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[2852]||(n[2852]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2853]||(n[2853]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"interception_Miralles2010.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2854]||(n[2854]=l("hr",null,null,-1)),n[2855]||(n[2855]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2856]||(n[2856]=l("p",null,[l("em",null,"References")],-1)),n[2857]||(n[2857]=l("ul",null,[l("li",null,"Miralles, D. G., Gash, J. H., Holmes, T. R., de Jeu, R. A., & Dolman, A. J. (2010). Global canopy interception from satellite observations. Journal of Geophysical ResearchAtmospheres, 115[D16].")],-1)),n[2858]||(n[2858]=l("p",null,[l("em",null,"Versions")],-1)),n[2859]||(n[2859]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 22.11.2019 [skoirala | @dr-ko]: handle land.states.fAPAR, rainfall intensity & rainfall")])],-1)),n[2860]||(n[2860]=l("p",null,[l("em",null,"Created by")],-1)),n[2861]||(n[2861]=l("ul",null,[l("li",null,"mjung")],-1)),n[2862]||(n[2862]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"interception_fAPAR"},{default:i(()=>[l("details",ot,[l("summary",null,[n[2863]||(n[2863]=l("a",{id:"Sindbad.Models.interception_fAPAR",href:"#Sindbad.Models.interception_fAPAR"},[l("span",{class:"jlbinding"},"Sindbad.Models.interception_fAPAR")],-1)),n[2864]||(n[2864]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2865]||(n[2865]=l("p",null,"Interception loss as a fraction of fAPAR.",-1)),n[2866]||(n[2866]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2867]||(n[2867]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"isp"),o(": 1.0 ∈ [0.1, 5.0] => fapar dependent storage ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2868]||(n[2868]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2869]||(n[2869]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2870]||(n[2870]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[2871]||(n[2871]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2872]||(n[2872]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"interception_fAPAR.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2873]||(n[2873]=l("hr",null,null,-1)),n[2874]||(n[2874]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2875]||(n[2875]=l("p",null,[l("em",null,"References")],-1)),n[2876]||(n[2876]=l("p",null,[l("em",null,"Versions")],-1)),n[2877]||(n[2877]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 29.11.2019 [skoirala | @dr-ko]: land.states.fAPAR")])],-1)),n[2878]||(n[2878]=l("p",null,[l("em",null,"Created by")],-1)),n[2879]||(n[2879]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"interception_none"},{default:i(()=>[l("details",et,[l("summary",null,[n[2880]||(n[2880]=l("a",{id:"Sindbad.Models.interception_none",href:"#Sindbad.Models.interception_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.interception_none")],-1)),n[2881]||(n[2881]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2882]||(n[2882]=l("p",null,"Sets interception loss to 0.",-1)),n[2883]||(n[2883]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2884]||(n[2884]=l("ul",null,[l("li",null,"None")],-1)),n[2885]||(n[2885]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2886]||(n[2886]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2887]||(n[2887]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])])])],-1)),n[2888]||(n[2888]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[2889]||(n[2889]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"interception_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2890]||(n[2890]=l("hr",null,null,-1)),n[2891]||(n[2891]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1}),e(s,{label:"interception_vegFraction"},{default:i(()=>[l("details",tt,[l("summary",null,[n[2892]||(n[2892]=l("a",{id:"Sindbad.Models.interception_vegFraction",href:"#Sindbad.Models.interception_vegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.interception_vegFraction")],-1)),n[2893]||(n[2893]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2894]||(n[2894]=l("p",null,"Interception loss as a fraction of vegetation cover.",-1)),n[2895]||(n[2895]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2896]||(n[2896]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"p_interception"),o(": 1.0 ∈ [0.0001, 5.0] => maximum interception storage (units: "),l("code",null,"mm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2897]||(n[2897]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2898]||(n[2898]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2899]||(n[2899]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.interception"),o(": interception evaporation loss")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[2900]||(n[2900]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2901]||(n[2901]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"interception_vegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2902]||(n[2902]=l("hr",null,null,-1)),n[2903]||(n[2903]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2904]||(n[2904]=l("p",null,[l("em",null,"References")],-1)),n[2905]||(n[2905]=l("p",null,[l("em",null,"Versions")],-1)),n[2906]||(n[2906]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 27.11.2019 [skoiralal]: moved contents from prec, handling of frac_vegetation from s.cd")])],-1)),n[2907]||(n[2907]=l("p",null,[l("em",null,"Created by")],-1)),n[2908]||(n[2908]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1})]),_:1})]),n[4656]||(n[4656]=l("hr",null,null,-1)),n[4657]||(n[4657]=l("h3",{id:"percolation",tabindex:"-1"},[o("percolation "),l("a",{class:"header-anchor",href:"#percolation","aria-label":'Permalink to "percolation {#percolation}"'},"​")],-1)),l("details",it,[l("summary",null,[n[2910]||(n[2910]=l("a",{id:"Sindbad.Models.percolation",href:"#Sindbad.Models.percolation"},[l("span",{class:"jlbinding"},"Sindbad.Models.percolation")],-1)),n[2911]||(n[2911]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2912]||(n[2912]=u("",4))]),l("details",st,[n[2930]||(n[2930]=l("summary",null,"percolation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"percolation_WBP"},{default:i(()=>[l("details",ut,[l("summary",null,[n[2913]||(n[2913]=l("a",{id:"Sindbad.Models.percolation_WBP",href:"#Sindbad.Models.percolation_WBP"},[l("span",{class:"jlbinding"},"Sindbad.Models.percolation_WBP")],-1)),n[2914]||(n[2914]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2915]||(n[2915]=l("p",null,"Percolation as a difference of throughfall and surface runoff loss.",-1)),n[2916]||(n[2916]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2917]||(n[2917]=l("ul",null,[l("li",null,"None")],-1)),n[2918]||(n[2918]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2919]||(n[2919]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2920]||(n[2920]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.percolation"),o(": amount of moisture percolating to the top soil layer")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[2921]||(n[2921]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2922]||(n[2922]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"percolation_WBP.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2923]||(n[2923]=l("hr",null,null,-1)),n[2924]||(n[2924]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2925]||(n[2925]=l("p",null,[l("em",null,"References")],-1)),n[2926]||(n[2926]=l("p",null,[l("em",null,"Versions")],-1)),n[2927]||(n[2927]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[2928]||(n[2928]=l("p",null,[l("em",null,"Created by")],-1)),n[2929]||(n[2929]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4658]||(n[4658]=l("hr",null,null,-1)),n[4659]||(n[4659]=l("h3",{id:"plantForm",tabindex:"-1"},[o("plantForm "),l("a",{class:"header-anchor",href:"#plantForm","aria-label":'Permalink to "plantForm {#plantForm}"'},"​")],-1)),l("details",rt,[l("summary",null,[n[2931]||(n[2931]=l("a",{id:"Sindbad.Models.plantForm",href:"#Sindbad.Models.plantForm"},[l("span",{class:"jlbinding"},"Sindbad.Models.plantForm")],-1)),n[2932]||(n[2932]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2933]||(n[2933]=u("",4))]),l("details",at,[n[2970]||(n[2970]=l("summary",null,"plantForm approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"plantForm_PFT"},{default:i(()=>[l("details",dt,[l("summary",null,[n[2934]||(n[2934]=l("a",{id:"Sindbad.Models.plantForm_PFT",href:"#Sindbad.Models.plantForm_PFT"},[l("span",{class:"jlbinding"},"Sindbad.Models.plantForm_PFT")],-1)),n[2935]||(n[2935]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2936]||(n[2936]=l("p",null,"Differentiate plant form based on PFT.",-1)),n[2937]||(n[2937]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2938]||(n[2938]=l("ul",null,[l("li",null,"None")],-1)),n[2939]||(n[2939]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2940]||(n[2940]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[2941]||(n[2941]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"plantForm.plant_form_pft"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:plantForm, :plant_form_pft)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"plantForm.defined_forms_pft"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:plantForm, :defined_forms_pft)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[2942]||(n[2942]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[2943]||(n[2943]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_pft"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_pft)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"plantForm.plant_form_pft"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:plantForm, :plant_form_pft)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"plantForm.defined_forms_pft"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:plantForm, :defined_forms_pft)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.plant_form"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :plant_form)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2944]||(n[2944]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[2945]||(n[2945]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"plantForm_PFT.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2946]||(n[2946]=l("hr",null,null,-1)),n[2947]||(n[2947]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2948]||(n[2948]=l("p",null,[l("em",null,"References")],-1)),n[2949]||(n[2949]=l("p",null,[l("em",null,"Versions")],-1)),n[2950]||(n[2950]=l("ul",null,[l("li",null,"1.0 on 24.04.2025 [skoirala]")],-1)),n[2951]||(n[2951]=l("p",null,[l("em",null,"Created by")],-1)),n[2952]||(n[2952]=l("ul",null,[l("li",null,"skoirala")],-1))])]),_:1}),e(s,{label:"plantForm_fixed"},{default:i(()=>[l("details",pt,[l("summary",null,[n[2953]||(n[2953]=l("a",{id:"Sindbad.Models.plantForm_fixed",href:"#Sindbad.Models.plantForm_fixed"},[l("span",{class:"jlbinding"},"Sindbad.Models.plantForm_fixed")],-1)),n[2954]||(n[2954]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2955]||(n[2955]=l("p",null,"Sets plant form to a fixed form with 1: tree, 2: shrub, 3:herb. Assumes tree as default.",-1)),n[2956]||(n[2956]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2957]||(n[2957]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"plant_form_type"),o(": 1 ∈ [1, 2] => plant form type (units: "),l("code",null,"categorical"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2958]||(n[2958]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2959]||(n[2959]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[2960]||(n[2960]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.plant_form"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :plant_form)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2961]||(n[2961]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[2962]||(n[2962]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"plantForm_fixed.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2963]||(n[2963]=l("hr",null,null,-1)),n[2964]||(n[2964]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2965]||(n[2965]=l("p",null,[l("em",null,"References")],-1)),n[2966]||(n[2966]=l("p",null,[l("em",null,"Versions")],-1)),n[2967]||(n[2967]=l("ul",null,[l("li",null,"1.0 on 24.04.2025 [skoirala]")],-1)),n[2968]||(n[2968]=l("p",null,[l("em",null,"Created by")],-1)),n[2969]||(n[2969]=l("ul",null,[l("li",null,"skoirala")],-1))])]),_:1})]),_:1})]),n[4660]||(n[4660]=l("hr",null,null,-1)),n[4661]||(n[4661]=l("h3",{id:"rainIntensity",tabindex:"-1"},[o("rainIntensity "),l("a",{class:"header-anchor",href:"#rainIntensity","aria-label":'Permalink to "rainIntensity {#rainIntensity}"'},"​")],-1)),l("details",ft,[l("summary",null,[n[2971]||(n[2971]=l("a",{id:"Sindbad.Models.rainIntensity",href:"#Sindbad.Models.rainIntensity"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainIntensity")],-1)),n[2972]||(n[2972]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2973]||(n[2973]=u("",4))]),l("details",gt,[n[3008]||(n[3008]=l("summary",null,"rainIntensity approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"rainIntensity_forcing"},{default:i(()=>[l("details",mt,[l("summary",null,[n[2974]||(n[2974]=l("a",{id:"Sindbad.Models.rainIntensity_forcing",href:"#Sindbad.Models.rainIntensity_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainIntensity_forcing")],-1)),n[2975]||(n[2975]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2976]||(n[2976]=l("p",null,"Gets rainfall intensity from forcing data.",-1)),n[2977]||(n[2977]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2978]||(n[2978]=l("ul",null,[l("li",null,"None")],-1)),n[2979]||(n[2979]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2980]||(n[2980]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2981]||(n[2981]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_rain_int"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain_int)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.rain_int"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :rain_int)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2982]||(n[2982]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[2983]||(n[2983]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rainIntensity_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[2984]||(n[2984]=l("hr",null,null,-1)),n[2985]||(n[2985]=l("p",null,[l("strong",null,"Extended help")],-1)),n[2986]||(n[2986]=l("p",null,[l("em",null,"References")],-1)),n[2987]||(n[2987]=l("p",null,[l("em",null,"Versions")],-1)),n[2988]||(n[2988]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: creation of approach")],-1)),n[2989]||(n[2989]=l("p",null,[l("em",null,"Created by")],-1)),n[2990]||(n[2990]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"rainIntensity_simple"},{default:i(()=>[l("details",bt,[l("summary",null,[n[2991]||(n[2991]=l("a",{id:"Sindbad.Models.rainIntensity_simple",href:"#Sindbad.Models.rainIntensity_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainIntensity_simple")],-1)),n[2992]||(n[2992]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[2993]||(n[2993]=l("p",null,"Rainfall intensity as a linear function of rainfall amount.",-1)),n[2994]||(n[2994]=l("p",null,[l("strong",null,"Parameters")],-1)),n[2995]||(n[2995]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"rain_init_factor"),o(": 0.04167 ∈ [0.0, 1.0] => factor to convert daily rainfall to rainfall intensity ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[2996]||(n[2996]=l("p",null,[l("strong",null,"Methods:")],-1)),n[2997]||(n[2997]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[2998]||(n[2998]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_rain"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.rain_int"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :rain_int)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[2999]||(n[2999]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3e3]||(n[3e3]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rainIntensity_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3001]||(n[3001]=l("hr",null,null,-1)),n[3002]||(n[3002]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3003]||(n[3003]=l("p",null,[l("em",null,"References")],-1)),n[3004]||(n[3004]=l("p",null,[l("em",null,"Versions")],-1)),n[3005]||(n[3005]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: creation of approach")],-1)),n[3006]||(n[3006]=l("p",null,[l("em",null,"Created by")],-1)),n[3007]||(n[3007]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4662]||(n[4662]=l("hr",null,null,-1)),n[4663]||(n[4663]=l("h3",{id:"rainSnow",tabindex:"-1"},[o("rainSnow "),l("a",{class:"header-anchor",href:"#rainSnow","aria-label":'Permalink to "rainSnow {#rainSnow}"'},"​")],-1)),l("details",yt,[l("summary",null,[n[3009]||(n[3009]=l("a",{id:"Sindbad.Models.rainSnow",href:"#Sindbad.Models.rainSnow"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainSnow")],-1)),n[3010]||(n[3010]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3011]||(n[3011]=u("",4))]),l("details",ct,[n[3065]||(n[3065]=l("summary",null,"rainSnow approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"rainSnow_Tair"},{default:i(()=>[l("details",vt,[l("summary",null,[n[3012]||(n[3012]=l("a",{id:"Sindbad.Models.rainSnow_Tair",href:"#Sindbad.Models.rainSnow_Tair"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainSnow_Tair")],-1)),n[3013]||(n[3013]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3014]||(n[3014]=l("p",null,"Rain and snow partitioning based on a temperature threshold.",-1)),n[3015]||(n[3015]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3016]||(n[3016]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"airT_thres"),o(": 0.0 ∈ [-5.0, 5.0] => threshold for separating rain and snow (units: "),l("code",null,"°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3017]||(n[3017]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3018]||(n[3018]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3019]||(n[3019]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rain"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.precip"),o(": total land precipitation including snow and rain")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.snow"),o(": amount of precipitation in solid form")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])])],-1)),n[3020]||(n[3020]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3021]||(n[3021]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rainSnow_Tair.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3022]||(n[3022]=l("hr",null,null,-1)),n[3023]||(n[3023]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3024]||(n[3024]=l("p",null,[l("em",null,"References")],-1)),n[3025]||(n[3025]=l("p",null,[l("em",null,"Versions")],-1)),n[3026]||(n[3026]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: creation of approach")],-1)),n[3027]||(n[3027]=l("p",null,[l("em",null,"Created by")],-1)),n[3028]||(n[3028]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"rainSnow_forcing"},{default:i(()=>[l("details",kt,[l("summary",null,[n[3029]||(n[3029]=l("a",{id:"Sindbad.Models.rainSnow_forcing",href:"#Sindbad.Models.rainSnow_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainSnow_forcing")],-1)),n[3030]||(n[3030]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3031]||(n[3031]=l("p",null,"Sets rainfall and snowfall from forcing data, with snowfall scaled if the snowfall_scalar parameter is optimized.",-1)),n[3032]||(n[3032]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3033]||(n[3033]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"snowfall_scalar"),o(": 1.0 ∈ [0.0, 3.0] => scaling factor for snow fall ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3034]||(n[3034]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3035]||(n[3035]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3036]||(n[3036]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rain"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_snow"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_snow)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.precip"),o(": total land precipitation including snow and rain")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.snow"),o(": amount of precipitation in solid form")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])])],-1)),n[3037]||(n[3037]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3038]||(n[3038]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rainSnow_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3039]||(n[3039]=l("hr",null,null,-1)),n[3040]||(n[3040]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3041]||(n[3041]=l("p",null,[l("em",null,"References")],-1)),n[3042]||(n[3042]=l("p",null,[l("em",null,"Versions")],-1)),n[3043]||(n[3043]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: creation of approach")],-1)),n[3044]||(n[3044]=l("p",null,[l("em",null,"Created by")],-1)),n[3045]||(n[3045]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"rainSnow_rain"},{default:i(()=>[l("details",St,[l("summary",null,[n[3046]||(n[3046]=l("a",{id:"Sindbad.Models.rainSnow_rain",href:"#Sindbad.Models.rainSnow_rain"},[l("span",{class:"jlbinding"},"Sindbad.Models.rainSnow_rain")],-1)),n[3047]||(n[3047]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3048]||(n[3048]=l("p",null,"All precipitation is assumed to be liquid rain with 0 snowfall.",-1)),n[3049]||(n[3049]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3050]||(n[3050]=l("ul",null,[l("li",null,"None")],-1)),n[3051]||(n[3051]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3052]||(n[3052]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3053]||(n[3053]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_rain"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.precip"),o(": total land precipitation including snow and rain")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.snow"),o(": amount of precipitation in solid form")])])])])],-1)),n[3054]||(n[3054]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3055]||(n[3055]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_rain"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rain)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.precip"),o(": total land precipitation including snow and rain")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])])])])],-1)),n[3056]||(n[3056]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3057]||(n[3057]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rainSnow_rain.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3058]||(n[3058]=l("hr",null,null,-1)),n[3059]||(n[3059]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3060]||(n[3060]=l("p",null,[l("em",null,"References")],-1)),n[3061]||(n[3061]=l("p",null,[l("em",null,"Versions")],-1)),n[3062]||(n[3062]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: creation of approach")],-1)),n[3063]||(n[3063]=l("p",null,[l("em",null,"Created by")],-1)),n[3064]||(n[3064]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4664]||(n[4664]=l("hr",null,null,-1)),n[4665]||(n[4665]=l("h3",{id:"rootMaximumDepth",tabindex:"-1"},[o("rootMaximumDepth "),l("a",{class:"header-anchor",href:"#rootMaximumDepth","aria-label":'Permalink to "rootMaximumDepth {#rootMaximumDepth}"'},"​")],-1)),l("details",wt,[l("summary",null,[n[3066]||(n[3066]=l("a",{id:"Sindbad.Models.rootMaximumDepth",href:"#Sindbad.Models.rootMaximumDepth"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootMaximumDepth")],-1)),n[3067]||(n[3067]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3068]||(n[3068]=u("",4))]),l("details",Tt,[n[3088]||(n[3088]=l("summary",null,"rootMaximumDepth approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"rootMaximumDepth_fracSoilD"},{default:i(()=>[l("details",jt,[l("summary",null,[n[3069]||(n[3069]=l("a",{id:"Sindbad.Models.rootMaximumDepth_fracSoilD",href:"#Sindbad.Models.rootMaximumDepth_fracSoilD"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootMaximumDepth_fracSoilD")],-1)),n[3070]||(n[3070]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3071]||(n[3071]=l("p",null,"Maximum rooting depth as a fraction of total soil depth.",-1)),n[3072]||(n[3072]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3073]||(n[3073]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_frac_max_root_depth"),o(": 0.5 ∈ [0.1, 0.8] => root depth as a fraction of soil depth ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3074]||(n[3074]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3075]||(n[3075]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3076]||(n[3076]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"properties.∑soil_depth"),o(": total depth of soil")])])])],-1)),n[3077]||(n[3077]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3078]||(n[3078]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"properties.∑soil_depth"),o(": total depth of soil")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.max_root_depth"),o(": maximum depth of root")])])])],-1)),n[3079]||(n[3079]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3080]||(n[3080]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootMaximumDepth_fracSoilD.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3081]||(n[3081]=l("hr",null,null,-1)),n[3082]||(n[3082]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3083]||(n[3083]=l("p",null,[l("em",null,"References")],-1)),n[3084]||(n[3084]=l("p",null,[l("em",null,"Versions")],-1)),n[3085]||(n[3085]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[3086]||(n[3086]=l("p",null,[l("em",null,"Created by")],-1)),n[3087]||(n[3087]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4666]||(n[4666]=l("hr",null,null,-1)),n[4667]||(n[4667]=l("h3",{id:"rootWaterEfficiency",tabindex:"-1"},[o("rootWaterEfficiency "),l("a",{class:"header-anchor",href:"#rootWaterEfficiency","aria-label":'Permalink to "rootWaterEfficiency {#rootWaterEfficiency}"'},"​")],-1)),l("details",Et,[l("summary",null,[n[3089]||(n[3089]=l("a",{id:"Sindbad.Models.rootWaterEfficiency",href:"#Sindbad.Models.rootWaterEfficiency"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency")],-1)),n[3090]||(n[3090]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3091]||(n[3091]=u("",4))]),l("details",xt,[n[3189]||(n[3189]=l("summary",null,"rootWaterEfficiency approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"rootWaterEfficiency_constant"},{default:i(()=>[l("details",Ct,[l("summary",null,[n[3092]||(n[3092]=l("a",{id:"Sindbad.Models.rootWaterEfficiency_constant",href:"#Sindbad.Models.rootWaterEfficiency_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency_constant")],-1)),n[3093]||(n[3093]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3094]||(n[3094]=l("p",null,"Water uptake efficiency by roots set as a constant for each soil layer.",-1)),n[3095]||(n[3095]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3096]||(n[3096]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_root_water_efficiency"),o(": 0.99 ∈ [0.001, 0.999] => root fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3097]||(n[3097]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3098]||(n[3098]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3099]||(n[3099]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.cumulative_soil_depths"),o(": the depth to the bottom of each soil layer")])])])])],-1)),n[3100]||(n[3100]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3101]||(n[3101]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.cumulative_soil_depths"),o(": the depth to the bottom of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.max_root_depth"),o(": maximum depth of root")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3102]||(n[3102]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3103]||(n[3103]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterEfficiency_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3104]||(n[3104]=l("hr",null,null,-1)),n[3105]||(n[3105]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3106]||(n[3106]=l("p",null,[l("em",null,"References")],-1)),n[3107]||(n[3107]=l("p",null,[l("em",null,"Versions")],-1)),n[3108]||(n[3108]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[3109]||(n[3109]=l("p",null,[l("em",null,"Created by")],-1)),n[3110]||(n[3110]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"rootWaterEfficiency_expCvegRoot"},{default:i(()=>[l("details",Mt,[l("summary",null,[n[3111]||(n[3111]=l("a",{id:"Sindbad.Models.rootWaterEfficiency_expCvegRoot",href:"#Sindbad.Models.rootWaterEfficiency_expCvegRoot"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency_expCvegRoot")],-1)),n[3112]||(n[3112]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3113]||(n[3113]=l("p",null,"Water uptake efficiency by roots set according to total root carbon.",-1)),n[3114]||(n[3114]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3115]||(n[3115]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"k_efficiency_cVegRoot"),o(": 0.02 ∈ [0.001, 0.3] => rate constant of exponential relationship (units: "),l("code",null,"m2/gC"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"max_root_water_efficiency"),o(": 0.95 ∈ [0.7, 0.98] => maximum root water uptake capacity ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"min_root_water_efficiency"),o(": 0.1 ∈ [0.05, 0.3] => minimum root water uptake threshold ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3116]||(n[3116]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3117]||(n[3117]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3118]||(n[3118]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"rootWaterEfficiency.root_over"),o(": a boolean indicating if the root is allowed to exract water from a given layer depending on maximum rooting depth")])]),l("li",null,[l("p",null,[l("code",null,"properties.cumulative_soil_depths"),o(": the depth to the bottom of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])])],-1)),n[3119]||(n[3119]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3120]||(n[3120]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"rootWaterEfficiency.root_over"),o(": a boolean indicating if the root is allowed to exract water from a given layer depending on maximum rooting depth")])]),l("li",null,[l("p",null,[l("code",null,"properties.cumulative_soil_depths"),o(": the depth to the bottom of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.max_root_depth"),o(": maximum depth of root")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"rootWaterEfficiency.root_over"),o(": a boolean indicating if the root is allowed to exract water from a given layer depending on maximum rooting depth")])])])],-1)),n[3121]||(n[3121]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3122]||(n[3122]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"rootWaterEfficiency.root_over"),o(": a boolean indicating if the root is allowed to exract water from a given layer depending on maximum rooting depth")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.cVegRoot"),o(": carbon content of cVegRoot pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3123]||(n[3123]=l("p",null,[l("code",null,"update"),o(" methods are not defined")],-1)),n[3124]||(n[3124]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterEfficiency_expCvegRoot.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3125]||(n[3125]=l("hr",null,null,-1)),n[3126]||(n[3126]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3127]||(n[3127]=l("p",null,[l("em",null,"References")],-1)),n[3128]||(n[3128]=l("p",null,[l("em",null,"Versions")],-1)),n[3129]||(n[3129]=l("ul",null,[l("li",null,"1.0 on 28.04.2020")],-1)),n[3130]||(n[3130]=l("p",null,[l("em",null,"Created by")],-1)),n[3131]||(n[3131]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"rootWaterEfficiency_k2Layer"},{default:i(()=>[l("details",It,[l("summary",null,[n[3132]||(n[3132]=l("a",{id:"Sindbad.Models.rootWaterEfficiency_k2Layer",href:"#Sindbad.Models.rootWaterEfficiency_k2Layer"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency_k2Layer")],-1)),n[3133]||(n[3133]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3134]||(n[3134]=l("p",null,"Water uptake efficiency by roots set as a calibration parameter for each soil layer (for two soil layers).",-1)),n[3135]||(n[3135]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3136]||(n[3136]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"k2"),o(": 0.02 ∈ [0.001, 0.2] => fraction of 2nd soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k1"),o(": 0.5 ∈ [0.01, 0.99] => fraction of 1st soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3137]||(n[3137]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3138]||(n[3138]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3139]||(n[3139]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3140]||(n[3140]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3141]||(n[3141]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3142]||(n[3142]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3143]||(n[3143]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterEfficiency_k2Layer.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3144]||(n[3144]=l("hr",null,null,-1)),n[3145]||(n[3145]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3146]||(n[3146]=l("p",null,[l("em",null,"References")],-1)),n[3147]||(n[3147]=l("p",null,[l("em",null,"Versions")],-1)),n[3148]||(n[3148]=l("ul",null,[l("li",null,"1.0 on 09.01.2020")],-1)),n[3149]||(n[3149]=l("p",null,[l("em",null,"Created by")],-1)),n[3150]||(n[3150]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"rootWaterEfficiency_k2fRD"},{default:i(()=>[l("details",At,[l("summary",null,[n[3151]||(n[3151]=l("a",{id:"Sindbad.Models.rootWaterEfficiency_k2fRD",href:"#Sindbad.Models.rootWaterEfficiency_k2fRD"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency_k2fRD")],-1)),n[3152]||(n[3152]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3153]||(n[3153]=l("p",null,"Water uptake efficiency by roots set as a function of vegetation fraction, and for the second soil layer, as a function of rooting depth from different datasets.",-1)),n[3154]||(n[3154]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3155]||(n[3155]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"k2_scale"),o(": 0.02 ∈ [0.001, 0.2] => scales vegFrac to define fraction of 2nd soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k1_scale"),o(": 0.5 ∈ [0.01, 0.99] => scales vegFrac to fraction of 1st soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3156]||(n[3156]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3157]||(n[3157]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3158]||(n[3158]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3159]||(n[3159]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3160]||(n[3160]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3161]||(n[3161]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3162]||(n[3162]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterEfficiency_k2fRD.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3163]||(n[3163]=l("hr",null,null,-1)),n[3164]||(n[3164]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3165]||(n[3165]=l("p",null,[l("em",null,"References")],-1)),n[3166]||(n[3166]=l("p",null,[l("em",null,"Versions")],-1)),n[3167]||(n[3167]=l("ul",null,[l("li",null,"1.0 on 10.02.2020")],-1)),n[3168]||(n[3168]=l("p",null,[l("em",null,"Created by")],-1)),n[3169]||(n[3169]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"rootWaterEfficiency_k2fvegFraction"},{default:i(()=>[l("details",Pt,[l("summary",null,[n[3170]||(n[3170]=l("a",{id:"Sindbad.Models.rootWaterEfficiency_k2fvegFraction",href:"#Sindbad.Models.rootWaterEfficiency_k2fvegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterEfficiency_k2fvegFraction")],-1)),n[3171]||(n[3171]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3172]||(n[3172]=l("p",null,"Water uptake efficiency by roots set as a function of vegetation fraction, and for the second soil layer, as a function of rooting depth from different datasets, which is further scaled by the vegetation fraction.",-1)),n[3173]||(n[3173]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3174]||(n[3174]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"k2_scale"),o(": 0.02 ∈ [0.001, 10.0] => scales vegFrac to define fraction of 2nd soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"k1_scale"),o(": 0.5 ∈ [0.001, 10.0] => scales vegFrac to fraction of 1st soil layer available for transpiration ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3175]||(n[3175]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3176]||(n[3176]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3177]||(n[3177]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3178]||(n[3178]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3179]||(n[3179]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])])])],-1)),n[3180]||(n[3180]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3181]||(n[3181]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterEfficiency_k2fvegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3182]||(n[3182]=l("hr",null,null,-1)),n[3183]||(n[3183]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3184]||(n[3184]=l("p",null,[l("em",null,"References")],-1)),n[3185]||(n[3185]=l("p",null,[l("em",null,"Versions")],-1)),n[3186]||(n[3186]=l("ul",null,[l("li",null,"1.0 on 10.02.2020")],-1)),n[3187]||(n[3187]=l("p",null,[l("em",null,"Created by")],-1)),n[3188]||(n[3188]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1})]),_:1})]),n[4668]||(n[4668]=l("hr",null,null,-1)),n[4669]||(n[4669]=l("h3",{id:"rootWaterUptake",tabindex:"-1"},[o("rootWaterUptake "),l("a",{class:"header-anchor",href:"#rootWaterUptake","aria-label":'Permalink to "rootWaterUptake {#rootWaterUptake}"'},"​")],-1)),l("details",Rt,[l("summary",null,[n[3190]||(n[3190]=l("a",{id:"Sindbad.Models.rootWaterUptake",href:"#Sindbad.Models.rootWaterUptake"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterUptake")],-1)),n[3191]||(n[3191]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3192]||(n[3192]=u("",4))]),l("details",Vt,[n[3235]||(n[3235]=l("summary",null,"rootWaterUptake approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"rootWaterUptake_proportion"},{default:i(()=>[l("details",Wt,[l("summary",null,[n[3193]||(n[3193]=l("a",{id:"Sindbad.Models.rootWaterUptake_proportion",href:"#Sindbad.Models.rootWaterUptake_proportion"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterUptake_proportion")],-1)),n[3194]||(n[3194]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3195]||(n[3195]=l("p",null,"Root uptake from each soil layer proportional to the relative plant water availability in the layer.",-1)),n[3196]||(n[3196]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3197]||(n[3197]=l("ul",null,[l("li",null,"None")],-1)),n[3198]||(n[3198]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3199]||(n[3199]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3200]||(n[3200]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.root_water_uptake"),o(": amount of water uptaken for transpiration per soil layer")])])])],-1)),n[3201]||(n[3201]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3202]||(n[3202]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.root_water_uptake"),o(": amount of water uptaken for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.root_water_uptake"),o(": amount of water uptaken for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[3203]||(n[3203]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3204]||(n[3204]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterUptake_proportion.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3205]||(n[3205]=l("hr",null,null,-1)),n[3206]||(n[3206]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3207]||(n[3207]=l("p",null,[l("em",null,"References")],-1)),n[3208]||(n[3208]=l("p",null,[l("em",null,"Versions")],-1)),n[3209]||(n[3209]=l("ul",null,[l("li",null,"1.0 on 13.03.2020 [ttraut]")],-1)),n[3210]||(n[3210]=l("p",null,[l("em",null,"Created by")],-1)),n[3211]||(n[3211]=l("ul",null,[l("li",null,"ttraut")],-1)),n[3212]||(n[3212]=l("p",null,[l("em",null,"Notes")],-1)),n[3213]||(n[3213]=l("ul",null,[l("li",null,"assumes that the uptake from each layer remains proportional to the root fraction")],-1))])]),_:1}),e(s,{label:"rootWaterUptake_topBottom"},{default:i(()=>[l("details",Dt,[l("summary",null,[n[3214]||(n[3214]=l("a",{id:"Sindbad.Models.rootWaterUptake_topBottom",href:"#Sindbad.Models.rootWaterUptake_topBottom"},[l("span",{class:"jlbinding"},"Sindbad.Models.rootWaterUptake_topBottom")],-1)),n[3215]||(n[3215]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3216]||(n[3216]=l("p",null,"Root uptake from each soil layer from top to bottom, using maximul available water in each layer.",-1)),n[3217]||(n[3217]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3218]||(n[3218]=l("ul",null,[l("li",null,"None")],-1)),n[3219]||(n[3219]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3220]||(n[3220]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3221]||(n[3221]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.root_water_uptake"),o(": amount of water uptaken for transpiration per soil layer")])])])],-1)),n[3222]||(n[3222]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3223]||(n[3223]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.ΔsoilW"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :ΔsoilW)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.root_water_uptake"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :root_water_uptake)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.root_water_uptake"),o(": amount of water uptaken for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])])],-1)),n[3224]||(n[3224]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3225]||(n[3225]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"rootWaterUptake_topBottom.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3226]||(n[3226]=l("hr",null,null,-1)),n[3227]||(n[3227]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3228]||(n[3228]=l("p",null,[l("em",null,"References")],-1)),n[3229]||(n[3229]=l("p",null,[l("em",null,"Versions")],-1)),n[3230]||(n[3230]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[3231]||(n[3231]=l("p",null,[l("em",null,"Created by")],-1)),n[3232]||(n[3232]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[3233]||(n[3233]=l("p",null,[l("em",null,"Notes")],-1)),n[3234]||(n[3234]=l("ul",null,[l("li",null,"assumes that the uptake is prioritized from top to bottom; irrespective of root fraction of the layers")],-1))])]),_:1})]),_:1})]),n[4670]||(n[4670]=l("hr",null,null,-1)),n[4671]||(n[4671]=l("h3",{id:"runoff",tabindex:"-1"},[o("runoff "),l("a",{class:"header-anchor",href:"#runoff","aria-label":'Permalink to "runoff {#runoff}"'},"​")],-1)),l("details",Ft,[l("summary",null,[n[3236]||(n[3236]=l("a",{id:"Sindbad.Models.runoff",href:"#Sindbad.Models.runoff"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoff")],-1)),n[3237]||(n[3237]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3238]||(n[3238]=u("",4))]),l("details",Nt,[n[3258]||(n[3258]=l("summary",null,"runoff approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoff_sum"},{default:i(()=>[l("details",Ot,[l("summary",null,[n[3239]||(n[3239]=l("a",{id:"Sindbad.Models.runoff_sum",href:"#Sindbad.Models.runoff_sum"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoff_sum")],-1)),n[3240]||(n[3240]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3241]||(n[3241]=l("p",null,"Runoff as a sum of all potential components.",-1)),n[3242]||(n[3242]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3243]||(n[3243]=l("ul",null,[l("li",null,"None")],-1)),n[3244]||(n[3244]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3245]||(n[3245]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3246]||(n[3246]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.runoff"),o(": total runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.base_runoff"),o(": base runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])])])])],-1)),n[3247]||(n[3247]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3248]||(n[3248]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.base_runoff"),o(": base runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.runoff"),o(": total runoff")])])])],-1)),n[3249]||(n[3249]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3250]||(n[3250]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoff_sum.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3251]||(n[3251]=l("hr",null,null,-1)),n[3252]||(n[3252]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3253]||(n[3253]=l("p",null,[l("em",null,"References")],-1)),n[3254]||(n[3254]=l("p",null,[l("em",null,"Versions")],-1)),n[3255]||(n[3255]=l("ul",null,[l("li",null,"1.0 on 01.04.2022")],-1)),n[3256]||(n[3256]=l("p",null,[l("em",null,"Created by")],-1)),n[3257]||(n[3257]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4672]||(n[4672]=l("hr",null,null,-1)),n[4673]||(n[4673]=l("h3",{id:"runoffBase",tabindex:"-1"},[o("runoffBase "),l("a",{class:"header-anchor",href:"#runoffBase","aria-label":'Permalink to "runoffBase {#runoffBase}"'},"​")],-1)),l("details",Bt,[l("summary",null,[n[3259]||(n[3259]=l("a",{id:"Sindbad.Models.runoffBase",href:"#Sindbad.Models.runoffBase"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffBase")],-1)),n[3260]||(n[3260]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3261]||(n[3261]=u("",4))]),l("details",Gt,[n[3292]||(n[3292]=l("summary",null,"runoffBase approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffBase_Zhang2008"},{default:i(()=>[l("details",Lt,[l("summary",null,[n[3262]||(n[3262]=l("a",{id:"Sindbad.Models.runoffBase_Zhang2008",href:"#Sindbad.Models.runoffBase_Zhang2008"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffBase_Zhang2008")],-1)),n[3263]||(n[3263]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3264]||(n[3264]=l("p",null,"Baseflow from a linear groundwater storage following Zhang (2008).",-1)),n[3265]||(n[3265]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3266]||(n[3266]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_baseflow"),o(": 0.001 ∈ [1.0e-5, 0.02] => base flow coefficient (units: "),l("code",null,"day-1"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])],-1)),n[3267]||(n[3267]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3268]||(n[3268]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3269]||(n[3269]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.base_runoff"),o(": base runoff")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])])])])],-1)),n[3270]||(n[3270]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3271]||(n[3271]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffBase_Zhang2008.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3272]||(n[3272]=l("hr",null,null,-1)),n[3273]||(n[3273]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3274]||(n[3274]=l("p",null,[l("em",null,"References")],-1)),n[3275]||(n[3275]=l("ul",null,[l("li",null,"Zhang, Y. Q., Chiew, F. H. S., Zhang, L., Leuning, R., & Cleugh, H. A. (2008). Estimating catchment evaporation and runoff using MODIS leaf area index & the Penman‐Monteith equation. Water Resources Research, 44[10].")],-1)),n[3276]||(n[3276]=l("p",null,[l("em",null,"Versions")],-1)),n[3277]||(n[3277]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3278]||(n[3278]=l("p",null,[l("em",null,"Created by")],-1)),n[3279]||(n[3279]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"runoffBase_none"},{default:i(()=>[l("details",zt,[l("summary",null,[n[3280]||(n[3280]=l("a",{id:"Sindbad.Models.runoffBase_none",href:"#Sindbad.Models.runoffBase_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffBase_none")],-1)),n[3281]||(n[3281]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3282]||(n[3282]=l("p",null,"Sets base runoff to 0.",-1)),n[3283]||(n[3283]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3284]||(n[3284]=l("ul",null,[l("li",null,"None")],-1)),n[3285]||(n[3285]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3286]||(n[3286]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3287]||(n[3287]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.base_runoff"),o(": base runoff")])])])],-1)),n[3288]||(n[3288]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3289]||(n[3289]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffBase_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3290]||(n[3290]=l("hr",null,null,-1)),n[3291]||(n[3291]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4674]||(n[4674]=l("hr",null,null,-1)),n[4675]||(n[4675]=l("h3",{id:"runoffInfiltrationExcess",tabindex:"-1"},[o("runoffInfiltrationExcess "),l("a",{class:"header-anchor",href:"#runoffInfiltrationExcess","aria-label":'Permalink to "runoffInfiltrationExcess {#runoffInfiltrationExcess}"'},"​")],-1)),l("details",Ut,[l("summary",null,[n[3293]||(n[3293]=l("a",{id:"Sindbad.Models.runoffInfiltrationExcess",href:"#Sindbad.Models.runoffInfiltrationExcess"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInfiltrationExcess")],-1)),n[3294]||(n[3294]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3295]||(n[3295]=u("",4))]),l("details",Jt,[n[3342]||(n[3342]=l("summary",null,"runoffInfiltrationExcess approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffInfiltrationExcess_Jung"},{default:i(()=>[l("details",Kt,[l("summary",null,[n[3296]||(n[3296]=l("a",{id:"Sindbad.Models.runoffInfiltrationExcess_Jung",href:"#Sindbad.Models.runoffInfiltrationExcess_Jung"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInfiltrationExcess_Jung")],-1)),n[3297]||(n[3297]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3298]||(n[3298]=l("p",null,"Infiltration excess runoff as a function of rain intensity and vegetated fraction.",-1)),n[3299]||(n[3299]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3300]||(n[3300]=l("ul",null,[l("li",null,"None")],-1)),n[3301]||(n[3301]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3302]||(n[3302]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3303]||(n[3303]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"states.rainInt"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :rainInt)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.inf_excess_runoff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :inf_excess_runoff)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3304]||(n[3304]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3305]||(n[3305]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffInfiltrationExcess_Jung.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3306]||(n[3306]=l("hr",null,null,-1)),n[3307]||(n[3307]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3308]||(n[3308]=l("p",null,[l("em",null,"References")],-1)),n[3309]||(n[3309]=l("p",null,[l("em",null,"Versions")],-1)),n[3310]||(n[3310]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 22.11.2019 [skoirala | @dr-ko]: moved from prec to dyna to handle land.states.fAPAR which is nPix, 1")])],-1)),n[3311]||(n[3311]=l("p",null,[l("em",null,"Created by")],-1)),n[3312]||(n[3312]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"runoffInfiltrationExcess_kUnsat"},{default:i(()=>[l("details",Ht,[l("summary",null,[n[3313]||(n[3313]=l("a",{id:"Sindbad.Models.runoffInfiltrationExcess_kUnsat",href:"#Sindbad.Models.runoffInfiltrationExcess_kUnsat"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInfiltrationExcess_kUnsat")],-1)),n[3314]||(n[3314]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3315]||(n[3315]=l("p",null,"Infiltration excess runoff based on unsaturated hydraulic conductivity.",-1)),n[3316]||(n[3316]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3317]||(n[3317]=l("ul",null,[l("li",null,"None")],-1)),n[3318]||(n[3318]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3319]||(n[3319]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3320]||(n[3320]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.inf_excess_runoff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :inf_excess_runoff)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3321]||(n[3321]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3322]||(n[3322]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffInfiltrationExcess_kUnsat.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3323]||(n[3323]=l("hr",null,null,-1)),n[3324]||(n[3324]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3325]||(n[3325]=l("p",null,[l("em",null,"References")],-1)),n[3326]||(n[3326]=l("p",null,[l("em",null,"Versions")],-1)),n[3327]||(n[3327]=l("ul",null,[l("li",null,"1.0 on 23.11.2019 [skoirala | @dr-ko]")],-1)),n[3328]||(n[3328]=l("p",null,[l("em",null,"Created by")],-1)),n[3329]||(n[3329]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffInfiltrationExcess_none"},{default:i(()=>[l("details",qt,[l("summary",null,[n[3330]||(n[3330]=l("a",{id:"Sindbad.Models.runoffInfiltrationExcess_none",href:"#Sindbad.Models.runoffInfiltrationExcess_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInfiltrationExcess_none")],-1)),n[3331]||(n[3331]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3332]||(n[3332]=l("p",null,"Sets infiltration excess runoff to 0.",-1)),n[3333]||(n[3333]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3334]||(n[3334]=l("ul",null,[l("li",null,"None")],-1)),n[3335]||(n[3335]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3336]||(n[3336]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3337]||(n[3337]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.inf_excess_runoff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :inf_excess_runoff)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[3338]||(n[3338]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3339]||(n[3339]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffInfiltrationExcess_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3340]||(n[3340]=l("hr",null,null,-1)),n[3341]||(n[3341]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4676]||(n[4676]=l("hr",null,null,-1)),n[4677]||(n[4677]=l("h3",{id:"runoffInterflow",tabindex:"-1"},[o("runoffInterflow "),l("a",{class:"header-anchor",href:"#runoffInterflow","aria-label":'Permalink to "runoffInterflow {#runoffInterflow}"'},"​")],-1)),l("details",Zt,[l("summary",null,[n[3343]||(n[3343]=l("a",{id:"Sindbad.Models.runoffInterflow",href:"#Sindbad.Models.runoffInterflow"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInterflow")],-1)),n[3344]||(n[3344]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3345]||(n[3345]=u("",4))]),l("details",Qt,[n[3375]||(n[3375]=l("summary",null,"runoffInterflow approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffInterflow_none"},{default:i(()=>[l("details",Yt,[l("summary",null,[n[3346]||(n[3346]=l("a",{id:"Sindbad.Models.runoffInterflow_none",href:"#Sindbad.Models.runoffInterflow_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInterflow_none")],-1)),n[3347]||(n[3347]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3348]||(n[3348]=l("p",null,"Sets interflow runoff to 0.",-1)),n[3349]||(n[3349]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3350]||(n[3350]=l("ul",null,[l("li",null,"None")],-1)),n[3351]||(n[3351]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3352]||(n[3352]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3353]||(n[3353]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.interflow_runoff"),o(": runoff loss from interflow in soil layers")])])])],-1)),n[3354]||(n[3354]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3355]||(n[3355]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffInterflow_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3356]||(n[3356]=l("hr",null,null,-1)),n[3357]||(n[3357]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1}),e(s,{label:"runoffInterflow_residual"},{default:i(()=>[l("details",Xt,[l("summary",null,[n[3358]||(n[3358]=l("a",{id:"Sindbad.Models.runoffInterflow_residual",href:"#Sindbad.Models.runoffInterflow_residual"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffInterflow_residual")],-1)),n[3359]||(n[3359]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3360]||(n[3360]=l("p",null,"Interflow as a fraction of the available water balance pool.",-1)),n[3361]||(n[3361]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3362]||(n[3362]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"rc"),o(": 0.3 ∈ [0.0, 0.9] => fraction of the available water that flows out as interflow ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3363]||(n[3363]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3364]||(n[3364]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3365]||(n[3365]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.interflow_runoff"),o(": runoff loss from interflow in soil layers")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3366]||(n[3366]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3367]||(n[3367]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffInterflow_residual.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3368]||(n[3368]=l("hr",null,null,-1)),n[3369]||(n[3369]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3370]||(n[3370]=l("p",null,[l("em",null,"References")],-1)),n[3371]||(n[3371]=l("p",null,[l("em",null,"Versions")],-1)),n[3372]||(n[3372]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3373]||(n[3373]=l("p",null,[l("em",null,"Created by")],-1)),n[3374]||(n[3374]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1})]),_:1})]),n[4678]||(n[4678]=l("hr",null,null,-1)),n[4679]||(n[4679]=l("h3",{id:"runoffOverland",tabindex:"-1"},[o("runoffOverland "),l("a",{class:"header-anchor",href:"#runoffOverland","aria-label":'Permalink to "runoffOverland {#runoffOverland}"'},"​")],-1)),l("details",$t,[l("summary",null,[n[3376]||(n[3376]=l("a",{id:"Sindbad.Models.runoffOverland",href:"#Sindbad.Models.runoffOverland"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffOverland")],-1)),n[3377]||(n[3377]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3378]||(n[3378]=u("",4))]),l("details",ht,[n[3442]||(n[3442]=l("summary",null,"runoffOverland approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffOverland_Inf"},{default:i(()=>[l("details",_t,[l("summary",null,[n[3379]||(n[3379]=l("a",{id:"Sindbad.Models.runoffOverland_Inf",href:"#Sindbad.Models.runoffOverland_Inf"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffOverland_Inf")],-1)),n[3380]||(n[3380]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3381]||(n[3381]=l("p",null,"Overland flow due to infiltration excess runoff.",-1)),n[3382]||(n[3382]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3383]||(n[3383]=l("ul",null,[l("li",null,"None")],-1)),n[3384]||(n[3384]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3385]||(n[3385]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3386]||(n[3386]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.inf_excess_runoff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :inf_excess_runoff)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])],-1)),n[3387]||(n[3387]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3388]||(n[3388]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffOverland_Inf.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3389]||(n[3389]=l("hr",null,null,-1)),n[3390]||(n[3390]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3391]||(n[3391]=l("p",null,[l("em",null,"References")],-1)),n[3392]||(n[3392]=l("p",null,[l("em",null,"Versions")],-1)),n[3393]||(n[3393]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[3394]||(n[3394]=l("p",null,[l("em",null,"Created by")],-1)),n[3395]||(n[3395]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffOverland_InfIntSat"},{default:i(()=>[l("details",li,[l("summary",null,[n[3396]||(n[3396]=l("a",{id:"Sindbad.Models.runoffOverland_InfIntSat",href:"#Sindbad.Models.runoffOverland_InfIntSat"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffOverland_InfIntSat")],-1)),n[3397]||(n[3397]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3398]||(n[3398]=l("p",null,"Overland flow as the sum of infiltration excess, interflow, and saturation excess runoffs.",-1)),n[3399]||(n[3399]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3400]||(n[3400]=l("ul",null,[l("li",null,"None")],-1)),n[3401]||(n[3401]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3402]||(n[3402]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3403]||(n[3403]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.inf_excess_runoff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :inf_excess_runoff)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.interflow_runoff"),o(": runoff loss from interflow in soil layers")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])],-1)),n[3404]||(n[3404]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3405]||(n[3405]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffOverland_InfIntSat.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3406]||(n[3406]=l("hr",null,null,-1)),n[3407]||(n[3407]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3408]||(n[3408]=l("p",null,[l("em",null,"References")],-1)),n[3409]||(n[3409]=l("p",null,[l("em",null,"Versions")],-1)),n[3410]||(n[3410]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[3411]||(n[3411]=l("p",null,[l("em",null,"Created by")],-1)),n[3412]||(n[3412]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffOverland_Sat"},{default:i(()=>[l("details",ni,[l("summary",null,[n[3413]||(n[3413]=l("a",{id:"Sindbad.Models.runoffOverland_Sat",href:"#Sindbad.Models.runoffOverland_Sat"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffOverland_Sat")],-1)),n[3414]||(n[3414]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3415]||(n[3415]=l("p",null,"Overland flow due to saturation excess runoff.",-1)),n[3416]||(n[3416]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3417]||(n[3417]=l("ul",null,[l("li",null,"None")],-1)),n[3418]||(n[3418]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3419]||(n[3419]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3420]||(n[3420]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])],-1)),n[3421]||(n[3421]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3422]||(n[3422]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffOverland_Sat.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3423]||(n[3423]=l("hr",null,null,-1)),n[3424]||(n[3424]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3425]||(n[3425]=l("p",null,[l("em",null,"References")],-1)),n[3426]||(n[3426]=l("p",null,[l("em",null,"Versions")],-1)),n[3427]||(n[3427]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[3428]||(n[3428]=l("p",null,[l("em",null,"Created by")],-1)),n[3429]||(n[3429]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffOverland_none"},{default:i(()=>[l("details",oi,[l("summary",null,[n[3430]||(n[3430]=l("a",{id:"Sindbad.Models.runoffOverland_none",href:"#Sindbad.Models.runoffOverland_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffOverland_none")],-1)),n[3431]||(n[3431]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3432]||(n[3432]=l("p",null,"Sets overland runoff to 0.",-1)),n[3433]||(n[3433]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3434]||(n[3434]=l("ul",null,[l("li",null,"None")],-1)),n[3435]||(n[3435]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3436]||(n[3436]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3437]||(n[3437]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])],-1)),n[3438]||(n[3438]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3439]||(n[3439]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffOverland_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3440]||(n[3440]=l("hr",null,null,-1)),n[3441]||(n[3441]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4680]||(n[4680]=l("hr",null,null,-1)),n[4681]||(n[4681]=l("h3",{id:"runoffSaturationExcess",tabindex:"-1"},[o("runoffSaturationExcess "),l("a",{class:"header-anchor",href:"#runoffSaturationExcess","aria-label":'Permalink to "runoffSaturationExcess {#runoffSaturationExcess}"'},"​")],-1)),l("details",ei,[l("summary",null,[n[3443]||(n[3443]=l("a",{id:"Sindbad.Models.runoffSaturationExcess",href:"#Sindbad.Models.runoffSaturationExcess"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess")],-1)),n[3444]||(n[3444]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3445]||(n[3445]=u("",4))]),l("details",ti,[n[3589]||(n[3589]=l("summary",null,"runoffSaturationExcess approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffSaturationExcess_Bergstroem1992"},{default:i(()=>[l("details",ii,[l("summary",null,[n[3446]||(n[3446]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Bergstroem1992",href:"#Sindbad.Models.runoffSaturationExcess_Bergstroem1992"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Bergstroem1992")],-1)),n[3447]||(n[3447]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3448]||(n[3448]=l("p",null,"Saturation excess runoff using the original Bergström method.",-1)),n[3449]||(n[3449]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3450]||(n[3450]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"β"),o(": 1.1 ∈ [0.1, 5.0] => berg exponential parameter ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3451]||(n[3451]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3452]||(n[3452]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3453]||(n[3453]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3454]||(n[3454]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3455]||(n[3455]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Bergstroem1992.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3456]||(n[3456]=l("hr",null,null,-1)),n[3457]||(n[3457]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3458]||(n[3458]=l("p",null,[l("em",null,"References")],-1)),n[3459]||(n[3459]=l("ul",null,[l("li",null,"Bergström, S. (1992). The HBV model–its structure & applications. SMHI.")],-1)),n[3460]||(n[3460]=l("p",null,[l("em",null,"Versions")],-1)),n[3461]||(n[3461]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 27.11.2019 [skoirala | @dr-ko]: changed to handle any number of soil layers")]),l("li",null,[l("p",null,"1.2 on 10.02.2020 [ttraut]: modyfying variable name to match the new SINDBAD version")])],-1)),n[3462]||(n[3462]=l("p",null,[l("em",null,"Created by")],-1)),n[3463]||(n[3463]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_Bergstroem1992MixedVegFraction"},{default:i(()=>[l("details",si,[l("summary",null,[n[3464]||(n[3464]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Bergstroem1992MixedVegFraction",href:"#Sindbad.Models.runoffSaturationExcess_Bergstroem1992MixedVegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Bergstroem1992MixedVegFraction")],-1)),n[3465]||(n[3465]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3466]||(n[3466]=l("p",null,"Saturation excess runoff using the Bergström method with separate parameters for vegetated and non-vegetated fractions.",-1)),n[3467]||(n[3467]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3468]||(n[3468]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"β_veg"),o(": 5.0 ∈ [0.1, 20.0] => linear scaling parameter for berg for vegetated fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_soil"),o(": 2.0 ∈ [0.1, 20.0] => linear scaling parameter for berg for non vegetated fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_min"),o(": 0.1 ∈ [0.08, 0.12] => minimum effective β ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3469]||(n[3469]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3470]||(n[3470]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3471]||(n[3471]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3472]||(n[3472]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3473]||(n[3473]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Bergstroem1992MixedVegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3474]||(n[3474]=l("hr",null,null,-1)),n[3475]||(n[3475]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3476]||(n[3476]=l("p",null,[l("em",null,"References")],-1)),n[3477]||(n[3477]=l("ul",null,[l("li",null,"Bergström, S. (1992). The HBV model–its structure & applications. SMHI.")],-1)),n[3478]||(n[3478]=l("p",null,[l("em",null,"Versions")],-1)),n[3479]||(n[3479]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3480]||(n[3480]=l("p",null,[l("em",null,"Created by")],-1)),n[3481]||(n[3481]=l("ul",null,[l("li",null,[l("p",null,"1.1 on 27.11.2019: skoirala: changed to handle any number of soil layers")]),l("li",null,[l("p",null,"ttraut")])],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_Bergstroem1992VegFraction"},{default:i(()=>[l("details",ui,[l("summary",null,[n[3482]||(n[3482]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFraction",href:"#Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFraction")],-1)),n[3483]||(n[3483]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3484]||(n[3484]=l("p",null,"Saturation excess runoff using the Bergström method with parameters scaled by vegetation fraction.",-1)),n[3485]||(n[3485]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3486]||(n[3486]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"β"),o(": 3.0 ∈ [0.1, 10.0] => linear scaling parameter to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_min"),o(": 0.1 ∈ [0.08, 0.12] => minimum effective β ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3487]||(n[3487]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3488]||(n[3488]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3489]||(n[3489]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"runoffSaturationExcess.β_veg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :β_veg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3490]||(n[3490]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3491]||(n[3491]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Bergstroem1992VegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3492]||(n[3492]=l("hr",null,null,-1)),n[3493]||(n[3493]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3494]||(n[3494]=l("p",null,[l("em",null,"References")],-1)),n[3495]||(n[3495]=l("ul",null,[l("li",null,"Bergström, S. (1992). The HBV model–its structure & applications. SMHI.")],-1)),n[3496]||(n[3496]=l("p",null,[l("em",null,"Versions")],-1)),n[3497]||(n[3497]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 27.11.2019 [skoirala | @dr-ko]: changed to handle any number of soil layers")]),l("li",null,[l("p",null,"1.2 on 10.02.2020 [ttraut]: modyfying variable name to match the new SINDBAD version")])],-1)),n[3498]||(n[3498]=l("p",null,[l("em",null,"Created by")],-1)),n[3499]||(n[3499]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_Bergstroem1992VegFractionFroSoil"},{default:i(()=>[l("details",ri,[l("summary",null,[n[3500]||(n[3500]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionFroSoil",href:"#Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionFroSoil"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionFroSoil")],-1)),n[3501]||(n[3501]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3502]||(n[3502]=l("p",null,"Saturation excess runoff using the Bergström method with parameters scaled by vegetation fraction and frozen soil fraction.",-1)),n[3503]||(n[3503]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3504]||(n[3504]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"β"),o(": 3.0 ∈ [0.1, 10.0] => linear scaling parameter to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"frozen_frac_scalar"),o(": 1.0 ∈ [0.1, 3.0] => linear scaling parameter for frozen Soil fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_min"),o(": 0.1 ∈ [0.08, 0.12] => minimum effective β ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3505]||(n[3505]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3506]||(n[3506]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3507]||(n[3507]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.frac_frozen_soil"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :frac_frozen_soil)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"runoffSaturationExcess.frac_frozen"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :frac_frozen)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"runoffSaturationExcess.β_veg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :β_veg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3508]||(n[3508]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3509]||(n[3509]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Bergstroem1992VegFractionFroSoil.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3510]||(n[3510]=l("hr",null,null,-1)),n[3511]||(n[3511]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3512]||(n[3512]=l("p",null,[l("em",null,"References")],-1)),n[3513]||(n[3513]=l("ul",null,[l("li",null,"Bergstroem, S. (1992). The HBV model–its structure & applications. SMHI.")],-1)),n[3514]||(n[3514]=l("p",null,[l("em",null,"Versions")],-1)),n[3515]||(n[3515]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]")],-1)),n[3516]||(n[3516]=l("p",null,[l("em",null,"Created by")],-1)),n[3517]||(n[3517]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_Bergstroem1992VegFractionPFT"},{default:i(()=>[l("details",ai,[l("summary",null,[n[3518]||(n[3518]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionPFT",href:"#Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionPFT"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Bergstroem1992VegFractionPFT")],-1)),n[3519]||(n[3519]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3520]||(n[3520]=l("p",null,"Saturation excess runoff using the Bergström method with parameters scaled by vegetation fraction separated by different PFTs.",-1)),n[3521]||(n[3521]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3522]||(n[3522]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"β_PFT0"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 0 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT1"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 1 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT2"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 2 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT3"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 3 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT4"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 4 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT5"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 5 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT6"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 6 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT7"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 7 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT8"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 8 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT9"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 9 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT10"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 10 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_PFT11"),o(": 3.0 ∈ [0.1, 5.0] => linear scaling parameter of PFT class 11 to get the berg parameter from vegFrac ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"β_min"),o(": 0.1 ∈ [0.08, 0.12] => minimum effective β ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3523]||(n[3523]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3524]||(n[3524]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3525]||(n[3525]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"runoffSaturationExcess.β_veg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :β_veg)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[3526]||(n[3526]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3527]||(n[3527]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.PFT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :PFT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"runoffSaturationExcess.β_veg"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :β_veg)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3528]||(n[3528]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3529]||(n[3529]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Bergstroem1992VegFractionPFT.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3530]||(n[3530]=l("hr",null,null,-1)),n[3531]||(n[3531]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3532]||(n[3532]=l("p",null,[l("em",null,"References")],-1)),n[3533]||(n[3533]=l("ul",null,[l("li",null,"Bergström, S. (1992). The HBV model–its structure & applications. SMHI.")],-1)),n[3534]||(n[3534]=l("p",null,[l("em",null,"Versions")],-1)),n[3535]||(n[3535]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 10.09.2021 [ttraut]: based on runoffSaturation_BergstroemLinVegFr")]),l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.1 on 27.11.2019 [skoirala | @dr-ko]: changed to handle any number of soil layers")]),l("li",null,[l("p",null,"1.2 on 10.02.2020 [ttraut]: modyfying variable name to match the new SINDBAD version")])],-1)),n[3536]||(n[3536]=l("p",null,[l("em",null,"Created by")],-1)),n[3537]||(n[3537]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_Zhang2008"},{default:i(()=>[l("details",di,[l("summary",null,[n[3538]||(n[3538]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_Zhang2008",href:"#Sindbad.Models.runoffSaturationExcess_Zhang2008"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_Zhang2008")],-1)),n[3539]||(n[3539]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3540]||(n[3540]=l("p",null,"Saturation excess runoff as a function of incoming water and PET following Zhang (2008).",-1)),n[3541]||(n[3541]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3542]||(n[3542]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"α"),o(": 0.5 ∈ [0.01, 10.0] => an empirical Budyko parameter ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3543]||(n[3543]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3544]||(n[3544]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3545]||(n[3545]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3546]||(n[3546]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3547]||(n[3547]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_Zhang2008.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3548]||(n[3548]=l("hr",null,null,-1)),n[3549]||(n[3549]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3550]||(n[3550]=l("p",null,[l("em",null,"References")],-1)),n[3551]||(n[3551]=l("ul",null,[l("li",null,[l("p",null,"Zhang et al 2008; Water balance modeling over variable time scales based on the Budyko framework ? Model development & testing; Journal of Hydrology")]),l("li",null,[l("p",null,"a combination of eq 14 & eq 15 in zhang et al 2008")])],-1)),n[3552]||(n[3552]=l("p",null,[l("em",null,"Versions")],-1)),n[3553]||(n[3553]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[3554]||(n[3554]=l("p",null,[l("em",null,"Created by")],-1)),n[3555]||(n[3555]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[3556]||(n[3556]=l("p",null,[l("em",null,"Notes")],-1)),n[3557]||(n[3557]=l("ul",null,[l("li",null,[l("p",null,'is supposed to work over multiple time scales. it represents the "fast" | "direct" runoff & thus it"s conceptually not really consistent with "saturation runoff". it basically lumps saturation runoff & interflow; i.e. if using this approach for saturation runoff it would be consistent to set interflow to none')]),l("li",null,[l("p",null,"supply limit is (land.states.WBP): Zhang et al use precipitation as supply limit. we here use precip +snow melt - interception - infliltration excess runoff (i.e. the water that arrives at the ground) - this is more consistent with the budyko logic than just using precip")])],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_none"},{default:i(()=>[l("details",pi,[l("summary",null,[n[3558]||(n[3558]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_none",href:"#Sindbad.Models.runoffSaturationExcess_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_none")],-1)),n[3559]||(n[3559]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3560]||(n[3560]=l("p",null,"Sets saturation excess runoff to 0.",-1)),n[3561]||(n[3561]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3562]||(n[3562]=l("ul",null,[l("li",null,"None")],-1)),n[3563]||(n[3563]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3564]||(n[3564]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3565]||(n[3565]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])])])],-1)),n[3566]||(n[3566]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3567]||(n[3567]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3568]||(n[3568]=l("hr",null,null,-1)),n[3569]||(n[3569]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1}),e(s,{label:"runoffSaturationExcess_satFraction"},{default:i(()=>[l("details",fi,[l("summary",null,[n[3570]||(n[3570]=l("a",{id:"Sindbad.Models.runoffSaturationExcess_satFraction",href:"#Sindbad.Models.runoffSaturationExcess_satFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSaturationExcess_satFraction")],-1)),n[3571]||(n[3571]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3572]||(n[3572]=l("p",null,"Saturation excess runoff as a fraction of the saturated fraction of a grid-cell.",-1)),n[3573]||(n[3573]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3574]||(n[3574]=l("ul",null,[l("li",null,"None")],-1)),n[3575]||(n[3575]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3576]||(n[3576]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3577]||(n[3577]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.satFrac"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :satFrac)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sat_excess_runoff"),o(": saturation excess runoff")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])])])])],-1)),n[3578]||(n[3578]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3579]||(n[3579]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSaturationExcess_satFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3580]||(n[3580]=l("hr",null,null,-1)),n[3581]||(n[3581]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3582]||(n[3582]=l("p",null,[l("em",null,"References")],-1)),n[3583]||(n[3583]=l("p",null,[l("em",null,"Versions")],-1)),n[3584]||(n[3584]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[3585]||(n[3585]=l("p",null,[l("em",null,"Created by")],-1)),n[3586]||(n[3586]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[3587]||(n[3587]=l("p",null,[l("em",null,"Notes")],-1)),n[3588]||(n[3588]=l("ul",null,[l("li",null,"only works if soilWSatFrac module is activated")],-1))])]),_:1})]),_:1})]),n[4682]||(n[4682]=l("hr",null,null,-1)),n[4683]||(n[4683]=l("h3",{id:"runoffSurface",tabindex:"-1"},[o("runoffSurface "),l("a",{class:"header-anchor",href:"#runoffSurface","aria-label":'Permalink to "runoffSurface {#runoffSurface}"'},"​")],-1)),l("details",gi,[l("summary",null,[n[3590]||(n[3590]=l("a",{id:"Sindbad.Models.runoffSurface",href:"#Sindbad.Models.runoffSurface"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface")],-1)),n[3591]||(n[3591]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3592]||(n[3592]=u("",4))]),l("details",mi,[n[3716]||(n[3716]=l("summary",null,"runoffSurface approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"runoffSurface_Orth2013"},{default:i(()=>[l("details",bi,[l("summary",null,[n[3593]||(n[3593]=l("a",{id:"Sindbad.Models.runoffSurface_Orth2013",href:"#Sindbad.Models.runoffSurface_Orth2013"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_Orth2013")],-1)),n[3594]||(n[3594]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3595]||(n[3595]=l("p",null,"Surface runoff directly calculated using delay coefficient for the last 60 days based on the Orth et al. (2013) method.",-1)),n[3596]||(n[3596]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3597]||(n[3597]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"qt"),o(": 2.0 ∈ [0.5, 100.0] => delay parameter for land runoff (units: "),l("code",null,"time"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3598]||(n[3598]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3599]||(n[3599]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3600]||(n[3600]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"surface_runoff.z"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :z)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3601]||(n[3601]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3602]||(n[3602]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"surface_runoff.z"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :z)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3603]||(n[3603]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3604]||(n[3604]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_Orth2013.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3605]||(n[3605]=l("hr",null,null,-1)),n[3606]||(n[3606]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3607]||(n[3607]=l("p",null,[l("em",null,"References")],-1)),n[3608]||(n[3608]=l("ul",null,[l("li",null,[l("p",null,"Orth, R., Koster, R. D., & Seneviratne, S. I. (2013). Inferring soil moisture memory from streamflow observations using a simple water balance model. Journal of Hydrometeorology, 14[6], 1773-1790.")]),l("li",null,[l("p",null,"used in Trautmann et al. 2018")])],-1)),n[3609]||(n[3609]=l("p",null,[l("em",null,"Versions")],-1)),n[3610]||(n[3610]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]")],-1)),n[3611]||(n[3611]=l("p",null,[l("em",null,"Created by")],-1)),n[3612]||(n[3612]=l("ul",null,[l("li",null,"ttraut")],-1)),n[3613]||(n[3613]=l("p",null,[l("em",null,"Notes")],-1)),n[3614]||(n[3614]=l("ul",null,[l("li",null,"how to handle 60days?!?!")],-1))])]),_:1}),e(s,{label:"runoffSurface_Trautmann2018"},{default:i(()=>[l("details",yi,[l("summary",null,[n[3615]||(n[3615]=l("a",{id:"Sindbad.Models.runoffSurface_Trautmann2018",href:"#Sindbad.Models.runoffSurface_Trautmann2018"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_Trautmann2018")],-1)),n[3616]||(n[3616]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3617]||(n[3617]=l("p",null,"Surface runoff directly calculated using delay coefficient for the last 60 days based on the Orth et al. (2013) method, but with a different delay coefficient as implemented in Trautmann et al. (2018).",-1)),n[3618]||(n[3618]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3619]||(n[3619]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"qt"),o(": 2.0 ∈ [0.5, 100.0] => delay parameter for land runoff (units: "),l("code",null,"time"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3620]||(n[3620]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3621]||(n[3621]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3622]||(n[3622]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"surface_runoff.z"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :z)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3623]||(n[3623]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3624]||(n[3624]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"surface_runoff.z"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :z)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.rain"),o(": amount of precipitation in liquid form")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.snow"),o(": amount of precipitation in solid form")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:pools, :snowW_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW_prev"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:pools, :soilW_prev)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evaporation"),o(": evaporation from the first soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.sublimation"),o(": sublimation of the snow")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.Rdelay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :Rdelay)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"surface_runoff.dSurf"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:surface_runoff, :dSurf)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3625]||(n[3625]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3626]||(n[3626]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_Trautmann2018.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3627]||(n[3627]=l("hr",null,null,-1)),n[3628]||(n[3628]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3629]||(n[3629]=l("p",null,[l("em",null,"References")],-1)),n[3630]||(n[3630]=l("ul",null,[l("li",null,[l("p",null,"Orth, R., Koster, R. D., & Seneviratne, S. I. (2013). Inferring soil moisture memory from streamflow observations using a simple water balance model. Journal of Hydrometeorology, 14[6], 1773-1790.")]),l("li",null,[l("p",null,"used in Trautmann et al. 2018")])],-1)),n[3631]||(n[3631]=l("p",null,[l("em",null,"Versions")],-1)),n[3632]||(n[3632]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]")]),l("li",null,[l("p",null,"1.1 on 21.01.2020 [ttraut] : calculate surfaceW[1] based on water balance (1:1 as in TWS Paper)")])],-1)),n[3633]||(n[3633]=l("p",null,[l("em",null,"Created by")],-1)),n[3634]||(n[3634]=l("ul",null,[l("li",null,"ttraut")],-1)),n[3635]||(n[3635]=l("p",null,[l("em",null,"Notes")],-1)),n[3636]||(n[3636]=l("ul",null,[l("li",null,"how to handle 60days?!?!")],-1))])]),_:1}),e(s,{label:"runoffSurface_all"},{default:i(()=>[l("details",ci,[l("summary",null,[n[3637]||(n[3637]=l("a",{id:"Sindbad.Models.runoffSurface_all",href:"#Sindbad.Models.runoffSurface_all"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_all")],-1)),n[3638]||(n[3638]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3639]||(n[3639]=l("p",null,"All overland runoff generates surface runoff.",-1)),n[3640]||(n[3640]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3641]||(n[3641]=l("ul",null,[l("li",null,"None")],-1)),n[3642]||(n[3642]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3643]||(n[3643]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3644]||(n[3644]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])])])],-1)),n[3645]||(n[3645]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3646]||(n[3646]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_all.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3647]||(n[3647]=l("hr",null,null,-1)),n[3648]||(n[3648]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3649]||(n[3649]=l("p",null,[l("em",null,"References")],-1)),n[3650]||(n[3650]=l("p",null,[l("em",null,"Versions")],-1)),n[3651]||(n[3651]=l("ul",null,[l("li",null,"1.0 on 20.11.2019 [skoirala | @dr-ko]: combine surface_runoff_direct, Indir, suw_recharge")],-1)),n[3652]||(n[3652]=l("p",null,[l("em",null,"Created by")],-1)),n[3653]||(n[3653]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffSurface_directIndirect"},{default:i(()=>[l("details",vi,[l("summary",null,[n[3654]||(n[3654]=l("a",{id:"Sindbad.Models.runoffSurface_directIndirect",href:"#Sindbad.Models.runoffSurface_directIndirect"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_directIndirect")],-1)),n[3655]||(n[3655]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3656]||(n[3656]=l("p",null,"Surface runoff as the sum of the direct fraction of overland runoff and the indirect fraction of surface water storage.",-1)),n[3657]||(n[3657]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3658]||(n[3658]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"dc"),o(": 0.01 ∈ [0.0001, 1.0] => delayed surface runoff coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"rf"),o(": 0.5 ∈ [0.0001, 1.0] => fraction of overland runoff that recharges the surface water storage ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3659]||(n[3659]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3660]||(n[3660]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3661]||(n[3661]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff_direct"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :surface_runoff_direct)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff_indirect"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :surface_runoff_indirect)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.suw_recharge"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :suw_recharge)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])])])])],-1)),n[3662]||(n[3662]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3663]||(n[3663]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_directIndirect.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3664]||(n[3664]=l("hr",null,null,-1)),n[3665]||(n[3665]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3666]||(n[3666]=l("p",null,[l("em",null,"References")],-1)),n[3667]||(n[3667]=l("p",null,[l("em",null,"Versions")],-1)),n[3668]||(n[3668]=l("p",null,[l("em",null,"Created by")],-1)),n[3669]||(n[3669]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffSurface_directIndirectFroSoil"},{default:i(()=>[l("details",ki,[l("summary",null,[n[3670]||(n[3670]=l("a",{id:"Sindbad.Models.runoffSurface_directIndirectFroSoil",href:"#Sindbad.Models.runoffSurface_directIndirectFroSoil"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_directIndirectFroSoil")],-1)),n[3671]||(n[3671]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3672]||(n[3672]=l("p",null,"Surface runoff as the sum of the direct fraction of overland runoff and the indirect fraction of surface water storage, with the direct fraction additionally dependent on the frozen fraction of the grid.",-1)),n[3673]||(n[3673]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3674]||(n[3674]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"dc"),o(": 0.01 ∈ [0.0, 1.0] => delayed surface runoff coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"rf"),o(": 0.5 ∈ [0.0, 1.0] => fraction of overland runoff that recharges the surface water storage ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3675]||(n[3675]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3676]||(n[3676]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3677]||(n[3677]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"runoffSaturationExcess.frac_frozen"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:runoffSaturationExcess, :frac_frozen)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff_direct"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :surface_runoff_direct)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff_indirect"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :surface_runoff_indirect)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.suw_recharge"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :suw_recharge)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])])])])],-1)),n[3678]||(n[3678]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3679]||(n[3679]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_directIndirectFroSoil.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3680]||(n[3680]=l("hr",null,null,-1)),n[3681]||(n[3681]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3682]||(n[3682]=l("p",null,[l("em",null,"References")],-1)),n[3683]||(n[3683]=l("p",null,[l("em",null,"Versions")],-1)),n[3684]||(n[3684]=l("ul",null,[l("li",null,"1.0 on 03.12.2020 [ttraut]")],-1)),n[3685]||(n[3685]=l("p",null,[l("em",null,"Created by")],-1)),n[3686]||(n[3686]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"runoffSurface_indirect"},{default:i(()=>[l("details",Si,[l("summary",null,[n[3687]||(n[3687]=l("a",{id:"Sindbad.Models.runoffSurface_indirect",href:"#Sindbad.Models.runoffSurface_indirect"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_indirect")],-1)),n[3688]||(n[3688]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3689]||(n[3689]=l("p",null,"All overland runoff is collected in surface water storage first, which in turn generates indirect surface runoff.",-1)),n[3690]||(n[3690]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3691]||(n[3691]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"dc"),o(": 0.01 ∈ [0.0, 1.0] => delayed surface runoff coefficient ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3692]||(n[3692]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3693]||(n[3693]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3694]||(n[3694]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.overland_runoff"),o(": overland runoff as a fraction of incoming water")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.suw_recharge"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :suw_recharge)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])])])])],-1)),n[3695]||(n[3695]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3696]||(n[3696]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_indirect.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3697]||(n[3697]=l("hr",null,null,-1)),n[3698]||(n[3698]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3699]||(n[3699]=l("p",null,[l("em",null,"References")],-1)),n[3700]||(n[3700]=l("p",null,[l("em",null,"Versions")],-1)),n[3701]||(n[3701]=l("ul",null,[l("li",null,"1.0 on 20.11.2019 [skoirala | @dr-ko]: combine surface_runoff_direct, Indir, suw_recharge")],-1)),n[3702]||(n[3702]=l("p",null,[l("em",null,"Created by")],-1)),n[3703]||(n[3703]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"runoffSurface_none"},{default:i(()=>[l("details",wi,[l("summary",null,[n[3704]||(n[3704]=l("a",{id:"Sindbad.Models.runoffSurface_none",href:"#Sindbad.Models.runoffSurface_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.runoffSurface_none")],-1)),n[3705]||(n[3705]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3706]||(n[3706]=l("p",null,"Sets surface runoff to 0.",-1)),n[3707]||(n[3707]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3708]||(n[3708]=l("ul",null,[l("li",null,"None")],-1)),n[3709]||(n[3709]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3710]||(n[3710]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3711]||(n[3711]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.surface_runoff"),o(": total surface runoff")])])])],-1)),n[3712]||(n[3712]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3713]||(n[3713]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"runoffSurface_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3714]||(n[3714]=l("hr",null,null,-1)),n[3715]||(n[3715]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4684]||(n[4684]=l("hr",null,null,-1)),n[4685]||(n[4685]=l("h3",{id:"saturatedFraction",tabindex:"-1"},[o("saturatedFraction "),l("a",{class:"header-anchor",href:"#saturatedFraction","aria-label":'Permalink to "saturatedFraction {#saturatedFraction}"'},"​")],-1)),l("details",Ti,[l("summary",null,[n[3717]||(n[3717]=l("a",{id:"Sindbad.Models.saturatedFraction",href:"#Sindbad.Models.saturatedFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.saturatedFraction")],-1)),n[3718]||(n[3718]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3719]||(n[3719]=u("",4))]),l("details",ji,[n[3732]||(n[3732]=l("summary",null,"saturatedFraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"saturatedFraction_none"},{default:i(()=>[l("details",Ei,[l("summary",null,[n[3720]||(n[3720]=l("a",{id:"Sindbad.Models.saturatedFraction_none",href:"#Sindbad.Models.saturatedFraction_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.saturatedFraction_none")],-1)),n[3721]||(n[3721]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3722]||(n[3722]=l("p",null,"Sets the saturated soil fraction to 0.",-1)),n[3723]||(n[3723]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3724]||(n[3724]=l("ul",null,[l("li",null,"None")],-1)),n[3725]||(n[3725]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3726]||(n[3726]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3727]||(n[3727]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.satFrac"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :satFrac)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[3728]||(n[3728]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3729]||(n[3729]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"saturatedFraction_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3730]||(n[3730]=l("hr",null,null,-1)),n[3731]||(n[3731]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4686]||(n[4686]=l("hr",null,null,-1)),n[4687]||(n[4687]=l("h3",{id:"snowFraction",tabindex:"-1"},[o("snowFraction "),l("a",{class:"header-anchor",href:"#snowFraction","aria-label":'Permalink to "snowFraction {#snowFraction}"'},"​")],-1)),l("details",xi,[l("summary",null,[n[3733]||(n[3733]=l("a",{id:"Sindbad.Models.snowFraction",href:"#Sindbad.Models.snowFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowFraction")],-1)),n[3734]||(n[3734]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3735]||(n[3735]=u("",4))]),l("details",Ci,[n[3783]||(n[3783]=l("summary",null,"snowFraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"snowFraction_HTESSEL"},{default:i(()=>[l("details",Mi,[l("summary",null,[n[3736]||(n[3736]=l("a",{id:"Sindbad.Models.snowFraction_HTESSEL",href:"#Sindbad.Models.snowFraction_HTESSEL"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowFraction_HTESSEL")],-1)),n[3737]||(n[3737]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3738]||(n[3738]=l("p",null,"Snow cover fraction following the HTESSEL approach.",-1)),n[3739]||(n[3739]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3740]||(n[3740]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"snow_cover_param"),o(": 15.0 ∈ [1.0, 100.0] => Snow Cover Parameter (units: "),l("code",null,"mm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3741]||(n[3741]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3742]||(n[3742]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3743]||(n[3743]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])])])],-1)),n[3744]||(n[3744]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3745]||(n[3745]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"snowFraction_HTESSEL.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3746]||(n[3746]=l("hr",null,null,-1)),n[3747]||(n[3747]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3748]||(n[3748]=l("p",null,[l("em",null,"References")],-1)),n[3749]||(n[3749]=l("ul",null,[l("li",null,'H-TESSEL = land surface scheme of the European Centre for Medium- Range Weather Forecasts" operational weather forecast system Balsamo et al.; 2009')],-1)),n[3750]||(n[3750]=l("p",null,[l("em",null,"Versions")],-1)),n[3751]||(n[3751]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3752]||(n[3752]=l("p",null,[l("em",null,"Created by")],-1)),n[3753]||(n[3753]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"snowFraction_binary"},{default:i(()=>[l("details",Ii,[l("summary",null,[n[3754]||(n[3754]=l("a",{id:"Sindbad.Models.snowFraction_binary",href:"#Sindbad.Models.snowFraction_binary"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowFraction_binary")],-1)),n[3755]||(n[3755]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3756]||(n[3756]=l("p",null,"Snow cover fraction using a binary approach.",-1)),n[3757]||(n[3757]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3758]||(n[3758]=l("ul",null,[l("li",null,"None")],-1)),n[3759]||(n[3759]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3760]||(n[3760]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3761]||(n[3761]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])])])],-1)),n[3762]||(n[3762]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3763]||(n[3763]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"snowFraction_binary.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3764]||(n[3764]=l("hr",null,null,-1)),n[3765]||(n[3765]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3766]||(n[3766]=l("p",null,[l("em",null,"References")],-1)),n[3767]||(n[3767]=l("p",null,[l("em",null,"Versions")],-1)),n[3768]||(n[3768]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3769]||(n[3769]=l("p",null,[l("em",null,"Created by")],-1)),n[3770]||(n[3770]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"snowFraction_none"},{default:i(()=>[l("details",Ai,[l("summary",null,[n[3771]||(n[3771]=l("a",{id:"Sindbad.Models.snowFraction_none",href:"#Sindbad.Models.snowFraction_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowFraction_none")],-1)),n[3772]||(n[3772]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3773]||(n[3773]=l("p",null,"Sets the snow cover fraction to 0.",-1)),n[3774]||(n[3774]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3775]||(n[3775]=l("ul",null,[l("li",null,"None")],-1)),n[3776]||(n[3776]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3777]||(n[3777]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3778]||(n[3778]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])])])],-1)),n[3779]||(n[3779]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[3780]||(n[3780]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"snowFraction_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3781]||(n[3781]=l("hr",null,null,-1)),n[3782]||(n[3782]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4688]||(n[4688]=l("hr",null,null,-1)),n[4689]||(n[4689]=l("h3",{id:"snowMelt",tabindex:"-1"},[o("snowMelt "),l("a",{class:"header-anchor",href:"#snowMelt","aria-label":'Permalink to "snowMelt {#snowMelt}"'},"​")],-1)),l("details",Pi,[l("summary",null,[n[3784]||(n[3784]=l("a",{id:"Sindbad.Models.snowMelt",href:"#Sindbad.Models.snowMelt"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowMelt")],-1)),n[3785]||(n[3785]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3786]||(n[3786]=u("",4))]),l("details",Ri,[n[3823]||(n[3823]=l("summary",null,"snowMelt approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"snowMelt_Tair"},{default:i(()=>[l("details",Vi,[l("summary",null,[n[3787]||(n[3787]=l("a",{id:"Sindbad.Models.snowMelt_Tair",href:"#Sindbad.Models.snowMelt_Tair"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowMelt_Tair")],-1)),n[3788]||(n[3788]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3789]||(n[3789]=l("p",null,"Snowmelt as a function of air temperature.",-1)),n[3790]||(n[3790]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3791]||(n[3791]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"rate"),o(": 1.0 ∈ [0.1, 10.0] => snow melt rate (units: "),l("code",null,"mm/°C"),o(" @ "),l("code",null,"day"),o(" timescale)")])])])],-1)),n[3792]||(n[3792]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3793]||(n[3793]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3794]||(n[3794]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.snow_melt"),o(": snow melt")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.Tterm"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :Tterm)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])])],-1)),n[3795]||(n[3795]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3796]||(n[3796]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"snowMelt_Tair.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3797]||(n[3797]=l("hr",null,null,-1)),n[3798]||(n[3798]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3799]||(n[3799]=l("p",null,[l("em",null,"References")],-1)),n[3800]||(n[3800]=l("p",null,[l("em",null,"Versions")],-1)),n[3801]||(n[3801]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")]),l("li",null,[l("p",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")])],-1)),n[3802]||(n[3802]=l("p",null,[l("em",null,"Created by")],-1)),n[3803]||(n[3803]=l("ul",null,[l("li",null,"mjung")],-1)),n[3804]||(n[3804]=l("p",null,[l("em",null,"Notes")],-1)),n[3805]||(n[3805]=l("ul",null,[l("li",null,[l("p",null,"may not be working well for longer time scales (like for weekly | longer time scales). Warnings needs to be set accordingly.")]),l("li",null,[l("p",null,"may not be working well for longer time scales (like for weekly | longer time scales). Warnings needs to be set accordingly.")])],-1))])]),_:1}),e(s,{label:"snowMelt_TairRn"},{default:i(()=>[l("details",Wi,[l("summary",null,[n[3806]||(n[3806]=l("a",{id:"Sindbad.Models.snowMelt_TairRn",href:"#Sindbad.Models.snowMelt_TairRn"},[l("span",{class:"jlbinding"},"Sindbad.Models.snowMelt_TairRn")],-1)),n[3807]||(n[3807]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3808]||(n[3808]=l("p",null,"Snowmelt based on temperature and net radiation when air temperature exceeds 0°C.",-1)),n[3809]||(n[3809]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3810]||(n[3810]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"melt_T"),o(": 3.0 ∈ [0.01, 10.0] => melt factor for temperature (units: "),l("code",null,"mm/°C"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"melt_Rn"),o(": 2.0 ∈ [0.01, 3.0] => melt factor for radiation (units: "),l("code",null,"mm/MJ/m2"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3811]||(n[3811]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3812]||(n[3812]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3813]||(n[3813]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_rn"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rn)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_airT"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.snow_melt"),o(": snow melt")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.potential_snow_melt"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:fluxes, :potential_snow_melt)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])])],-1)),n[3814]||(n[3814]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[3815]||(n[3815]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"snowMelt_TairRn.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3816]||(n[3816]=l("hr",null,null,-1)),n[3817]||(n[3817]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3818]||(n[3818]=l("p",null,[l("em",null,"References")],-1)),n[3819]||(n[3819]=l("p",null,[l("em",null,"Versions")],-1)),n[3820]||(n[3820]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[3821]||(n[3821]=l("p",null,[l("em",null,"Created by")],-1)),n[3822]||(n[3822]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1})]),_:1})]),n[4690]||(n[4690]=l("hr",null,null,-1)),n[4691]||(n[4691]=l("h3",{id:"soilProperties",tabindex:"-1"},[o("soilProperties "),l("a",{class:"header-anchor",href:"#soilProperties","aria-label":'Permalink to "soilProperties {#soilProperties}"'},"​")],-1)),l("details",Di,[l("summary",null,[n[3824]||(n[3824]=l("a",{id:"Sindbad.Models.soilProperties",href:"#Sindbad.Models.soilProperties"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilProperties")],-1)),n[3825]||(n[3825]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3826]||(n[3826]=u("",4))]),l("details",Fi,[n[3867]||(n[3867]=l("summary",null,"soilProperties approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"soilProperties_Saxton1986"},{default:i(()=>[l("details",Ni,[l("summary",null,[n[3827]||(n[3827]=l("a",{id:"Sindbad.Models.soilProperties_Saxton1986",href:"#Sindbad.Models.soilProperties_Saxton1986"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilProperties_Saxton1986")],-1)),n[3828]||(n[3828]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3829]||(n[3829]=l("p",null,"Soil hydraulic properties based on Saxton (1986).",-1)),n[3830]||(n[3830]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3831]||(n[3831]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"ψ_fc"),o(": 33.0 ∈ [30.0, 35.0] => matric potential at field capacity (units: "),l("code",null,"kPa"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ψ_wp"),o(": 1500.0 ∈ [1000.0, 1800.0] => matric potential at wilting point (units: "),l("code",null,"kPa"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"ψ_sat"),o(": 0.0 ∈ [0.0, 5.0] => matric potential at saturation (units: "),l("code",null,"kPa"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a1"),o(": -4.396 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a2"),o(": -0.0715 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a3"),o(": -0.000488 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a4"),o(": -4.285e-5 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"b1"),o(": -3.14 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"b2"),o(": -0.00222 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"b3"),o(": -3.484e-5 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c1"),o(": 0.332 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c2"),o(": -0.0007251 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c3"),o(": 0.1276 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"d1"),o(": -0.108 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"d2"),o(": 0.341 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e1"),o(": 2.778e-6 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e2"),o(": 12.012 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e3"),o(": -0.0755 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e4"),o(": -3.895 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e5"),o(": 0.03671 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e6"),o(": -0.1103 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e7"),o(": 0.00087546 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f1"),o(": 2.302 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n2"),o(": 2.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n24"),o(": 24.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n10"),o(": 10.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n100"),o(": 100.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n1000"),o(": 1000.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n1500"),o(": 1000.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n3600"),o(": 3600.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3832]||(n[3832]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3833]||(n[3833]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3834]||(n[3834]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.n100"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :n100)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.n1000"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :n1000)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.n2"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :n2)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.n24"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :n24)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.n3600"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :n3600)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e1"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e1)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e2"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e2)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e3"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e3)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e4"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e4)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e5"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e5)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e6"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e6)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"soilProperties.e7"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilProperties, :e7)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])])])])],-1)),n[3835]||(n[3835]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3836]||(n[3836]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])])])])],-1)),n[3837]||(n[3837]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3838]||(n[3838]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilProperties_Saxton1986.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3839]||(n[3839]=l("hr",null,null,-1)),n[3840]||(n[3840]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3841]||(n[3841]=l("p",null,[l("em",null,"References")],-1)),n[3842]||(n[3842]=l("ul",null,[l("li",null,"Saxton, K. E., Rawls, W., Romberger, J. S., & Papendick, R. I. (1986). Estimating generalized soil‐water characteristics from texture. Soil science society of America Journal, 50(4), 1031-1036.")],-1)),n[3843]||(n[3843]=l("p",null,[l("em",null,"Versions")],-1)),n[3844]||(n[3844]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 21.11.2019")]),l("li",null,[l("p",null,"1.1 on 03.12.2019 [skoirala | @dr-ko]: handling potentail vertical distribution of soil texture")])],-1)),n[3845]||(n[3845]=l("p",null,[l("em",null,"Created by")],-1)),n[3846]||(n[3846]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"soilProperties_Saxton2006"},{default:i(()=>[l("details",Oi,[l("summary",null,[n[3847]||(n[3847]=l("a",{id:"Sindbad.Models.soilProperties_Saxton2006",href:"#Sindbad.Models.soilProperties_Saxton2006"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilProperties_Saxton2006")],-1)),n[3848]||(n[3848]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3849]||(n[3849]=l("p",null,"Soil hydraulic properties based on Saxton (2006).",-1)),n[3850]||(n[3850]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3851]||(n[3851]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"DF"),o(": 1.0 ∈ [0.9, 1.3] => Density correction factor ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Rw"),o(": 0.0 ∈ [0.0, 1.0] => Weight fraction of gravel (decimal) (units: "),l("code",null,"g g-1"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"matric_soil_density"),o(": 2.65 ∈ [2.5, 3.0] => Matric soil density (units: "),l("code",null,"g cm-3"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"gravel_density"),o(": 2.65 ∈ [2.5, 3.0] => density of gravel material (units: "),l("code",null,"g cm-3"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"EC"),o(": 36.0 ∈ [30.0, 40.0] => SElectrical conductance of a saturated soil extract (units: "),l("code",null,"dS m-1 (dS/m = mili-mho cm-1)"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a1"),o(": -0.024 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a2"),o(": 0.487 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a3"),o(": 0.006 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a4"),o(": 0.005 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a5"),o(": 0.013 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a6"),o(": 0.068 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"a7"),o(": 0.031 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"b1"),o(": 0.14 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"b2"),o(": 0.02 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c1"),o(": -0.251 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c2"),o(": 0.195 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c3"),o(": 0.011 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c4"),o(": 0.006 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c5"),o(": 0.027 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c6"),o(": 0.452 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"c7"),o(": 0.299 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"d1"),o(": 1.283 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"d2"),o(": 0.374 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"d3"),o(": 0.015 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e1"),o(": 0.278 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e2"),o(": 0.034 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e3"),o(": 0.022 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e4"),o(": 0.018 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e5"),o(": 0.027 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e6"),o(": 0.584 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"e7"),o(": 0.078 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f1"),o(": 0.636 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"f2"),o(": 0.107 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g1"),o(": -21.67 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g2"),o(": 27.93 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g3"),o(": 81.97 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g4"),o(": 71.12 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g5"),o(": 8.29 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g6"),o(": 14.05 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g7"),o(": 27.16 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"h1"),o(": 0.02 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"h2"),o(": 0.113 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"h3"),o(": 0.7 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"i1"),o(": 0.097 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"i2"),o(": 0.043 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n02"),o(": 0.2 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n24"),o(": 24.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n33"),o(": 33.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n36"),o(": 36.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n1500"),o(": 1500.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"n1930"),o(": 1930.0 ∈ [-Inf, Inf] => Saxton Parameters ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3852]||(n[3852]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3853]||(n[3853]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3854]||(n[3854]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"models.unsat_k_model"),o(": name of the model used to calculate unsaturated hydraulic conductivity")])])])])],-1)),n[3855]||(n[3855]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3856]||(n[3856]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])])])])],-1)),n[3857]||(n[3857]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3858]||(n[3858]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilProperties_Saxton2006.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3859]||(n[3859]=l("hr",null,null,-1)),n[3860]||(n[3860]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3861]||(n[3861]=l("p",null,[l("em",null,"References")],-1)),n[3862]||(n[3862]=l("ul",null,[l("li",null,"Saxton, K. E., & Rawls, W. J. (2006). Soil water characteristic estimates by texture & organic matter for hydrologic solutions. Soil science society of America Journal, 70[5], 1569-1578.")],-1)),n[3863]||(n[3863]=l("p",null,[l("em",null,"Versions")],-1)),n[3864]||(n[3864]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 21.11.2019")]),l("li",null,[l("p",null,"1.1 on 03.12.2019 [skoirala | @dr-ko]: handling potentail vertical distribution of soil texture")])],-1)),n[3865]||(n[3865]=l("p",null,[l("em",null,"Created by")],-1)),n[3866]||(n[3866]=l("ul",null,[l("li",null,[l("p",null,"Nuno Carvalhais [ncarvalhais]")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1})]),_:1})]),n[4692]||(n[4692]=l("hr",null,null,-1)),n[4693]||(n[4693]=l("h3",{id:"soilTexture",tabindex:"-1"},[o("soilTexture "),l("a",{class:"header-anchor",href:"#soilTexture","aria-label":'Permalink to "soilTexture {#soilTexture}"'},"​")],-1)),l("details",Bi,[l("summary",null,[n[3868]||(n[3868]=l("a",{id:"Sindbad.Models.soilTexture",href:"#Sindbad.Models.soilTexture"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilTexture")],-1)),n[3869]||(n[3869]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3870]||(n[3870]=u("",4))]),l("details",Gi,[n[3913]||(n[3913]=l("summary",null,"soilTexture approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"soilTexture_constant"},{default:i(()=>[l("details",Li,[l("summary",null,[n[3871]||(n[3871]=l("a",{id:"Sindbad.Models.soilTexture_constant",href:"#Sindbad.Models.soilTexture_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilTexture_constant")],-1)),n[3872]||(n[3872]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3873]||(n[3873]=l("p",null,"Sets soil texture properties as constant values.",-1)),n[3874]||(n[3874]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3875]||(n[3875]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"clay"),o(": 0.2 ∈ [0.0, 1.0] => Clay content ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"silt"),o(": 0.3 ∈ [0.0, 1.0] => Silt content ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sand"),o(": 0.5 ∈ [0.0, 1.0] => Sand content ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"orgm"),o(": 0.0 ∈ [0.0, 1.0] => Organic matter content ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3876]||(n[3876]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3877]||(n[3877]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3878]||(n[3878]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])])])])],-1)),n[3879]||(n[3879]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3880]||(n[3880]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])])])])],-1)),n[3881]||(n[3881]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3882]||(n[3882]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilTexture_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3883]||(n[3883]=l("hr",null,null,-1)),n[3884]||(n[3884]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3885]||(n[3885]=l("p",null,[l("em",null,"References")],-1)),n[3886]||(n[3886]=l("p",null,[l("em",null,"Versions")],-1)),n[3887]||(n[3887]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[3888]||(n[3888]=l("p",null,[l("em",null,"Created by")],-1)),n[3889]||(n[3889]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[3890]||(n[3890]=l("p",null,[l("em",null,"Notes")],-1)),n[3891]||(n[3891]=l("ul",null,[l("li",null,"texture does not change with space & depth")],-1))])]),_:1}),e(s,{label:"soilTexture_forcing"},{default:i(()=>[l("details",zi,[l("summary",null,[n[3892]||(n[3892]=l("a",{id:"Sindbad.Models.soilTexture_forcing",href:"#Sindbad.Models.soilTexture_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilTexture_forcing")],-1)),n[3893]||(n[3893]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3894]||(n[3894]=l("p",null,"Gets Soil texture properties from forcing data.",-1)),n[3895]||(n[3895]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3896]||(n[3896]=l("ul",null,[l("li",null,"None")],-1)),n[3897]||(n[3897]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3898]||(n[3898]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3899]||(n[3899]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])])])])],-1)),n[3900]||(n[3900]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3901]||(n[3901]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_clay"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_clay)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_orgm"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_orgm)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_sand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_sand)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_silt"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_silt)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.st_clay"),o(": fraction of clay content in the soil")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_orgm"),o(": fraction of organic matter content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_sand"),o(": fraction of sand content in the soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.st_silt"),o(": fraction of silt content in the soil per layer")])])])])],-1)),n[3902]||(n[3902]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3903]||(n[3903]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilTexture_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3904]||(n[3904]=l("hr",null,null,-1)),n[3905]||(n[3905]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3906]||(n[3906]=l("p",null,[l("em",null,"References")],-1)),n[3907]||(n[3907]=l("p",null,[l("em",null,"Versions")],-1)),n[3908]||(n[3908]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[3909]||(n[3909]=l("p",null,[l("em",null,"Created by")],-1)),n[3910]||(n[3910]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[3911]||(n[3911]=l("p",null,[l("em",null,"Notes")],-1)),n[3912]||(n[3912]=l("ul",null,[l("li",null,[l("p",null,"if not; then sets the average of all as the fixed property of all layers")]),l("li",null,[l("p",null,"if the input has same number of layers & soilW; then sets the properties per layer")])],-1))])]),_:1})]),_:1})]),n[4694]||(n[4694]=l("hr",null,null,-1)),n[4695]||(n[4695]=l("h3",{id:"soilWBase",tabindex:"-1"},[o("soilWBase "),l("a",{class:"header-anchor",href:"#soilWBase","aria-label":'Permalink to "soilWBase {#soilWBase}"'},"​")],-1)),l("details",Ui,[l("summary",null,[n[3914]||(n[3914]=l("a",{id:"Sindbad.Models.soilWBase",href:"#Sindbad.Models.soilWBase"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilWBase")],-1)),n[3915]||(n[3915]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3916]||(n[3916]=u("",4))]),l("details",Ji,[n[3994]||(n[3994]=l("summary",null,"soilWBase approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"soilWBase_smax1Layer"},{default:i(()=>[l("details",Ki,[l("summary",null,[n[3917]||(n[3917]=l("a",{id:"Sindbad.Models.soilWBase_smax1Layer",href:"#Sindbad.Models.soilWBase_smax1Layer"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilWBase_smax1Layer")],-1)),n[3918]||(n[3918]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3919]||(n[3919]=l("p",null,"Maximum soil water content of one soil layer as a fraction of total soil depth, based on the Trautmann et al. (2018) model.",-1)),n[3920]||(n[3920]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3921]||(n[3921]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"smax"),o(": 1.0 ∈ [0.001, 10.0] => maximum soil water holding capacity of 1st soil layer, as % of defined soil depth ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[3922]||(n[3922]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3923]||(n[3923]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3924]||(n[3924]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])])])])],-1)),n[3925]||(n[3925]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3926]||(n[3926]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])])])])],-1)),n[3927]||(n[3927]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3928]||(n[3928]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilWBase_smax1Layer.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3929]||(n[3929]=l("hr",null,null,-1)),n[3930]||(n[3930]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3931]||(n[3931]=l("p",null,[l("em",null,"References")],-1)),n[3932]||(n[3932]=l("ul",null,[l("li",null,"Trautmann et al. 2018")],-1)),n[3933]||(n[3933]=l("p",null,[l("em",null,"Versions")],-1)),n[3934]||(n[3934]=l("ul",null,[l("li",null,"1.0 on 09.01.2020 [ttraut]: clean up & consistency")],-1)),n[3935]||(n[3935]=l("p",null,[l("em",null,"Created by")],-1)),n[3936]||(n[3936]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"soilWBase_smax2Layer"},{default:i(()=>[l("details",Hi,[l("summary",null,[n[3937]||(n[3937]=l("a",{id:"Sindbad.Models.soilWBase_smax2Layer",href:"#Sindbad.Models.soilWBase_smax2Layer"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilWBase_smax2Layer")],-1)),n[3938]||(n[3938]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3939]||(n[3939]=l("p",null,"Maximum soil water content of two soil layers as fractions of total soil depth, based on the older version of the Pre-Tokyo Model.",-1)),n[3940]||(n[3940]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3941]||(n[3941]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"smax1"),o(": 1.0 ∈ [0.001, 1.0] => maximum soil water holding capacity of 1st soil layer, as % of defined soil depth ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"smax2"),o(": 0.3 ∈ [0.01, 1.0] => maximum plant available water in 2nd soil layer, as % of defined soil depth ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3942]||(n[3942]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3943]||(n[3943]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3944]||(n[3944]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])])])])],-1)),n[3945]||(n[3945]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3946]||(n[3946]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])])])])],-1)),n[3947]||(n[3947]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3948]||(n[3948]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilWBase_smax2Layer.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3949]||(n[3949]=l("hr",null,null,-1)),n[3950]||(n[3950]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3951]||(n[3951]=l("p",null,[l("em",null,"References")],-1)),n[3952]||(n[3952]=l("p",null,[l("em",null,"Versions")],-1)),n[3953]||(n[3953]=l("ul",null,[l("li",null,"1.0 on 09.01.2020 [ttraut]: clean up & consistency")],-1)),n[3954]||(n[3954]=l("p",null,[l("em",null,"Created by")],-1)),n[3955]||(n[3955]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"soilWBase_smax2fRD4"},{default:i(()=>[l("details",qi,[l("summary",null,[n[3956]||(n[3956]=l("a",{id:"Sindbad.Models.soilWBase_smax2fRD4",href:"#Sindbad.Models.soilWBase_smax2fRD4"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilWBase_smax2fRD4")],-1)),n[3957]||(n[3957]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3958]||(n[3958]=l("p",null,"Maximum soil water content of two soil layers: the first layer as a fraction of soil depth, the second as a linear combination of scaled rooting depth data from forcing.",-1)),n[3959]||(n[3959]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3960]||(n[3960]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"smax1"),o(": 1.0 ∈ [0.001, 1.0] => maximum soil water holding capacity of 1st soil layer, as % of defined soil depth ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"scalar_Fan"),o(": 0.05 ∈ [0.0, 5.0] => scaling for rooting depth data to obtain smax2 (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"scalar_Yang"),o(": 0.05 ∈ [0.0, 5.0] => scaling for rooting depth data to obtain smax2 (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"scalar_Wang"),o(": 0.05 ∈ [0.0, 5.0] => scaling for root zone storage capacity data to obtain smax2 (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"scalar_Tian"),o(": 0.05 ∈ [0.0, 5.0] => scaling for plant avaiable water capacity data to obtain smax2 (units: "),l("code",null,"fraction"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"smax_Tian"),o(": 50.0 ∈ [0.0, 1000.0] => value for plant avaiable water capacity data where this is NaN (units: "),l("code",null,"mm"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])])],-1)),n[3961]||(n[3961]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3962]||(n[3962]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3963]||(n[3963]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"soilWBase.rootwater_capacities"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilWBase, :rootwater_capacities)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3964]||(n[3964]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[3965]||(n[3965]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_AWC"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_AWC)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_RDeff"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_RDeff)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_RDmax"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_RDmax)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_SWCmax"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_SWCmax)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"soilWBase.rootwater_capacities"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilWBase, :rootwater_capacities)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"soilWBase.rootwater_capacities"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:soilWBase, :rootwater_capacities)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[3966]||(n[3966]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[3967]||(n[3967]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilWBase_smax2fRD4.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3968]||(n[3968]=l("hr",null,null,-1)),n[3969]||(n[3969]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3970]||(n[3970]=l("p",null,[l("em",null,"References")],-1)),n[3971]||(n[3971]=l("p",null,[l("em",null,"Versions")],-1)),n[3972]||(n[3972]=l("ul",null,[l("li",null,"1.0 on 10.02.2020 [ttraut]")],-1)),n[3973]||(n[3973]=l("p",null,[l("em",null,"Created by")],-1)),n[3974]||(n[3974]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"soilWBase_uniform"},{default:i(()=>[l("details",Zi,[l("summary",null,[n[3975]||(n[3975]=l("a",{id:"Sindbad.Models.soilWBase_uniform",href:"#Sindbad.Models.soilWBase_uniform"},[l("span",{class:"jlbinding"},"Sindbad.Models.soilWBase_uniform")],-1)),n[3976]||(n[3976]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3977]||(n[3977]=l("p",null,"Soil hydraulic properties distributed for different soil layers assuming a uniform vertical distribution.",-1)),n[3978]||(n[3978]=l("p",null,[l("strong",null,"Parameters")],-1)),n[3979]||(n[3979]=l("ul",null,[l("li",null,"None")],-1)),n[3980]||(n[3980]=l("p",null,[l("strong",null,"Methods:")],-1)),n[3981]||(n[3981]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[3982]||(n[3982]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_wp"),o(": hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_awc"),o(": total amount of water available for vegetation/transpiration")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_fc"),o(": total amount of water in the soil at field capacity")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_α"),o(": alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_fc"),o(": moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_sat"),o(": moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_wp"),o(": moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_fc"),o(": matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_sat"),o(": matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_wp"),o(": matric potential of soil at wiliting point per layer")])])])])],-1)),n[3983]||(n[3983]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[3984]||(n[3984]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.sp_k_fc"),o(": calculated/input hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_sat"),o(": calculated/input hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_k_wp"),o(": calculated/input hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_α"),o(": calculated/input alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_β"),o(": calculated/input beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_fc"),o(": calculated/input moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_sat"),o(": calculated/input moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_θ_wp"),o(": calculated/input moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_fc"),o(": calculated/input matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_sat"),o(": calculated/input matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.sp_ψ_wp"),o(": calculated/input matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_wp"),o(": hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_awc"),o(": total amount of water available for vegetation/transpiration")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_fc"),o(": total amount of water in the soil at field capacity")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_α"),o(": alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_fc"),o(": moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_sat"),o(": moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_wp"),o(": moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_fc"),o(": matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_sat"),o(": matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_wp"),o(": matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.k_fc"),o(": hydraulic conductivity of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_sat"),o(": hydraulic conductivity of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.k_wp"),o(": hydraulic conductivity of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_layer_thickness"),o(": thickness of each soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_awc"),o(": total amount of water available for vegetation/transpiration")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_fc"),o(": total amount of water in the soil at field capacity")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_wp"),o(": total amount of water in the soil at wiliting point")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_α"),o(": alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_fc"),o(": moisture content of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_sat"),o(": moisture content of soil at saturation (porosity) per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.θ_wp"),o(": moisture content of soil at wilting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_fc"),o(": matric potential of soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_sat"),o(": matric potential of soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.ψ_wp"),o(": matric potential of soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])])])],-1)),n[3985]||(n[3985]=l("p",null,[l("code",null,"compute, update"),o(" methods are not defined")],-1)),n[3986]||(n[3986]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"soilWBase_uniform.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[3987]||(n[3987]=l("hr",null,null,-1)),n[3988]||(n[3988]=l("p",null,[l("strong",null,"Extended help")],-1)),n[3989]||(n[3989]=l("p",null,[l("em",null,"References")],-1)),n[3990]||(n[3990]=l("p",null,[l("em",null,"Versions")],-1)),n[3991]||(n[3991]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]: clean up & consistency")]),l("li",null,[l("p",null,"1.1 on 03.12.2019 [skoirala | @dr-ko]: handling potentail vertical distribution of soil texture")])],-1)),n[3992]||(n[3992]=l("p",null,[l("em",null,"Created by")],-1)),n[3993]||(n[3993]=l("ul",null,[l("li",null,[l("p",null,"ncarvalhais")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1))])]),_:1})]),_:1})]),n[4696]||(n[4696]=l("hr",null,null,-1)),n[4697]||(n[4697]=l("h3",{id:"sublimation",tabindex:"-1"},[o("sublimation "),l("a",{class:"header-anchor",href:"#sublimation","aria-label":'Permalink to "sublimation {#sublimation}"'},"​")],-1)),l("details",Qi,[l("summary",null,[n[3995]||(n[3995]=l("a",{id:"Sindbad.Models.sublimation",href:"#Sindbad.Models.sublimation"},[l("span",{class:"jlbinding"},"Sindbad.Models.sublimation")],-1)),n[3996]||(n[3996]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[3997]||(n[3997]=u("",4))]),l("details",Yi,[n[4028]||(n[4028]=l("summary",null,"sublimation approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"sublimation_GLEAM"},{default:i(()=>[l("details",Xi,[l("summary",null,[n[3998]||(n[3998]=l("a",{id:"Sindbad.Models.sublimation_GLEAM",href:"#Sindbad.Models.sublimation_GLEAM"},[l("span",{class:"jlbinding"},"Sindbad.Models.sublimation_GLEAM")],-1)),n[3999]||(n[3999]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4e3]||(n[4e3]=l("p",null,"Sublimation using the Priestley-Taylor term following the GLEAM approach.",-1)),n[4001]||(n[4001]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4002]||(n[4002]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"α"),o(": 0.95 ∈ [0.0, 3.0] => Priestley Taylor Coefficient for Sublimation (units: "),l("code",null,"none"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"deg_to_k"),o(": 273.15 ∈ [-Inf, Inf] => degree to Kelvin conversion (units: "),l("code",null,"none"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"Δ_1"),o(": 5723.265 ∈ [-Inf, Inf] => first parameter of Δ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"Δ_2"),o(": 3.53068 ∈ [-Inf, Inf] => second parameter of Δ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"Δ_3"),o(": 0.00728332 ∈ [-Inf, Inf] => third parameter of Δ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"Δ_4"),o(": 9.550426 ∈ [-Inf, Inf] => fourth parameter of Δ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"pa_to_kpa"),o(": 0.001 ∈ [-Inf, Inf] => pascal to kilopascal conversion (units: "),l("code",null,"none"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"λ_1"),o(": 46782.5 ∈ [-Inf, Inf] => first parameter of λ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"λ_2"),o(": 35.8925 ∈ [-Inf, Inf] => second parameter of λ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"λ_3"),o(": 0.07414 ∈ [-Inf, Inf] => third parameter of λ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"λ_4"),o(": 541.5 ∈ [-Inf, Inf] => fourth parameter of λ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"λ_5"),o(": 123.75 ∈ [-Inf, Inf] => fifth parameter of λ from Murphy & Koop "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"2005")])]),l("li",null,[l("p",null,[l("code",null,"j_to_mj"),o(": 1.0e-6 ∈ [-Inf, Inf] => joule to megajoule conversion (units: "),l("code",null,"none"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"g_to_kg"),o(": 0.001 ∈ [-Inf, Inf] => joule to megajoule conversion (units: "),l("code",null,"none"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"mol_mass_water"),o(": 18.01528 ∈ [-Inf, Inf] => molecular mass of water (units: "),l("code",null,"gram"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"sp_heat_air"),o(": 0.001 ∈ [-Inf, Inf] => specific heat of air (units: "),l("code",null,"MJ/kg/K"),o(" @ "),l("code",null,"all"),o(" timescales)")])]),l("li",null,[l("p",null,[l("code",null,"γ_1"),o(": 0.001 ∈ [-Inf, Inf] => first parameter of γ from Brunt "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"1952")])]),l("li",null,[l("p",null,[l("code",null,"γ_2"),o(": 0.622 ∈ [-Inf, Inf] => second parameter of γ from Brunt "),l("a",{href:"units:%20%60none%60%20@%20%60all%60%20timescales",target:"_blank",rel:"noreferrer"},"1952")])])])])],-1)),n[4003]||(n[4003]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4004]||(n[4004]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4005]||(n[4005]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"forcing.f_psurf_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_psurf_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_rn"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_rn)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"forcing.f_airT_day"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_airT_day)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_snow"),o(": fractional coverage of grid with snow")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.t_two"),o(": a type stable 2")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.sublimation"),o(": sublimation of the snow")])]),l("li",null,[l("p",null,[l("code",null,"sublimation.PTtermSub"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:sublimation, :PTtermSub)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])])])])],-1)),n[4006]||(n[4006]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4007]||(n[4007]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"sublimation_GLEAM.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4008]||(n[4008]=l("hr",null,null,-1)),n[4009]||(n[4009]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4010]||(n[4010]=l("p",null,[l("em",null,"References")],-1)),n[4011]||(n[4011]=l("ul",null,[l("li",null,[l("p",null,"Miralles; D. G.; De Jeu; R. A. M.; Gash; J. H.; Holmes; T. R. H. & Dolman, A. J. (2011). An application of GLEAM to estimating global evaporation. Hydrology & Earth System Sciences Discussions, 8[1].")]),l("li",null,[l("p",null,[o("Murphy, D. M., & Koop, T. (2005). Review of the vapour pressures of ice and supercooled water for atmospheric applications. Quarterly Journal of the Royal Meteorological Society: A journal of the atmospheric sciences, applied meteorology and physical oceanography, 131(608), 1539-1565. "),l("a",{href:"https://patarnott.com/atms360/pdf_atms360/class2017/VaporPressureIce_SupercooledH20_Murphy.pdf",target:"_blank",rel:"noreferrer"},"https://patarnott.com/atms360/pdf_atms360/class2017/VaporPressureIce_SupercooledH20_Murphy.pdf")])])],-1)),n[4012]||(n[4012]=l("p",null,[l("em",null,"Versions")],-1)),n[4013]||(n[4013]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [ttraut]: cleaned up the code")],-1)),n[4014]||(n[4014]=l("p",null,[l("em",null,"Created by")],-1)),n[4015]||(n[4015]=l("ul",null,[l("li",null,"mjung")],-1))])]),_:1}),e(s,{label:"sublimation_none"},{default:i(()=>[l("details",$i,[l("summary",null,[n[4016]||(n[4016]=l("a",{id:"Sindbad.Models.sublimation_none",href:"#Sindbad.Models.sublimation_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.sublimation_none")],-1)),n[4017]||(n[4017]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4018]||(n[4018]=l("p",null,"Sets snow sublimation to 0.",-1)),n[4019]||(n[4019]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4020]||(n[4020]=l("ul",null,[l("li",null,"None")],-1)),n[4021]||(n[4021]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4022]||(n[4022]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4023]||(n[4023]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.sublimation"),o(": sublimation of the snow")])])])],-1)),n[4024]||(n[4024]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[4025]||(n[4025]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"sublimation_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4026]||(n[4026]=l("hr",null,null,-1)),n[4027]||(n[4027]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4698]||(n[4698]=l("hr",null,null,-1)),n[4699]||(n[4699]=l("h3",{id:"transpiration",tabindex:"-1"},[o("transpiration "),l("a",{class:"header-anchor",href:"#transpiration","aria-label":'Permalink to "transpiration {#transpiration}"'},"​")],-1)),l("details",hi,[l("summary",null,[n[4029]||(n[4029]=l("a",{id:"Sindbad.Models.transpiration",href:"#Sindbad.Models.transpiration"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpiration")],-1)),n[4030]||(n[4030]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4031]||(n[4031]=u("",4))]),l("details",_i,[n[4081]||(n[4081]=l("summary",null,"transpiration approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"transpiration_coupled"},{default:i(()=>[l("details",ls,[l("summary",null,[n[4032]||(n[4032]=l("a",{id:"Sindbad.Models.transpiration_coupled",href:"#Sindbad.Models.transpiration_coupled"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpiration_coupled")],-1)),n[4033]||(n[4033]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4034]||(n[4034]=l("p",null,"Transpiration as a function of GPP and WUE.",-1)),n[4035]||(n[4035]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4036]||(n[4036]=l("ul",null,[l("li",null,"None")],-1)),n[4037]||(n[4037]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4038]||(n[4038]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4039]||(n[4039]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.gpp"),o(": gross primary prorDcutivity")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.WUE"),o(": water use efficiency of the ecosystem")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])])])],-1)),n[4040]||(n[4040]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4041]||(n[4041]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpiration_coupled.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4042]||(n[4042]=l("hr",null,null,-1)),n[4043]||(n[4043]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4044]||(n[4044]=l("p",null,[l("em",null,"References")],-1)),n[4045]||(n[4045]=l("p",null,[l("em",null,"Versions")],-1)),n[4046]||(n[4046]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4047]||(n[4047]=l("p",null,[l("em",null,"Created by")],-1)),n[4048]||(n[4048]=l("ul",null,[l("li",null,[l("p",null,"mjung")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[4049]||(n[4049]=l("p",null,[l("em",null,"Notes")],-1))])]),_:1}),e(s,{label:"transpiration_demandSupply"},{default:i(()=>[l("details",ns,[l("summary",null,[n[4050]||(n[4050]=l("a",{id:"Sindbad.Models.transpiration_demandSupply",href:"#Sindbad.Models.transpiration_demandSupply"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpiration_demandSupply")],-1)),n[4051]||(n[4051]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4052]||(n[4052]=l("p",null,"Transpiration as the minimum of supply and demand.",-1)),n[4053]||(n[4053]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4054]||(n[4054]=l("ul",null,[l("li",null,"None")],-1)),n[4055]||(n[4055]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4056]||(n[4056]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4057]||(n[4057]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.transpiration_demand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :transpiration_demand)"),o(" for information on how to add the variable to the catalog.")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])])])],-1)),n[4058]||(n[4058]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4059]||(n[4059]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpiration_demandSupply.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4060]||(n[4060]=l("hr",null,null,-1)),n[4061]||(n[4061]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4062]||(n[4062]=l("p",null,[l("em",null,"References")],-1)),n[4063]||(n[4063]=l("p",null,[l("em",null,"Versions")],-1)),n[4064]||(n[4064]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4065]||(n[4065]=l("p",null,[l("em",null,"Created by")],-1)),n[4066]||(n[4066]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[4067]||(n[4067]=l("p",null,[l("em",null,"Notes")],-1)),n[4068]||(n[4068]=l("ul",null,[l("li",null,"ignores biological limitation of transpiration demand")],-1))])]),_:1}),e(s,{label:"transpiration_none"},{default:i(()=>[l("details",os,[l("summary",null,[n[4069]||(n[4069]=l("a",{id:"Sindbad.Models.transpiration_none",href:"#Sindbad.Models.transpiration_none"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpiration_none")],-1)),n[4070]||(n[4070]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4071]||(n[4071]=l("p",null,"Sets transpiration to 0.",-1)),n[4072]||(n[4072]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4073]||(n[4073]=l("ul",null,[l("li",null,"None")],-1)),n[4074]||(n[4074]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4075]||(n[4075]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4076]||(n[4076]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.transpiration"),o(": transpiration")])])])],-1)),n[4077]||(n[4077]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[4078]||(n[4078]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpiration_none.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4079]||(n[4079]=l("hr",null,null,-1)),n[4080]||(n[4080]=l("p",null,[l("strong",null,"Extended help")],-1))])]),_:1})]),_:1})]),n[4700]||(n[4700]=l("hr",null,null,-1)),n[4701]||(n[4701]=l("h3",{id:"transpirationDemand",tabindex:"-1"},[o("transpirationDemand "),l("a",{class:"header-anchor",href:"#transpirationDemand","aria-label":'Permalink to "transpirationDemand {#transpirationDemand}"'},"​")],-1)),l("details",es,[l("summary",null,[n[4082]||(n[4082]=l("a",{id:"Sindbad.Models.transpirationDemand",href:"#Sindbad.Models.transpirationDemand"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationDemand")],-1)),n[4083]||(n[4083]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4084]||(n[4084]=u("",4))]),l("details",ts,[n[4159]||(n[4159]=l("summary",null,"transpirationDemand approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"transpirationDemand_CASA"},{default:i(()=>[l("details",is,[l("summary",null,[n[4085]||(n[4085]=l("a",{id:"Sindbad.Models.transpirationDemand_CASA",href:"#Sindbad.Models.transpirationDemand_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationDemand_CASA")],-1)),n[4086]||(n[4086]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4087]||(n[4087]=l("p",null,"Demand-limited transpiration as a function of volumetric soil content and soil properties, as in the CASA model.",-1)),n[4088]||(n[4088]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4089]||(n[4089]=l("ul",null,[l("li",null,"None")],-1)),n[4090]||(n[4090]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4091]||(n[4091]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4092]||(n[4092]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_awc"),o(": maximum amount of water available for vegetation/transpiration per soil layer (w_sat-_wp)")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_α"),o(": alpha parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.percolation"),o(": amount of moisture percolating to the top soil layer")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_demand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :transpiration_demand)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[4093]||(n[4093]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4094]||(n[4094]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationDemand_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4095]||(n[4095]=l("hr",null,null,-1)),n[4096]||(n[4096]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4097]||(n[4097]=l("p",null,[l("em",null,"References")],-1)),n[4098]||(n[4098]=l("p",null,[l("em",null,"Versions")],-1)),n[4099]||(n[4099]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: split the original transpiration_supply of CASA into demand supply: actual [minimum] is now just demandSupply approach of transpiration")],-1)),n[4100]||(n[4100]=l("p",null,[l("em",null,"Created by")],-1)),n[4101]||(n[4101]=l("ul",null,[l("li",null,[l("p",null,"ncarvalhais")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[4102]||(n[4102]=l("p",null,[l("em",null,"Notes")],-1)),n[4103]||(n[4103]=l("ul",null,[l("li",null,"The supply limit has non-linear relationship with moisture state over the root zone")],-1))])]),_:1}),e(s,{label:"transpirationDemand_PET"},{default:i(()=>[l("details",ss,[l("summary",null,[n[4104]||(n[4104]=l("a",{id:"Sindbad.Models.transpirationDemand_PET",href:"#Sindbad.Models.transpirationDemand_PET"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationDemand_PET")],-1)),n[4105]||(n[4105]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4106]||(n[4106]=l("p",null,"Demand-limited transpiration as a function of PET and a vegetation parameter.",-1)),n[4107]||(n[4107]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4108]||(n[4108]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"α"),o(": 1.0 ∈ [0.2, 3.0] => vegetation specific α coefficient of Priestley Taylor PET ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4109]||(n[4109]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4110]||(n[4110]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4111]||(n[4111]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_demand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :transpiration_demand)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[4112]||(n[4112]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4113]||(n[4113]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationDemand_PET.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4114]||(n[4114]=l("hr",null,null,-1)),n[4115]||(n[4115]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4116]||(n[4116]=l("p",null,[l("em",null,"References")],-1)),n[4117]||(n[4117]=l("p",null,[l("em",null,"Versions")],-1)),n[4118]||(n[4118]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4119]||(n[4119]=l("p",null,[l("em",null,"Created by")],-1)),n[4120]||(n[4120]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"transpirationDemand_PETfAPAR"},{default:i(()=>[l("details",us,[l("summary",null,[n[4121]||(n[4121]=l("a",{id:"Sindbad.Models.transpirationDemand_PETfAPAR",href:"#Sindbad.Models.transpirationDemand_PETfAPAR"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationDemand_PETfAPAR")],-1)),n[4122]||(n[4122]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4123]||(n[4123]=l("p",null,"Demand-limited transpiration as a function of PET and fAPAR.",-1)),n[4124]||(n[4124]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4125]||(n[4125]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"α"),o(": 1.0 ∈ [0.2, 3.0] => vegetation specific α coefficient of Priestley Taylor PET ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4126]||(n[4126]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4127]||(n[4127]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4128]||(n[4128]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_demand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :transpiration_demand)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[4129]||(n[4129]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4130]||(n[4130]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationDemand_PETfAPAR.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4131]||(n[4131]=l("hr",null,null,-1)),n[4132]||(n[4132]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4133]||(n[4133]=l("p",null,[l("em",null,"References")],-1)),n[4134]||(n[4134]=l("p",null,[l("em",null,"Versions")],-1)),n[4135]||(n[4135]=l("ul",null,[l("li",null,"1.0 on 30.04.2020 [skoirala | @dr-ko]")],-1)),n[4136]||(n[4136]=l("p",null,[l("em",null,"Created by")],-1)),n[4137]||(n[4137]=l("ul",null,[l("li",null,"sbesnard; skoirala; ncarvalhais")],-1)),n[4138]||(n[4138]=l("p",null,[l("em",null,"Notes")],-1)),n[4139]||(n[4139]=l("ul",null,[l("li",null,"Assumes that the transpiration demand scales with vegetated fraction")],-1))])]),_:1}),e(s,{label:"transpirationDemand_PETvegFraction"},{default:i(()=>[l("details",rs,[l("summary",null,[n[4140]||(n[4140]=l("a",{id:"Sindbad.Models.transpirationDemand_PETvegFraction",href:"#Sindbad.Models.transpirationDemand_PETvegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationDemand_PETvegFraction")],-1)),n[4141]||(n[4141]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4142]||(n[4142]=l("p",null,"Demand-limited transpiration as a function of PET, a vegetation parameter, and vegetation fraction.",-1)),n[4143]||(n[4143]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4144]||(n[4144]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"α"),o(": 1.0 ∈ [0.2, 3.0] => vegetation specific α coefficient of Priestley Taylor PET ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4145]||(n[4145]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4146]||(n[4146]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4147]||(n[4147]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.PET"),o(": potential evapotranspiration")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_demand"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:diagnostics, :transpiration_demand)"),o(" for information on how to add the variable to the catalog.")])])])],-1)),n[4148]||(n[4148]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4149]||(n[4149]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationDemand_PETvegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4150]||(n[4150]=l("hr",null,null,-1)),n[4151]||(n[4151]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4152]||(n[4152]=l("p",null,[l("em",null,"References")],-1)),n[4153]||(n[4153]=l("p",null,[l("em",null,"Versions")],-1)),n[4154]||(n[4154]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4155]||(n[4155]=l("p",null,[l("em",null,"Created by")],-1)),n[4156]||(n[4156]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[4157]||(n[4157]=l("p",null,[l("em",null,"Notes")],-1)),n[4158]||(n[4158]=l("ul",null,[l("li",null,"Assumes that the transpiration demand scales with vegetated fraction")],-1))])]),_:1})]),_:1})]),n[4702]||(n[4702]=l("hr",null,null,-1)),n[4703]||(n[4703]=l("h3",{id:"transpirationSupply",tabindex:"-1"},[o("transpirationSupply "),l("a",{class:"header-anchor",href:"#transpirationSupply","aria-label":'Permalink to "transpirationSupply {#transpirationSupply}"'},"​")],-1)),l("details",as,[l("summary",null,[n[4160]||(n[4160]=l("a",{id:"Sindbad.Models.transpirationSupply",href:"#Sindbad.Models.transpirationSupply"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationSupply")],-1)),n[4161]||(n[4161]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4162]||(n[4162]=u("",4))]),l("details",ds,[n[4236]||(n[4236]=l("summary",null,"transpirationSupply approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"transpirationSupply_CASA"},{default:i(()=>[l("details",ps,[l("summary",null,[n[4163]||(n[4163]=l("a",{id:"Sindbad.Models.transpirationSupply_CASA",href:"#Sindbad.Models.transpirationSupply_CASA"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationSupply_CASA")],-1)),n[4164]||(n[4164]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4165]||(n[4165]=l("p",null,"Supply-limited transpiration as a function of volumetric soil content and soil properties, as in the CASA model.",-1)),n[4166]||(n[4166]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4167]||(n[4167]=l("ul",null,[l("li",null,"None")],-1)),n[4168]||(n[4168]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4169]||(n[4169]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4170]||(n[4170]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])])])],-1)),n[4171]||(n[4171]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4172]||(n[4172]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationSupply_CASA.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4173]||(n[4173]=l("hr",null,null,-1)),n[4174]||(n[4174]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4175]||(n[4175]=l("p",null,[l("em",null,"References")],-1)),n[4176]||(n[4176]=l("p",null,[l("em",null,"Versions")],-1)),n[4177]||(n[4177]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]: split the original transpiration_supply of CASA into demand supply: actual [minimum] is now just demSup approach of transpiration")],-1)),n[4178]||(n[4178]=l("p",null,[l("em",null,"Created by")],-1)),n[4179]||(n[4179]=l("ul",null,[l("li",null,[l("p",null,"ncarvalhais")]),l("li",null,[l("p",null,"skoirala | @dr-ko")])],-1)),n[4180]||(n[4180]=l("p",null,[l("em",null,"Notes")],-1)),n[4181]||(n[4181]=l("ul",null,[l("li",null,"The supply limit has non-linear relationship with moisture state over the root zone")],-1))])]),_:1}),e(s,{label:"transpirationSupply_Federer1982"},{default:i(()=>[l("details",fs,[l("summary",null,[n[4182]||(n[4182]=l("a",{id:"Sindbad.Models.transpirationSupply_Federer1982",href:"#Sindbad.Models.transpirationSupply_Federer1982"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationSupply_Federer1982")],-1)),n[4183]||(n[4183]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4184]||(n[4184]=l("p",null,"Supply-limited transpiration as a function of a maximum rate parameter and available water, following Federer (1982).",-1)),n[4185]||(n[4185]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4186]||(n[4186]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"max_t_loss"),o(": 5.0 ∈ [0.1, 20.0] => Maximum rate of transpiration in mm/day (units: "),l("code",null,"mm/day"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4187]||(n[4187]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4188]||(n[4188]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4189]||(n[4189]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.∑w_sat"),o(": total amount of water in the soil at saturation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])])])],-1)),n[4190]||(n[4190]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4191]||(n[4191]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationSupply_Federer1982.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4192]||(n[4192]=l("hr",null,null,-1)),n[4193]||(n[4193]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4194]||(n[4194]=l("p",null,[l("em",null,"References")],-1)),n[4195]||(n[4195]=l("p",null,[l("em",null,"Versions")],-1)),n[4196]||(n[4196]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4197]||(n[4197]=l("p",null,[l("em",null,"Created by")],-1)),n[4198]||(n[4198]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"transpirationSupply_wAWC"},{default:i(()=>[l("details",gs,[l("summary",null,[n[4199]||(n[4199]=l("a",{id:"Sindbad.Models.transpirationSupply_wAWC",href:"#Sindbad.Models.transpirationSupply_wAWC"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationSupply_wAWC")],-1)),n[4200]||(n[4200]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4201]||(n[4201]=l("p",null,"Supply-limited transpiration as the minimum of the fraction of total available water capacity and available moisture.",-1)),n[4202]||(n[4202]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4203]||(n[4203]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_transpiration"),o(": 0.99 ∈ [0.002, 1.0] => fraction of total maximum available water that can be transpired ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4204]||(n[4204]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4205]||(n[4205]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4206]||(n[4206]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])])])],-1)),n[4207]||(n[4207]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4208]||(n[4208]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationSupply_wAWC.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4209]||(n[4209]=l("hr",null,null,-1)),n[4210]||(n[4210]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4211]||(n[4211]=l("p",null,[l("em",null,"References")],-1)),n[4212]||(n[4212]=l("ul",null,[l("li",null,"Teuling; 2007 | 2009: Time scales.#")],-1)),n[4213]||(n[4213]=l("p",null,[l("em",null,"Versions")],-1)),n[4214]||(n[4214]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4215]||(n[4215]=l("p",null,[l("em",null,"Created by")],-1)),n[4216]||(n[4216]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"transpirationSupply_wAWCvegFraction"},{default:i(()=>[l("details",ms,[l("summary",null,[n[4217]||(n[4217]=l("a",{id:"Sindbad.Models.transpirationSupply_wAWCvegFraction",href:"#Sindbad.Models.transpirationSupply_wAWCvegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.transpirationSupply_wAWCvegFraction")],-1)),n[4218]||(n[4218]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4219]||(n[4219]=l("p",null,"Supply-limited transpiration as the minimum of the fraction of total available water capacity and available moisture, scaled by vegetated fractions.",-1)),n[4220]||(n[4220]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4221]||(n[4221]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"k_transpiration"),o(": 1.0 ∈ [0.02, 1.0] => fraction of total maximum available water that can be transpired ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4222]||(n[4222]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4223]||(n[4223]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4224]||(n[4224]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.transpiration_supply"),o(": total amount of water available in soil for transpiration")])])])],-1)),n[4225]||(n[4225]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4226]||(n[4226]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"transpirationSupply_wAWCvegFraction.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4227]||(n[4227]=l("hr",null,null,-1)),n[4228]||(n[4228]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4229]||(n[4229]=l("p",null,[l("em",null,"References")],-1)),n[4230]||(n[4230]=l("p",null,[l("em",null,"Versions")],-1)),n[4231]||(n[4231]=l("ul",null,[l("li",null,"1.0 on 22.11.2019 [skoirala | @dr-ko]")],-1)),n[4232]||(n[4232]=l("p",null,[l("em",null,"Created by")],-1)),n[4233]||(n[4233]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1)),n[4234]||(n[4234]=l("p",null,[l("em",null,"Notes")],-1)),n[4235]||(n[4235]=l("ul",null,[l("li",null,"Assumes that the transpiration supply scales with vegetated fraction")],-1))])]),_:1})]),_:1})]),n[4704]||(n[4704]=l("hr",null,null,-1)),n[4705]||(n[4705]=l("h3",{id:"treeFraction",tabindex:"-1"},[o("treeFraction "),l("a",{class:"header-anchor",href:"#treeFraction","aria-label":'Permalink to "treeFraction {#treeFraction}"'},"​")],-1)),l("details",bs,[l("summary",null,[n[4237]||(n[4237]=l("a",{id:"Sindbad.Models.treeFraction",href:"#Sindbad.Models.treeFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.treeFraction")],-1)),n[4238]||(n[4238]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4239]||(n[4239]=u("",4))]),l("details",ys,[n[4274]||(n[4274]=l("summary",null,"treeFraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"treeFraction_constant"},{default:i(()=>[l("details",cs,[l("summary",null,[n[4240]||(n[4240]=l("a",{id:"Sindbad.Models.treeFraction_constant",href:"#Sindbad.Models.treeFraction_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.treeFraction_constant")],-1)),n[4241]||(n[4241]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4242]||(n[4242]=l("p",null,"Sets tree cover fraction as a constant value.",-1)),n[4243]||(n[4243]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4244]||(n[4244]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_frac_tree"),o(": 1.0 ∈ [0.3, 1.0] => Tree fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4245]||(n[4245]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4246]||(n[4246]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[4247]||(n[4247]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_tree"),o(": fractional coverage of grid with trees")])])])],-1)),n[4248]||(n[4248]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[4249]||(n[4249]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"treeFraction_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4250]||(n[4250]=l("hr",null,null,-1)),n[4251]||(n[4251]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4252]||(n[4252]=l("p",null,[l("em",null,"References")],-1)),n[4253]||(n[4253]=l("p",null,[l("em",null,"Versions")],-1)),n[4254]||(n[4254]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[4255]||(n[4255]=l("p",null,[l("em",null,"Created by")],-1)),n[4256]||(n[4256]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"treeFraction_forcing"},{default:i(()=>[l("details",vs,[l("summary",null,[n[4257]||(n[4257]=l("a",{id:"Sindbad.Models.treeFraction_forcing",href:"#Sindbad.Models.treeFraction_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.treeFraction_forcing")],-1)),n[4258]||(n[4258]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4259]||(n[4259]=l("p",null,"Gets tree cover fraction from forcing data.",-1)),n[4260]||(n[4260]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4261]||(n[4261]=l("ul",null,[l("li",null,"None")],-1)),n[4262]||(n[4262]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4263]||(n[4263]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4264]||(n[4264]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_tree_frac"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_tree_frac)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_tree"),o(": fractional coverage of grid with trees")])])])],-1)),n[4265]||(n[4265]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4266]||(n[4266]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"treeFraction_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4267]||(n[4267]=l("hr",null,null,-1)),n[4268]||(n[4268]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4269]||(n[4269]=l("p",null,[l("em",null,"References")],-1)),n[4270]||(n[4270]=l("p",null,[l("em",null,"Versions")],-1)),n[4271]||(n[4271]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[4272]||(n[4272]=l("p",null,[l("em",null,"Created by")],-1)),n[4273]||(n[4273]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4706]||(n[4706]=l("hr",null,null,-1)),n[4707]||(n[4707]=l("h3",{id:"vegAvailableWater",tabindex:"-1"},[o("vegAvailableWater "),l("a",{class:"header-anchor",href:"#vegAvailableWater","aria-label":'Permalink to "vegAvailableWater {#vegAvailableWater}"'},"​")],-1)),l("details",ks,[l("summary",null,[n[4275]||(n[4275]=l("a",{id:"Sindbad.Models.vegAvailableWater",href:"#Sindbad.Models.vegAvailableWater"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegAvailableWater")],-1)),n[4276]||(n[4276]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4277]||(n[4277]=u("",4))]),l("details",Ss,[n[4316]||(n[4316]=l("summary",null,"vegAvailableWater approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"vegAvailableWater_rootWaterEfficiency"},{default:i(()=>[l("details",ws,[l("summary",null,[n[4278]||(n[4278]=l("a",{id:"Sindbad.Models.vegAvailableWater_rootWaterEfficiency",href:"#Sindbad.Models.vegAvailableWater_rootWaterEfficiency"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegAvailableWater_rootWaterEfficiency")],-1)),n[4279]||(n[4279]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4280]||(n[4280]=l("p",null,"PAW as a function of soil moisture and root water extraction efficiency.",-1)),n[4281]||(n[4281]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4282]||(n[4282]=l("ul",null,[l("li",null,"None")],-1)),n[4283]||(n[4283]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4284]||(n[4284]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4285]||(n[4285]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])])])],-1)),n[4286]||(n[4286]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4287]||(n[4287]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])])])],-1)),n[4288]||(n[4288]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[4289]||(n[4289]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegAvailableWater_rootWaterEfficiency.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4290]||(n[4290]=l("hr",null,null,-1)),n[4291]||(n[4291]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4292]||(n[4292]=l("p",null,[l("em",null,"References")],-1)),n[4293]||(n[4293]=l("p",null,[l("em",null,"Versions")],-1)),n[4294]||(n[4294]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[4295]||(n[4295]=l("p",null,[l("em",null,"Created by")],-1)),n[4296]||(n[4296]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"vegAvailableWater_sigmoid"},{default:i(()=>[l("details",Ts,[l("summary",null,[n[4297]||(n[4297]=l("a",{id:"Sindbad.Models.vegAvailableWater_sigmoid",href:"#Sindbad.Models.vegAvailableWater_sigmoid"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegAvailableWater_sigmoid")],-1)),n[4298]||(n[4298]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4299]||(n[4299]=l("p",null,"PAW using a sigmoid function of soil moisture.",-1)),n[4300]||(n[4300]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4301]||(n[4301]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"exp_factor"),o(": 1.0 ∈ [0.02, 3.0] => multiplier of B factor of exponential rate ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4302]||(n[4302]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4303]||(n[4303]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4304]||(n[4304]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.θ_dos"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :θ_dos)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.θ_fc_dos"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :θ_fc_dos)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"states.soilW_stress"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :soilW_stress)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.max_water"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :max_water)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[4305]||(n[4305]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4306]||(n[4306]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"properties.w_wp"),o(": amount of water in the soil at wiliting point per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_fc"),o(": amount of water in the soil at field capacity per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.w_sat"),o(": amount of water in the soil at saturation per layer")])]),l("li",null,[l("p",null,[l("code",null,"properties.soil_β"),o(": beta parameter of soil per layer")])]),l("li",null,[l("p",null,[l("code",null,"diagnostics.root_water_efficiency"),o(": a efficiency like number that indicates the ease/fraction of soil water that can extracted by the root per layer")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.θ_dos"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :θ_dos)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.θ_fc_dos"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :θ_fc_dos)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"states.soilW_stress"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :soilW_stress)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"states.max_water"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :max_water)"),o(" for information on how to add the variable to the catalog.")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"states.PAW"),o(": amount of water available for transpiration per soil layer")])]),l("li",null,[l("p",null,[l("code",null,"states.soilW_stress"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :soilW_stress)"),o(" for information on how to add the variable to the catalog.")])])])])],-1)),n[4307]||(n[4307]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[4308]||(n[4308]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegAvailableWater_sigmoid.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4309]||(n[4309]=l("hr",null,null,-1)),n[4310]||(n[4310]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4311]||(n[4311]=l("p",null,[l("em",null,"References")],-1)),n[4312]||(n[4312]=l("p",null,[l("em",null,"Versions")],-1)),n[4313]||(n[4313]=l("ul",null,[l("li",null,"1.0 on 21.11.2019")],-1)),n[4314]||(n[4314]=l("p",null,[l("em",null,"Created by")],-1)),n[4315]||(n[4315]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4708]||(n[4708]=l("hr",null,null,-1)),n[4709]||(n[4709]=l("h3",{id:"vegFraction",tabindex:"-1"},[o("vegFraction "),l("a",{class:"header-anchor",href:"#vegFraction","aria-label":'Permalink to "vegFraction {#vegFraction}"'},"​")],-1)),l("details",js,[l("summary",null,[n[4317]||(n[4317]=l("a",{id:"Sindbad.Models.vegFraction",href:"#Sindbad.Models.vegFraction"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction")],-1)),n[4318]||(n[4318]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4319]||(n[4319]=u("",4))]),l("details",Es,[n[4439]||(n[4439]=l("summary",null,"vegFraction approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"vegFraction_constant"},{default:i(()=>[l("details",xs,[l("summary",null,[n[4320]||(n[4320]=l("a",{id:"Sindbad.Models.vegFraction_constant",href:"#Sindbad.Models.vegFraction_constant"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_constant")],-1)),n[4321]||(n[4321]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4322]||(n[4322]=l("p",null,"Sets vegetation fraction as a constant value.",-1)),n[4323]||(n[4323]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4324]||(n[4324]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"constant_frac_vegetation"),o(": 0.5 ∈ [0.3, 0.9] => Vegetation fraction ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4325]||(n[4325]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4326]||(n[4326]=l("p",null,[l("code",null,"precompute"),o(":")],-1)),n[4327]||(n[4327]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4328]||(n[4328]=l("p",null,[l("code",null,"define, compute, update"),o(" methods are not defined")],-1)),n[4329]||(n[4329]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_constant.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4330]||(n[4330]=l("hr",null,null,-1)),n[4331]||(n[4331]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4332]||(n[4332]=l("p",null,[l("em",null,"References")],-1)),n[4333]||(n[4333]=l("p",null,[l("em",null,"Versions")],-1)),n[4334]||(n[4334]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]: cleaned up the code")],-1)),n[4335]||(n[4335]=l("p",null,[l("em",null,"Created by")],-1)),n[4336]||(n[4336]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"vegFraction_forcing"},{default:i(()=>[l("details",Cs,[l("summary",null,[n[4337]||(n[4337]=l("a",{id:"Sindbad.Models.vegFraction_forcing",href:"#Sindbad.Models.vegFraction_forcing"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_forcing")],-1)),n[4338]||(n[4338]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4339]||(n[4339]=l("p",null,"Gets vegetation fraction from forcing data.",-1)),n[4340]||(n[4340]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4341]||(n[4341]=l("ul",null,[l("li",null,"None")],-1)),n[4342]||(n[4342]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4343]||(n[4343]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4344]||(n[4344]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"forcing.f_frac_vegetation"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:forcing, :f_frac_vegetation)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4345]||(n[4345]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4346]||(n[4346]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_forcing.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4347]||(n[4347]=l("hr",null,null,-1)),n[4348]||(n[4348]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4349]||(n[4349]=l("p",null,[l("em",null,"References")],-1)),n[4350]||(n[4350]=l("p",null,[l("em",null,"Versions")],-1)),n[4351]||(n[4351]=l("ul",null,[l("li",null,"1.0 on 11.11.2019 [skoirala | @dr-ko]")],-1)),n[4352]||(n[4352]=l("p",null,[l("em",null,"Created by")],-1)),n[4353]||(n[4353]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"vegFraction_scaledEVI"},{default:i(()=>[l("details",Ms,[l("summary",null,[n[4354]||(n[4354]=l("a",{id:"Sindbad.Models.vegFraction_scaledEVI",href:"#Sindbad.Models.vegFraction_scaledEVI"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_scaledEVI")],-1)),n[4355]||(n[4355]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4356]||(n[4356]=l("p",null,"Vegetation fraction as a linear function of EVI.",-1)),n[4357]||(n[4357]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4358]||(n[4358]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"EVIscale"),o(": 1.0 ∈ [0.0, 5.0] => scalar for EVI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4359]||(n[4359]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4360]||(n[4360]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4361]||(n[4361]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.EVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :EVI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4362]||(n[4362]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4363]||(n[4363]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_scaledEVI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4364]||(n[4364]=l("hr",null,null,-1)),n[4365]||(n[4365]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4366]||(n[4366]=l("p",null,[l("em",null,"References")],-1)),n[4367]||(n[4367]=l("p",null,[l("em",null,"Versions")],-1)),n[4368]||(n[4368]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 06.02.2020 [ttraut]")]),l("li",null,[l("p",null,"1.1 on 05.03.2020 [ttraut]: apply the min function")])],-1)),n[4369]||(n[4369]=l("p",null,[l("em",null,"Created by")],-1)),n[4370]||(n[4370]=l("ul",null,[l("li",null,"ttraut")],-1))])]),_:1}),e(s,{label:"vegFraction_scaledLAI"},{default:i(()=>[l("details",Is,[l("summary",null,[n[4371]||(n[4371]=l("a",{id:"Sindbad.Models.vegFraction_scaledLAI",href:"#Sindbad.Models.vegFraction_scaledLAI"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_scaledLAI")],-1)),n[4372]||(n[4372]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4373]||(n[4373]=l("p",null,"Vegetation fraction as a linear function of LAI.",-1)),n[4374]||(n[4374]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4375]||(n[4375]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"LAIscale"),o(": 1.0 ∈ [0.0, 5.0] => scalar for LAI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4376]||(n[4376]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4377]||(n[4377]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4378]||(n[4378]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.LAI"),o(": leaf area index")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4379]||(n[4379]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4380]||(n[4380]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_scaledLAI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4381]||(n[4381]=l("hr",null,null,-1)),n[4382]||(n[4382]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4383]||(n[4383]=l("p",null,[l("em",null,"References")],-1)),n[4384]||(n[4384]=l("p",null,[l("em",null,"Versions")],-1)),n[4385]||(n[4385]=l("ul",null,[l("li",null,"1.1 on 24.10.2020 [ttraut]: new module")],-1)),n[4386]||(n[4386]=l("p",null,[l("em",null,"Created by")],-1)),n[4387]||(n[4387]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"vegFraction_scaledNDVI"},{default:i(()=>[l("details",As,[l("summary",null,[n[4388]||(n[4388]=l("a",{id:"Sindbad.Models.vegFraction_scaledNDVI",href:"#Sindbad.Models.vegFraction_scaledNDVI"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_scaledNDVI")],-1)),n[4389]||(n[4389]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4390]||(n[4390]=l("p",null,"Vegetation fraction as a linear function of NDVI.",-1)),n[4391]||(n[4391]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4392]||(n[4392]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"NDVIscale"),o(": 1.0 ∈ [0.0, 5.0] => scalar for NDVI ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4393]||(n[4393]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4394]||(n[4394]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4395]||(n[4395]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NDVI"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NDVI)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4396]||(n[4396]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4397]||(n[4397]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_scaledNDVI.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4398]||(n[4398]=l("hr",null,null,-1)),n[4399]||(n[4399]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4400]||(n[4400]=l("p",null,[l("em",null,"References")],-1)),n[4401]||(n[4401]=l("p",null,[l("em",null,"Versions")],-1)),n[4402]||(n[4402]=l("ul",null,[l("li",null,"1.1 on 29.04.2020 [sbesnard]: new module")],-1)),n[4403]||(n[4403]=l("p",null,[l("em",null,"Created by")],-1)),n[4404]||(n[4404]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"vegFraction_scaledNIRv"},{default:i(()=>[l("details",Ps,[l("summary",null,[n[4405]||(n[4405]=l("a",{id:"Sindbad.Models.vegFraction_scaledNIRv",href:"#Sindbad.Models.vegFraction_scaledNIRv"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_scaledNIRv")],-1)),n[4406]||(n[4406]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4407]||(n[4407]=l("p",null,"Vegetation fraction as a linear function of NIRv.",-1)),n[4408]||(n[4408]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4409]||(n[4409]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"NIRvscale"),o(": 1.0 ∈ [0.0, 5.0] => scalar for NIRv ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4410]||(n[4410]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4411]||(n[4411]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4412]||(n[4412]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.NIRv"),o(": No description available in "),l("code",null,"src/sindbadVariableCatalog.jl"),o(" catalog. Run "),l("code",null,"whatIs(:states, :NIRv)"),o(" for information on how to add the variable to the catalog.")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4413]||(n[4413]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4414]||(n[4414]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_scaledNIRv.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4415]||(n[4415]=l("hr",null,null,-1)),n[4416]||(n[4416]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4417]||(n[4417]=l("p",null,[l("em",null,"References")],-1)),n[4418]||(n[4418]=l("p",null,[l("em",null,"Versions")],-1)),n[4419]||(n[4419]=l("ul",null,[l("li",null,"1.1 on 29.04.2020 [sbesnard]: new module")],-1)),n[4420]||(n[4420]=l("p",null,[l("em",null,"Created by")],-1)),n[4421]||(n[4421]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1}),e(s,{label:"vegFraction_scaledfAPAR"},{default:i(()=>[l("details",Rs,[l("summary",null,[n[4422]||(n[4422]=l("a",{id:"Sindbad.Models.vegFraction_scaledfAPAR",href:"#Sindbad.Models.vegFraction_scaledfAPAR"},[l("span",{class:"jlbinding"},"Sindbad.Models.vegFraction_scaledfAPAR")],-1)),n[4423]||(n[4423]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4424]||(n[4424]=l("p",null,"Vegetation fraction as a linear function of fAPAR.",-1)),n[4425]||(n[4425]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4426]||(n[4426]=l("ul",null,[l("li",null,[l("strong",null,"Fields"),l("ul",null,[l("li",null,[l("code",null,"fAPAR_scalar"),o(": 10.0 ∈ [0.0, 20.0] => scalar for fAPAR ("),l("code",null,"unitless"),o(" @ "),l("code",null,"all"),o(" timescales)")])])])],-1)),n[4427]||(n[4427]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4428]||(n[4428]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4429]||(n[4429]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"states.fAPAR"),o(": fraction of absorbed photosynthetically active radiation")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"states.frac_vegetation"),o(": fractional coverage of grid with vegetation")])])])],-1)),n[4430]||(n[4430]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4431]||(n[4431]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"vegFraction_scaledfAPAR.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4432]||(n[4432]=l("hr",null,null,-1)),n[4433]||(n[4433]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4434]||(n[4434]=l("p",null,[l("em",null,"References")],-1)),n[4435]||(n[4435]=l("p",null,[l("em",null,"Versions")],-1)),n[4436]||(n[4436]=l("ul",null,[l("li",null,"1.1 on 24.10.2020 [ttraut]: new module")],-1)),n[4437]||(n[4437]=l("p",null,[l("em",null,"Created by")],-1)),n[4438]||(n[4438]=l("ul",null,[l("li",null,"sbesnard")],-1))])]),_:1})]),_:1})]),n[4710]||(n[4710]=l("hr",null,null,-1)),n[4711]||(n[4711]=l("h3",{id:"wCycle",tabindex:"-1"},[o("wCycle "),l("a",{class:"header-anchor",href:"#wCycle","aria-label":'Permalink to "wCycle {#wCycle}"'},"​")],-1)),l("details",Vs,[l("summary",null,[n[4440]||(n[4440]=l("a",{id:"Sindbad.Models.wCycle",href:"#Sindbad.Models.wCycle"},[l("span",{class:"jlbinding"},"Sindbad.Models.wCycle")],-1)),n[4441]||(n[4441]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4442]||(n[4442]=u("",4))]),l("details",Ws,[n[4479]||(n[4479]=l("summary",null,"wCycle approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"wCycle_combined"},{default:i(()=>[l("details",Ds,[l("summary",null,[n[4443]||(n[4443]=l("a",{id:"Sindbad.Models.wCycle_combined",href:"#Sindbad.Models.wCycle_combined"},[l("span",{class:"jlbinding"},"Sindbad.Models.wCycle_combined")],-1)),n[4444]||(n[4444]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4445]||(n[4445]=l("p",null,"computes the algebraic sum of storage and delta storage",-1)),n[4446]||(n[4446]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4447]||(n[4447]=l("ul",null,[l("li",null,"None")],-1)),n[4448]||(n[4448]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4449]||(n[4449]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4450]||(n[4450]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.ΔTWS"),o(": change in water storage in TWS pool(s)")])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"pools.zeroΔTWS"),o(": helper variable to reset ΔTWS to zero in every time step")])])])],-1)),n[4451]||(n[4451]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4452]||(n[4452]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.TWS"),o(": terrestrial water storage including all water pools")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔTWS"),o(": change in water storage in TWS pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.zeroΔTWS"),o(": helper variable to reset ΔTWS to zero in every time step")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.ΔTWS"),o(": change in water storage in TWS pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.TWS"),o(": terrestrial water storage including all water pools")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water"),o(": sum of water storage across all components")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water_prev"),o(": sum of water storage across all components in previous time step")])])])])],-1)),n[4453]||(n[4453]=l("p",null,[l("code",null,"precompute, update"),o(" methods are not defined")],-1)),n[4454]||(n[4454]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"wCycle_combined.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4455]||(n[4455]=l("hr",null,null,-1)),n[4456]||(n[4456]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4457]||(n[4457]=l("p",null,[l("em",null,"References")],-1)),n[4458]||(n[4458]=l("p",null,[l("em",null,"Versions")],-1)),n[4459]||(n[4459]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[4460]||(n[4460]=l("p",null,[l("em",null,"Created by")],-1)),n[4461]||(n[4461]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1}),e(s,{label:"wCycle_components"},{default:i(()=>[l("details",Fs,[l("summary",null,[n[4462]||(n[4462]=l("a",{id:"Sindbad.Models.wCycle_components",href:"#Sindbad.Models.wCycle_components"},[l("span",{class:"jlbinding"},"Sindbad.Models.wCycle_components")],-1)),n[4463]||(n[4463]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4464]||(n[4464]=l("p",null,"update the water cycle pools per component",-1)),n[4465]||(n[4465]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4466]||(n[4466]=l("ul",null,[l("li",null,"None")],-1)),n[4467]||(n[4467]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4468]||(n[4468]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4469]||(n[4469]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.TWS"),o(": terrestrial water storage including all water pools")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔTWS"),o(": change in water storage in TWS pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"constants.z_zero"),o(": a helper type stable 0 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"constants.o_one"),o(": a helper type stable 1 to be used across all models")])]),l("li",null,[l("p",null,[l("code",null,"models.w_model"),o(": a base water cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every water model/pool realization")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"pools.groundW"),o(": water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.snowW"),o(": water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.soilW"),o(": water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.surfaceW"),o(": water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.TWS"),o(": terrestrial water storage including all water pools")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔgroundW"),o(": change in water storage in groundW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsnowW"),o(": change in water storage in snowW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsoilW"),o(": change in water storage in soilW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"pools.ΔsurfaceW"),o(": change in water storage in surfaceW pool(s)")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water"),o(": sum of water storage across all components")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water_prev"),o(": sum of water storage across all components in previous time step")])])])])],-1)),n[4470]||(n[4470]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4471]||(n[4471]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"wCycle_components.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4472]||(n[4472]=l("hr",null,null,-1)),n[4473]||(n[4473]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4474]||(n[4474]=l("p",null,[l("em",null,"References")],-1)),n[4475]||(n[4475]=l("p",null,[l("em",null,"Versions")],-1)),n[4476]||(n[4476]=l("ul",null,[l("li",null,"1.0 on 18.11.2019 [skoirala | @dr-ko]")],-1)),n[4477]||(n[4477]=l("p",null,[l("em",null,"Created by")],-1)),n[4478]||(n[4478]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4712]||(n[4712]=l("hr",null,null,-1)),n[4713]||(n[4713]=l("h3",{id:"wCycleBase",tabindex:"-1"},[o("wCycleBase "),l("a",{class:"header-anchor",href:"#wCycleBase","aria-label":'Permalink to "wCycleBase {#wCycleBase}"'},"​")],-1)),l("details",Ns,[l("summary",null,[n[4480]||(n[4480]=l("a",{id:"Sindbad.Models.wCycleBase",href:"#Sindbad.Models.wCycleBase"},[l("span",{class:"jlbinding"},"Sindbad.Models.wCycleBase")],-1)),n[4481]||(n[4481]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4482]||(n[4482]=u("",4))]),l("details",Os,[n[4500]||(n[4500]=l("summary",null,"wCycleBase approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"wCycleBase_simple"},{default:i(()=>[l("details",Bs,[l("summary",null,[n[4483]||(n[4483]=l("a",{id:"Sindbad.Models.wCycleBase_simple",href:"#Sindbad.Models.wCycleBase_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.wCycleBase_simple")],-1)),n[4484]||(n[4484]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4485]||(n[4485]=l("p",null,[o("Through "),l("code",null,"wCycle"),o(".jl, adjust/update the variables for each storage separately and for TWS.")],-1)),n[4486]||(n[4486]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4487]||(n[4487]=l("ul",null,[l("li",null,"None")],-1)),n[4488]||(n[4488]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4489]||(n[4489]=l("p",null,[l("code",null,"define"),o(":")],-1)),n[4490]||(n[4490]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,"None")])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"models.w_model"),o(": a base water cycle model to loop through the pools and fill the main or component pools needed for using static arrays. A mandatory field for every water model/pool realization")])])])],-1)),n[4491]||(n[4491]=l("p",null,[l("code",null,"precompute, compute, update"),o(" methods are not defined")],-1)),n[4492]||(n[4492]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"wCycleBase_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4493]||(n[4493]=l("hr",null,null,-1)),n[4494]||(n[4494]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4495]||(n[4495]=l("p",null,[l("em",null,"References")],-1)),n[4496]||(n[4496]=l("p",null,[l("em",null,"Versions")],-1)),n[4497]||(n[4497]=l("ul",null,[l("li",null,"1.0 on 18.07.2023 [skoirala | @dr-ko]")],-1)),n[4498]||(n[4498]=l("p",null,[l("em",null,"Created by")],-1)),n[4499]||(n[4499]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4714]||(n[4714]=l("hr",null,null,-1)),n[4715]||(n[4715]=l("h3",{id:"waterBalance",tabindex:"-1"},[o("waterBalance "),l("a",{class:"header-anchor",href:"#waterBalance","aria-label":'Permalink to "waterBalance {#waterBalance}"'},"​")],-1)),l("details",Gs,[l("summary",null,[n[4501]||(n[4501]=l("a",{id:"Sindbad.Models.waterBalance",href:"#Sindbad.Models.waterBalance"},[l("span",{class:"jlbinding"},"Sindbad.Models.waterBalance")],-1)),n[4502]||(n[4502]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4503]||(n[4503]=u("",4))]),l("details",Ls,[n[4521]||(n[4521]=l("summary",null,"waterBalance approaches",-1)),e(r,null,{default:i(()=>[e(s,{label:"waterBalance_simple"},{default:i(()=>[l("details",zs,[l("summary",null,[n[4504]||(n[4504]=l("a",{id:"Sindbad.Models.waterBalance_simple",href:"#Sindbad.Models.waterBalance_simple"},[l("span",{class:"jlbinding"},"Sindbad.Models.waterBalance_simple")],-1)),n[4505]||(n[4505]=o()),e(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),n[4506]||(n[4506]=l("p",null,"Simply checks the water balance as P-ET-R-ds/dt.",-1)),n[4507]||(n[4507]=l("p",null,[l("strong",null,"Parameters")],-1)),n[4508]||(n[4508]=l("ul",null,[l("li",null,"None")],-1)),n[4509]||(n[4509]=l("p",null,[l("strong",null,"Methods:")],-1)),n[4510]||(n[4510]=l("p",null,[l("code",null,"compute"),o(":")],-1)),n[4511]||(n[4511]=l("ul",null,[l("li",null,[l("p",null,[l("strong",null,"Inputs")]),l("ul",null,[l("li",null,[l("p",null,[l("code",null,"fluxes.precip"),o(": total land precipitation including snow and rain")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water_prev"),o(": sum of water storage across all components in previous time step")])]),l("li",null,[l("p",null,[l("code",null,"states.total_water"),o(": sum of water storage across all components")])]),l("li",null,[l("p",null,[l("code",null,"states.WBP"),o(": water balance tracker pool that starts with rain and ends up with 0 after allocating to soil percolation")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.evapotranspiration"),o(": total land evaporation including soil evaporation, vegetation transpiration, snow sublimation, and interception loss")])]),l("li",null,[l("p",null,[l("code",null,"fluxes.runoff"),o(": total runoff")])])])]),l("li",null,[l("p",null,[l("strong",null,"Outputs")]),l("ul",null,[l("li",null,[l("code",null,"diagnostics.water_balance"),o(": misbalance of the water for the given time step calculated as the differences between total input, output and change in storages")])])])],-1)),n[4512]||(n[4512]=l("p",null,[l("code",null,"define, precompute, update"),o(" methods are not defined")],-1)),n[4513]||(n[4513]=l("p",null,[l("em",null,[o("End of "),l("code",null,"getModelDocString"),o("-generated docstring for "),l("code",null,"waterBalance_simple.jl"),o(". Check the Extended help for user-defined information.")])],-1)),n[4514]||(n[4514]=l("hr",null,null,-1)),n[4515]||(n[4515]=l("p",null,[l("strong",null,"Extended help")],-1)),n[4516]||(n[4516]=l("p",null,[l("em",null,"References")],-1)),n[4517]||(n[4517]=l("p",null,[l("em",null,"Versions")],-1)),n[4518]||(n[4518]=l("ul",null,[l("li",null,[l("p",null,"1.0 on 11.11.2019")]),l("li",null,[l("p",null,"1.1 on 20.11.2019 [skoirala | @dr-ko]:")])],-1)),n[4519]||(n[4519]=l("p",null,[l("em",null,"Created by")],-1)),n[4520]||(n[4520]=l("ul",null,[l("li",null,"skoirala | @dr-ko")],-1))])]),_:1})]),_:1})]),n[4716]||(n[4716]=l("hr",null,null,-1)),n[4717]||(n[4717]=l("h2",{id:"Internal",tabindex:"-1"},[o("Internal "),l("a",{class:"header-anchor",href:"#Internal","aria-label":'Permalink to "Internal {#Internal}"'},"​")],-1)),l("details",Us,[l("summary",null,[n[4522]||(n[4522]=l("a",{id:"Sindbad.Models.calcPropsSaxton1986-Tuple{soilProperties_Saxton1986, Vararg{Any, 4}}",href:"#Sindbad.Models.calcPropsSaxton1986-Tuple{soilProperties_Saxton1986, Vararg{Any, 4}}"},[l("span",{class:"jlbinding"},"Sindbad.Models.calcPropsSaxton1986")],-1)),n[4523]||(n[4523]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4524]||(n[4524]=l("p",null,"calculates the soil hydraulic properties based on Saxton 1986",-1)),n[4525]||(n[4525]=l("p",null,[l("strong",null,"Extended help")],-1))]),l("details",Js,[l("summary",null,[n[4526]||(n[4526]=l("a",{id:"Sindbad.Models.calcPropsSaxton2006-Tuple{soilProperties_Saxton2006, Any, Any, Any}",href:"#Sindbad.Models.calcPropsSaxton2006-Tuple{soilProperties_Saxton2006, Any, Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.calcPropsSaxton2006")],-1)),n[4527]||(n[4527]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4528]||(n[4528]=u("",15))]),l("details",Ks,[l("summary",null,[n[4529]||(n[4529]=l("a",{id:"Sindbad.Models.compute-Tuple{LandEcosystem, Any, Any, Any}",href:"#Sindbad.Models.compute-Tuple{LandEcosystem, Any, Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.compute")],-1)),n[4530]||(n[4530]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4531]||(n[4531]=u("",14))]),l("details",Hs,[l("summary",null,[n[4532]||(n[4532]=l("a",{id:"Sindbad.Models.define-Tuple{LandEcosystem, Any, Any, Any}",href:"#Sindbad.Models.define-Tuple{LandEcosystem, Any, Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.define")],-1)),n[4533]||(n[4533]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4534]||(n[4534]=u("",10))]),l("details",qs,[l("summary",null,[n[4535]||(n[4535]=l("a",{id:"Sindbad.Models.getModelDocString",href:"#Sindbad.Models.getModelDocString"},[l("span",{class:"jlbinding"},"Sindbad.Models.getModelDocString")],-1)),n[4536]||(n[4536]=o()),e(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),n[4537]||(n[4537]=u("",12))]),l("details",Zs,[l("summary",null,[n[4538]||(n[4538]=l("a",{id:"Sindbad.Models.includeApproaches-Tuple{Any, Any}",href:"#Sindbad.Models.includeApproaches-Tuple{Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.includeApproaches")],-1)),n[4539]||(n[4539]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4540]||(n[4540]=u("",10))]),l("details",Qs,[l("summary",null,[n[4541]||(n[4541]=l("a",{id:"Sindbad.Models.precompute-Tuple{LandEcosystem, Any, Any, Any}",href:"#Sindbad.Models.precompute-Tuple{LandEcosystem, Any, Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.precompute")],-1)),n[4542]||(n[4542]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4543]||(n[4543]=u("",15))]),l("details",Ys,[l("summary",null,[n[4544]||(n[4544]=l("a",{id:"Sindbad.Models.throwError-Tuple{Any, Any}",href:"#Sindbad.Models.throwError-Tuple{Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.throwError")],-1)),n[4545]||(n[4545]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4546]||(n[4546]=l("p",null,"throwError(land, msg) display and error msg and stop when there is inconsistency",-1))]),l("details",Xs,[l("summary",null,[n[4547]||(n[4547]=l("a",{id:"Sindbad.Models.update-Tuple{LandEcosystem, Any, Any, Any}",href:"#Sindbad.Models.update-Tuple{LandEcosystem, Any, Any, Any}"},[l("span",{class:"jlbinding"},"Sindbad.Models.update")],-1)),n[4548]||(n[4548]=o()),e(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),n[4549]||(n[4549]=u("",14))])])}const iu=d(g,[["render",$s]]);export{tu as __pageData,iu as default};
