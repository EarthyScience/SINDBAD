import{_ as i,c as a,o as e,aA as t}from"./chunks/framework.W9DcKwru.js";const k=JSON.parse('{"title":"Adding a New Cost Calculation Method in SINDBAD","description":"","frontmatter":{},"headers":[],"relativePath":"pages/develop/cost_function.md","filePath":"pages/develop/cost_function.md","lastUpdated":null}'),n={name:"pages/develop/cost_function.md"};function l(p,s,o,h,d,r){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="Adding-a-New-Cost-Calculation-Method-in-SINDBAD" tabindex="-1">Adding a New Cost Calculation Method in SINDBAD <a class="header-anchor" href="#Adding-a-New-Cost-Calculation-Method-in-SINDBAD" aria-label="Permalink to &quot;Adding a New Cost Calculation Method in SINDBAD {#Adding-a-New-Cost-Calculation-Method-in-SINDBAD}&quot;">​</a></h1><p>This documentation provides a framework for adding new cost calculation methods while maintaining consistency with SINDBAD&#39;s existing architecture.</p><div class="tip custom-block"><p class="custom-block-title">For a more detailed view of available cost methods and their purposes, use:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Sindbad</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">showMethodsOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(CostMethod)</span></span></code></pre></div><p>This will display a formatted list of all cost methods and their descriptions.</p></div><h2 id="Overview" tabindex="-1">Overview <a class="header-anchor" href="#Overview" aria-label="Permalink to &quot;Overview {#Overview}&quot;">​</a></h2><p>SINDBAD uses a type-based dispatch system for cost calculation methods. To add a new cost calculation method, you need to:</p><ol><li><p>Define a new type in <code>src/Types/OptimizationTypes.jl</code></p></li><li><p>Implement the cost calculation function in <code>cost.jl</code></p></li><li><p>Update the cost preparation in <code>prepOpti.jl</code> if needed</p></li></ol><h2 id="Step-1:-Define-the-New-Cost-Method-Type" tabindex="-1">Step 1: Define the New Cost Method Type <a class="header-anchor" href="#Step-1:-Define-the-New-Cost-Method-Type" aria-label="Permalink to &quot;Step 1: Define the New Cost Method Type {#Step-1:-Define-the-New-Cost-Method-Type}&quot;">​</a></h2><p>In <code>src/Types/OptimizationTypes.jl</code>, add a new struct that subtypes <code>CostMethod</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> YourNewCostMethod </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CostMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span></code></pre></div><p>For example, the existing cost methods are (but can change, use <code>showMethodsOf(CostMethod)</code> for current implementations):</p><ul><li><p><code>CostModelObs</code>: Basic cost calculation between model and observations</p></li><li><p><code>CostModelObsMT</code>: Multi-threaded version of <code>CostModelObs</code></p></li><li><p><code>CostModelObsPriors</code>: Cost calculation including prior information</p></li><li><p><code>CostModelObsLandTS</code>: Cost calculation for land time series</p></li></ul><h2 id="Step-2:-Implement-the-Cost-Calculation-Function" tabindex="-1">Step 2: Implement the Cost Calculation Function <a class="header-anchor" href="#Step-2:-Implement-the-Cost-Calculation-Function" aria-label="Permalink to &quot;Step 2: Implement the Cost Calculation Function {#Step-2:-Implement-the-Cost-Calculation-Function}&quot;">​</a></h2><p>In <code>cost.jl</code>, implement your cost calculation function with the following signature:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, default_values, selected_models, space_forcing, space_spinup_forcing, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            loc_forcing_t, output_array, space_output, space_land, tem_info, observations, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type, </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">YourNewCostMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Your implementation here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>The function should:</p><ol><li><p>Update model parameters using <code>updateModels</code></p></li><li><p>Run the model simulation</p></li><li><p>Calculate the cost using <code>metricVector</code> and <code>combineMetric</code></p></li></ol><p>Example implementation structure:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, _, selected_models, space_forcing, space_spinup_forcing, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            loc_forcing_t, output_array, space_output, space_land, tem_info, observations, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type, </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">YourNewCostMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Update models with new parameters</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updated_models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> updateModels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, parameter_updater, parameter_scaling_type, selected_models)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Run the model simulation</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    runTEM!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(updated_models, space_forcing, space_spinup_forcing, loc_forcing_t, space_output, space_land, tem_info)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Calculate cost vector</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cost_vector </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> metricVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output_array, observations, cost_options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Combine costs using specified method</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cost_metric </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> combineMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_vector, multi_constraint_method)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost_metric</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Step-3:-Update-Cost-Preparation-if-needed" tabindex="-1">Step 3: Update Cost Preparation (if needed) <a class="header-anchor" href="#Step-3:-Update-Cost-Preparation-if-needed" aria-label="Permalink to &quot;Step 3: Update Cost Preparation (if needed) {#Step-3:-Update-Cost-Preparation-if-needed}&quot;">​</a></h2><p>If your new cost method requires special preparation, update <code>prepOpti.jl</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> prepOpti</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing, observations, info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">YourNewCostMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Get base helpers</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    opti_helpers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prepOpti</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(forcing, observations, info, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CostModelObs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Add your custom preparation here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opti_helpers</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Example:-Adding-a-Weighted-Cost-Method" tabindex="-1">Example: Adding a Weighted Cost Method <a class="header-anchor" href="#Example:-Adding-a-Weighted-Cost-Method" aria-label="Permalink to &quot;Example: Adding a Weighted Cost Method {#Example:-Adding-a-Weighted-Cost-Method}&quot;">​</a></h2><p>Here&#39;s a complete example of adding a new weighted cost method:</p><ol><li>In <code>src/Types/OptimizationTypes.jl</code>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CostModelObsWeighted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CostMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span></code></pre></div><ol><li>In <code>cost.jl</code>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, _, selected_models, space_forcing, space_spinup_forcing, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             loc_forcing_t, output_array, space_output, space_land, tem_info, observations, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             parameter_updater, cost_options, multi_constraint_method, parameter_scaling_type, </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             ::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CostModelObsWeighted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Update models</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    updated_models </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> updateModels</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parameter_vector, parameter_updater, parameter_scaling_type, selected_models)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Run simulation</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    runTEM!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(updated_models, space_forcing, space_spinup_forcing, loc_forcing_t, space_output, space_land, tem_info)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Calculate weighted cost vector</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cost_vector </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> metricVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output_array, observations, cost_options)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Apply custom weights</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weights </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getWeights</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cost_options)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># getWeights is a hypothetical function, you would need to implement such function</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    weighted_cost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost_vector </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weights</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Combine costs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cost_metric </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> combineMetric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weighted_cost, multi_constraint_method)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cost_metric</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Important-Considerations" tabindex="-1">Important Considerations <a class="header-anchor" href="#Important-Considerations" aria-label="Permalink to &quot;Important Considerations {#Important-Considerations}&quot;">​</a></h2><ol><li><p><strong>Parameter Scaling</strong>: Ensure your method properly handles parameter scaling using <code>parameter_scaling_type</code>.</p></li><li><p><strong>Multi-threading</strong>: If your method can benefit from parallelization, consider implementing a multi-threaded version like <code>CostModelObsMT</code>.</p></li><li><p><strong>Cost Options</strong>: Your method should respect the <code>cost_options</code> configuration, which includes:</p></li></ol><ul><li><p>Cost metrics</p></li><li><p>Spatial and temporal aggregation</p></li><li><p>Minimum data points</p></li><li><p>Weights</p></li></ul><ol start="4"><li><p><strong>Performance</strong>: For large-scale optimizations, consider implementing efficient memory management and parallelization.</p></li><li><p><strong>Documentation</strong>: Add comprehensive docstrings explaining:</p></li></ol><ul><li><p>The purpose of your cost method</p></li><li><p>Required parameters</p></li><li><p>Return values</p></li><li><p>Any special considerations</p></li></ul><h2 id="Testing" tabindex="-1">Testing <a class="header-anchor" href="#Testing" aria-label="Permalink to &quot;Testing {#Testing}&quot;">​</a></h2><p>After implementing your new cost method:</p><ol><li><p>Test with small parameter sets first</p></li><li><p>Verify the cost calculation matches expected values</p></li><li><p>Check performance with larger parameter sets</p></li><li><p>Ensure compatibility with different optimization algorithms</p></li></ol>`,35)]))}const g=i(n,[["render",l]]);export{k as __pageData,g as default};
