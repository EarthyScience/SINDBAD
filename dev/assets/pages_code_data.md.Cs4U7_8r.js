import{_ as l,C as o,c as d,o as p,j as a,aA as s,a as e,G as n}from"./chunks/framework.C07RQYAL.js";const X=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"pages/code/data.md","filePath":"pages/code/data.md","lastUpdated":null}'),r={name:"pages/code/data.md"},c={class:"jldocstring custom-block"},u={class:"jldocstring custom-block"},h={class:"jldocstring custom-block"},g={class:"jldocstring custom-block"},k={class:"jldocstring custom-block"},m={class:"jldocstring custom-block"},y={class:"jldocstring custom-block"},b={class:"jldocstring custom-block"},f={class:"jldocstring custom-block"},T={class:"jldocstring custom-block"},_={class:"jldocstring custom-block"},A={class:"jldocstring custom-block"},v={class:"jldocstring custom-block"},D={class:"jldocstring custom-block"},E={class:"jldocstring custom-block"},C={class:"jldocstring custom-block"},S={class:"jldocstring custom-block"},j={class:"jldocstring custom-block"},F={class:"jldocstring custom-block"},N={class:"jldocstring custom-block"},x={class:"jldocstring custom-block"},I={class:"jldocstring custom-block"},P={class:"jldocstring custom-block"},B={class:"jldocstring custom-block"};function V(R,i,w,O,M,q){const t=o("Badge");return p(),d("div",null,[a("details",c,[a("summary",null,[i[0]||(i[0]=a("a",{id:"SindbadData",href:"#SindbadData"},[a("span",{class:"jlbinding"},"SindbadData")],-1)),i[1]||(i[1]=e()),n(t,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),i[2]||(i[2]=s(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SindbadData</span></span></code></pre></div><p>The <code>SindbadData</code> package provides tools for handling and processing SINDBAD-related input data and processing. It supports reading, cleaning, masking, and managing data for SINDBAD experiments, with a focus on spatial and temporal dimensions.</p><p><strong>Purpose:</strong></p><p>This package is designed to streamline the ingestion and preprocessing of input data for SINDBAD experiments.</p><p><strong>Dependencies:</strong></p><ul><li><p><code>SindbadUtils</code>: Provides utility functions for handling NamedTuple, spatial operations, and other helper tasks for spatial and temporal operations.</p></li><li><p><code>AxisKeys</code>: Enables labeled multidimensional arrays (<code>KeyedArray</code>) for managing data with explicit axis labels.</p></li><li><p><code>FillArrays</code>: Provides efficient representations of arrays filled with a single value, useful for initializing data structures.</p></li><li><p><code>DimensionalData</code>: Facilitates working with multidimensional data, particularly for indexing and slicing along spatial and temporal dimensions.</p></li><li><p><code>NCDatasets</code>: Provides tools for reading and writing NetCDF files, a common format for scientific data.</p></li><li><p><code>NetCDF</code>: Re-exported for convenience, enabling users to work with NetCDF files directly.</p></li><li><p><code>YAXArrays</code>: Supports handling of multidimensional arrays, particularly for managing spatial and temporal data in SINDBAD experiments.</p></li><li><p><code>Zarr</code>: Re-exported for handling hierarchical, chunked, and compressed data arrays, useful for large datasets.</p></li><li><p><code>YAXArrayBase</code>: Provides base functionality for working with YAXArrays.</p></li></ul><p><strong>Included Files:</strong></p><ol><li><strong><code>inputTypes.jl</code></strong>:</li></ol><ul><li>Defines types and structures for managing input data, ensuring consistency across SINDBAD experiments.</li></ul><ol start="2"><li><strong><code>utilsData.jl</code></strong>:</li></ol><ul><li>Contains utility functions for data preprocessing, including cleaning, masking, and checking bounds.</li></ul><ol start="3"><li><strong><code>getForcing.jl</code></strong>:</li></ol><ul><li>Provides functions for extracting and processing forcing data, such as environmental drivers, for SINDBAD experiments.</li></ul><ol start="4"><li><strong><code>getObservation.jl</code></strong>:</li></ol><ul><li>Implements utilities for reading and processing observational data, enabling model validation and performance evaluation.</li></ul><p><strong>Notes:</strong></p><ul><li><p>The package re-exports key packages (<code>NetCDF</code>, <code>YAXArrays</code>, <code>Zarr</code>) for convenience, allowing users to access their functionality directly through <code>SindbadData</code>.</p></li><li><p>Designed to handle large datasets efficiently, leveraging chunked and compressed data formats like NetCDF and Zarr.</p></li><li><p>Ensures compatibility with SINDBAD&#39;s experimental framework by integrating spatial and temporal data management tools.</p></li></ul><p><strong>Examples:</strong></p><ol><li><strong>Reading forcing data</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SindbadData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">forcing_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getForcing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;forcing_file.nc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol><li><strong>Processing observational data</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SindbadData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observations </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> getObservation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;observation_file.nc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol><li><strong>Cleaning and masking data</strong>:</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SindbadData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cleaned_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cleanData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(raw_data, mask)</span></span></code></pre></div>`,24))]),i[72]||(i[72]=a("h2",{id:"exported",tabindex:"-1"},[e("Exported "),a("a",{class:"header-anchor",href:"#exported","aria-label":'Permalink to "Exported"'},"​")],-1)),a("details",u,[a("summary",null,[i[3]||(i[3]=a("a",{id:"SindbadData.AllNaN",href:"#SindbadData.AllNaN"},[a("span",{class:"jlbinding"},"SindbadData.AllNaN")],-1)),i[4]||(i[4]=e()),n(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[5]||(i[5]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AllNaN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> YAXArrays.DAT.ProcFilter</span></span></code></pre></div><p>Add skipping filter for pixels with all <code>NaN</code> or <code>missing</code> in YAXArrays</p><p>A filter type that inherits from <code>YAXArrays.DAT.ProcFilter</code>.</p><p>This struct is used as a specialized filter in data processing pipelines to identify or handle cases where all values in a data segment are NaN (Not a Number).</p>',4))]),a("details",h,[a("summary",null,[i[6]||(i[6]=a("a",{id:"SindbadData.getForcing-Tuple{NamedTuple}",href:"#SindbadData.getForcing-Tuple{NamedTuple}"},[a("span",{class:"jlbinding"},"SindbadData.getForcing")],-1)),i[7]||(i[7]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[8]||(i[8]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getForcing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reads forcing data from the <code>data_path</code> specified in the experiment configuration and returns a NamedTuple with the forcing data.</p><p><strong>Arguments:</strong></p><ul><li><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>forcing</code> containing: <ul><li><p><code>data</code>: The processed input cubes.</p></li><li><p><code>dims</code>: The dimensions of the forcing data.</p></li><li><p><code>variables</code>: The names of the forcing variables.</p></li><li><p><code>f_types</code>: The types of the forcing data (e.g., <code>ForcingWithTime</code> or <code>ForcingWithoutTime</code>).</p></li><li><p><code>helpers</code>: Helper information for the forcing data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Reads forcing data from the specified data path and processes it using the SINDBAD framework.</p></li><li><p>Handles spatiotemporal and spatial-only forcing data.</p></li><li><p>Applies masks and subsets to the forcing data if specified in the configuration.</p></li></ul>',8))]),a("details",g,[a("summary",null,[i[9]||(i[9]=a("a",{id:"SindbadData.getNumberOfTimeSteps-Tuple{Any, Any}",href:"#SindbadData.getNumberOfTimeSteps-Tuple{Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.getNumberOfTimeSteps")],-1)),i[10]||(i[10]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[11]||(i[11]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getNumberOfTimeSteps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incubes, time_name)</span></span></code></pre></div><p>Returns the number of time steps in the input data cubes.</p><p><strong>Arguments</strong></p><ul><li><p><code>incubes</code>: Input data cubes containing temporal information</p></li><li><p><code>time_name</code>: Name of the time dimension/variable</p></li></ul><p><strong>Returns</strong></p><p>Integer representing the total number of time steps in the data</p>',6))]),a("details",k,[a("summary",null,[i[12]||(i[12]=a("a",{id:"SindbadData.getObservation-Tuple{NamedTuple, NamedTuple}",href:"#SindbadData.getObservation-Tuple{NamedTuple, NamedTuple}"},[a("span",{class:"jlbinding"},"SindbadData.getObservation")],-1)),i[13]||(i[13]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[14]||(i[14]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getObservation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, forcing_helpers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Processes observation data and returns a NamedTuple containing the observation data, dimensions, and variables.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>forcing_helpers</code>: A SINDBAD NamedTuple containing helper information for forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple with the following fields: <ul><li><p><code>data</code>: The processed observation data as an input array.</p></li><li><p><code>dims</code>: The dimensions of the observation data.</p></li><li><p><code>variables</code>: A tuple of variable names for the observation data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Reads observation data from the path specified in the experiment configuration.</p></li><li><p>Handles quality flags, uncertainty, spatial weights, and selection masks for each observation variable.</p></li><li><p>Subsets and harmonizes the observation data based on the target dimensions and masks.</p></li></ul>',8))]),a("details",m,[a("summary",null,[i[15]||(i[15]=a("a",{id:"SindbadData.mapCleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, Val{T}}} where T",href:"#SindbadData.mapCleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, Val{T}}} where T"},[a("span",{class:"jlbinding"},"SindbadData.mapCleanData")],-1)),i[16]||(i[16]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[17]||(i[17]=s("<p>Maps and cleans data based on quality control parameters and fills missing values.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Raw input data to be cleaned</p></li><li><p><code>_data_qc</code>: Quality control data corresponding to input data</p></li><li><p><code>_data_fill</code>: Fill values for replacing invalid/missing data</p></li><li><p><code>bounds_qc</code>: Quality control bounds/thresholds</p></li><li><p><code>_data_info</code>: Additional information about the data</p></li><li><p><code>::Val{T}</code>: Value type parameter for dispatch</p></li></ul><p><strong>Returns</strong></p><p>Cleaned and mapped data with invalid values replaced according to QC criteria</p><p><strong>Note</strong></p><p>This function performs quality control checks and data cleaning based on the provided bounds and fill values. The exact behavior depends on the value type T.</p>",7))]),a("details",y,[a("summary",null,[i[18]||(i[18]=a("a",{id:"SindbadData.subsetAndProcessYax-Union{Tuple{num_type}, Tuple{Any, Any, Any, Any, Any, Val{num_type}}} where num_type",href:"#SindbadData.subsetAndProcessYax-Union{Tuple{num_type}, Tuple{Any, Any, Any, Any, Any, Val{num_type}}} where num_type"},[a("span",{class:"jlbinding"},"SindbadData.subsetAndProcessYax")],-1)),i[19]||(i[19]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[20]||(i[20]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">subsetAndProcessYax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(yax, forcing_mask, tar_dims, _data_info, info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{num_type}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; clean_data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fill_nan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, yax_qc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bounds_qc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {num_type}</span></span></code></pre></div><p>Subset and process YAX data according to specified parameters and quality control criteria.</p><p><strong>Arguments</strong></p><ul><li><p><code>yax</code>: YAX data to be processed</p></li><li><p><code>forcing_mask</code>: Mask to apply to the data</p></li><li><p><code>tar_dims</code>: Target dimensions</p></li><li><p><code>_data_info</code>: Data information</p></li><li><p><code>info</code>: a SINDBAD NT that includes all information needed for setup and execution of an experiment</p></li><li><p><code>::Val{num_type}</code>: Value type parameter for numerical type specification</p></li><li><p><code>clean_data=true</code>: Boolean flag to enable/disable data cleaning</p></li><li><p><code>fill_nan=false</code>: Boolean flag to control NaN filling</p></li><li><p><code>yax_qc=nothing</code>: Optional quality control parameters for YAX data</p></li><li><p><code>bounds_qc=nothing</code>: Optional boundary quality control parameters</p></li></ul><p><strong>Returns</strong></p><p>Processed and subset YAX data according to specified parameters and quality controls.</p><p><strong>Type Parameters</strong></p><ul><li><code>num_type</code>: Numerical type specification for the processed data</li></ul>',8))]),a("details",b,[a("summary",null,[i[21]||(i[21]=a("a",{id:"SindbadData.toDimStackArray-Tuple{Any, Any, Any}",href:"#SindbadData.toDimStackArray-Tuple{Any, Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.toDimStackArray")],-1)),i[22]||(i[22]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[23]||(i[23]=s("<p>Convert a stacked array into a DimensionalArray with specified dimensions and metadata.</p><p><strong>Arguments</strong></p><ul><li><p><code>stackArr</code>: The input stacked array to be converted</p></li><li><p><code>time_interval</code>: Time interval information for temporal dimension</p></li><li><p><code>p_names</code>: Names of pools/variables</p></li><li><p><code>name</code>: Optional keyword argument to specify the name of the dimension (default: :pools)</p></li></ul><p><strong>Returns</strong></p><p>A DimensionalArray with proper dimensions and labels.</p><p>This function is useful for converting raw stacked arrays into properly dimensioned arrays with metadata, particularly for time series data with multiple pools or variables.</p>",6))]),a("details",f,[a("summary",null,[i[24]||(i[24]=a("a",{id:"SindbadData.yaxCubeToKeyedArray-Tuple{Any}",href:"#SindbadData.yaxCubeToKeyedArray-Tuple{Any}"},[a("span",{class:"jlbinding"},"SindbadData.yaxCubeToKeyedArray")],-1)),i[25]||(i[25]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[26]||(i[26]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">yaxCubeToKeyedArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)</span></span></code></pre></div><p>Convert a YAXArray cube to a KeyedArray.</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: YAXArray input cube to be converted</li></ul><p><strong>Returns</strong></p><p>KeyedArray representation of the input YAXArray cube</p><p><strong>Description</strong></p><p>Transforms a YAXArray data cube into a KeyedArray format, preserving the dimensional structure and associated metadata of the original cube.</p>',8))]),i[73]||(i[73]=a("h2",{id:"internal",tabindex:"-1"},[e("Internal "),a("a",{class:"header-anchor",href:"#internal","aria-label":'Permalink to "Internal"'},"​")],-1)),a("details",T,[a("summary",null,[i[27]||(i[27]=a("a",{id:"SindbadData.applyQCBound-NTuple{4, Any}",href:"#SindbadData.applyQCBound-NTuple{4, Any}"},[a("span",{class:"jlbinding"},"SindbadData.applyQCBound")],-1)),i[28]||(i[28]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[29]||(i[29]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">applyQCBound</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, data_qc, bounds_qc, _data_fill)</span></span></code></pre></div><p>Apply quality control bounds to data values.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Input data array to be quality controlled</p></li><li><p><code>data_qc</code>: Quality control flags associated with the data</p></li><li><p><code>bounds_qc</code>: Bounds/thresholds for quality control checks</p></li><li><p><code>_data_fill</code>: Fill value to use for data points that fail QC</p></li></ul><p><strong>Returns</strong></p><p>The quality controlled data array with values outside bounds replaced by fill value</p>',6))]),a("details",_,[a("summary",null,[i[30]||(i[30]=a("a",{id:"SindbadData.applyUnitConversion",href:"#SindbadData.applyUnitConversion"},[a("span",{class:"jlbinding"},"SindbadData.applyUnitConversion")],-1)),i[31]||(i[31]=e()),n(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[32]||(i[32]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">applyUnitConversion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, conversion, isadditive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Applies a simple factor to the input, either additively or multiplicatively depending on isadditive flag</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: Input data to be converted</p></li><li><p><code>conversion</code>: Conversion factor or function to be applied</p></li><li><p><code>isadditive</code>: Boolean flag indicating whether the conversion is additive (default: false) or multiplicative</p></li></ul><p><strong>Returns</strong></p><p>Converted data with the applied unit transformation</p>',6))]),a("details",A,[a("summary",null,[i[33]||(i[33]=a("a",{id:"SindbadData.cleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Val{T}}} where T",href:"#SindbadData.cleanData-Union{Tuple{T}, Tuple{Any, Any, Any, Val{T}}} where T"},[a("span",{class:"jlbinding"},"SindbadData.cleanData")],-1)),i[34]||(i[34]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[35]||(i[35]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(_data, _data_fill, _data_info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Val{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {T}</span></span></code></pre></div><p>Applies a series of cleaning steps to the data, including replacing invalid data, applying unit conversion, and clamping to bounds.</p><p><strong>Arguments</strong></p><ul><li><p><code>_data</code>: The raw data to be cleaned</p></li><li><p><code>_data_fill</code>: Fill values or parameters for handling missing/invalid data</p></li><li><p><code>_data_info</code>: Information about the data structure and cleaning requirements</p></li><li><p><code>::Val{T}</code>: Value type parameter for dispatch</p></li></ul><p><strong>Returns</strong></p><p>Cleaned data according to the specified type parameter T</p>',6))]),a("details",v,[a("summary",null,[i[36]||(i[36]=a("a",{id:"SindbadData.collectForcingHelpers-Tuple{Any, Any, Any}",href:"#SindbadData.collectForcingHelpers-Tuple{Any, Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.collectForcingHelpers")],-1)),i[37]||(i[37]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[38]||(i[38]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collectForcingHelpers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info, f_sizes, f_dimensions)</span></span></code></pre></div><p>Generates a NamedTuple of helper information for forcing data.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>f_sizes</code>: A NamedTuple containing the sizes of forcing dimensions.</p></li><li><p><code>f_dimensions</code>: A NamedTuple containing the dimensions of the forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>f_helpers</code> containing helper information for forcing data.</li></ul><p><strong>Notes:</strong></p><ul><li>Includes dimensions, axes, subset information, and sizes for the forcing data.</li></ul>',8))]),a("details",D,[a("summary",null,[i[39]||(i[39]=a("a",{id:"SindbadData.collectForcingSizes-Tuple{Any, Any}",href:"#SindbadData.collectForcingSizes-Tuple{Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.collectForcingSizes")],-1)),i[40]||(i[40]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[41]||(i[41]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">collectForcingSizes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info, in_yax)</span></span></code></pre></div><p>Collects the sizes of forcing dimensions from the input YAXArray.</p><p><strong>Arguments:</strong></p><ul><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>in_yax</code>: The input YAXArray containing forcing data.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>f_sizes</code> where each dimension name is paired with its size.</li></ul><p><strong>Notes:</strong></p><ul><li><p>The function retrieves the size of the time dimension and spatial dimensions specified in the experiment configuration.</p></li><li><p>If the dimension is not directly accessible, it uses <code>DimensionalData.lookup</code> to retrieve the size.</p></li></ul>',8))]),a("details",E,[a("summary",null,[i[42]||(i[42]=a("a",{id:"SindbadData.createForcingNamedTuple-NTuple{4, Any}",href:"#SindbadData.createForcingNamedTuple-NTuple{4, Any}"},[a("span",{class:"jlbinding"},"SindbadData.createForcingNamedTuple")],-1)),i[43]||(i[43]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[44]||(i[44]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">createForcingNamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(incubes, f_sizes, f_dimensions, info)</span></span></code></pre></div><p>Creates a NamedTuple containing forcing data and metadata.</p><p><strong>Arguments:</strong></p><ul><li><p><code>incubes</code>: A collection of input cubes (YAXArray) containing forcing data.</p></li><li><p><code>f_sizes</code>: A NamedTuple containing the sizes of forcing dimensions.</p></li><li><p><code>f_dimensions</code>: A NamedTuple containing the dimensions of the forcing data.</p></li><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li></ul><p><strong>Returns:</strong></p><ul><li>A NamedTuple <code>forcing</code> containing: <ul><li><p><code>data</code>: The processed input cubes.</p></li><li><p><code>dims</code>: The dimensions of the forcing data.</p></li><li><p><code>variables</code>: The names of the forcing variables.</p></li><li><p><code>f_types</code>: The types of the forcing data (e.g., <code>ForcingWithTime</code> or <code>ForcingWithoutTime</code>).</p></li><li><p><code>helpers</code>: Helper information for the forcing data.</p></li></ul></li></ul><p><strong>Notes:</strong></p><ul><li><p>Processes the input cubes to determine their types and dimensions.</p></li><li><p>Helper information is generated using <code>collectForcingHelpers</code>.</p></li></ul>',8))]),a("details",C,[a("summary",null,[i[45]||(i[45]=a("a",{id:"SindbadData.getAllConstraintData-NTuple{7, Any}",href:"#SindbadData.getAllConstraintData-NTuple{7, Any}"},[a("span",{class:"jlbinding"},"SindbadData.getAllConstraintData")],-1)),i[46]||(i[46]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[47]||(i[47]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getAllConstraintData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_backend, data_path, default_info, v_info, data_sub_field, info; yax</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, use_data_sub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Reads data from the observation file and returns the data, YAXArray, variable info, and bounds for the observation constraint.</p><p><strong>Arguments:</strong></p><ul><li><p><code>nc</code>: The file or NetCDF object containing the observation data.</p></li><li><p><code>data_backend</code>: The backend used to process the data (e.g., NetCDF, Zarr).</p></li><li><p><code>data_path</code>: The path to the observation data file.</p></li><li><p><code>default_info</code>: Default variable information for constraints.</p></li><li><p><code>v_info</code>: Variable-specific information for the observation constraint, which can overwrite <code>default_info</code>.</p></li><li><p><code>data_sub_field</code>: The subfield of the observation data to process (e.g., <code>:data</code>, <code>:qflag</code>, <code>:unc</code>).</p></li><li><p><code>info</code>: A SINDBAD NamedTuple containing all information needed for setup and execution of an experiment.</p></li><li><p><code>yax</code>: (Optional) The base observation YAXArray.</p></li><li><p><code>use_data_sub</code>: A flag indicating whether to use the subfield of the observation constraint.</p></li></ul><p><strong>Returns:</strong></p><ul><li><p><code>nc_sub</code>: The NetCDF object for the subfield.</p></li><li><p><code>yax_sub</code>: The YAXArray for the subfield.</p></li><li><p><code>v_info_sub</code>: The variable information for the subfield.</p></li><li><p><code>bounds_sub</code>: The bounds for the subfield.</p></li></ul><p><strong>Notes:</strong></p><ul><li><p>If the subfield is not provided or <code>use_data_sub</code> is <code>false</code>, default values are used.</p></li><li><p>Handles quality flags, uncertainty, spatial weights, and selection masks for observation constraints.</p></li></ul>',8))]),a("details",S,[a("summary",null,[i[48]||(i[48]=a("a",{id:"SindbadData.getDataDims-Tuple{Any, Any}",href:"#SindbadData.getDataDims-Tuple{Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.getDataDims")],-1)),i[49]||(i[49]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[50]||(i[50]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getDataDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, mappinginfo)</span></span></code></pre></div><p>Retrieves the dimensions of data based on provided mapping information.</p><p><strong>Arguments</strong></p><ul><li><p><code>c</code>: The container or data structure to get dimensions from</p></li><li><p><code>mappinginfo</code>: Information about how the data is mapped</p></li></ul><p><strong>Returns</strong></p><p>The dimensions of the data specified by the mapping information.</p>',6))]),a("details",j,[a("summary",null,[i[51]||(i[51]=a("a",{id:"SindbadData.getDimPermutation-Tuple{Any, Any}",href:"#SindbadData.getDimPermutation-Tuple{Any, Any}"},[a("span",{class:"jlbinding"},"SindbadData.getDimPermutation")],-1)),i[52]||(i[52]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[53]||(i[53]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getDimPermutation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(datDims, permDims)</span></span></code></pre></div><p>Returns the permutation indices required to rearrange dimensions from <code>datDims</code> to match <code>permDims</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>datDims</code>: Array of current dimension names or indices</p></li><li><p><code>permDims</code>: Array of target dimension names or indices in desired order</p></li></ul><p><strong>Returns</strong></p><ul><li>Array of indices representing the required permutation</li></ul>',6))]),a("details",F,[a("summary",null,[i[54]||(i[54]=a("a",{id:"SindbadData.getInputArrayOfType",href:"#SindbadData.getInputArrayOfType"},[a("span",{class:"jlbinding"},"SindbadData.getInputArrayOfType")],-1)),i[55]||(i[55]=e()),n(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[56]||(i[56]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getInputArrayOfType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_data, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SindbadInputDataType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Converts the provided input data into a specific input array type.</p><p><strong>Arguments</strong></p><ul><li><p><code>input_data</code>: The data to be converted into an input array</p></li><li><p>&lt;:SindbadInputDataType: The specific input array type to convert the data into</p><ul><li><p><code>::InputArray</code>: Specifies the input array type as a simple array</p></li><li><p><code>::InputKeyedArray</code>: Specifies the input array type as a keyed array</p></li><li><p><code>::InputNamedDimsArray</code>: Specifies the input array type as a named dims array</p></li><li><p><code>::InputYaxArray</code>: Specifies the input array type as a YAX array</p></li></ul></li></ul><p><strong>Returns</strong></p><p>Returns the input data converted to the specified input array type.</p>',6))]),a("details",N,[a("summary",null,[i[57]||(i[57]=a("a",{id:"SindbadData.getSindbadDims-Tuple{Any}",href:"#SindbadData.getSindbadDims-Tuple{Any}"},[a("span",{class:"jlbinding"},"SindbadData.getSindbadDims")],-1)),i[58]||(i[58]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[59]||(i[59]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getSindbadDims</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)</span></span></code></pre></div><p>prepare the dimensions of data and name them appropriately for use in internal SINDBAD functions</p><p><strong>Arguments</strong></p><ul><li><code>c</code>: input data cube</li></ul><p><strong>Returns</strong></p><p>Dimensions for use in SINDBAD</p>',6))]),a("details",x,[a("summary",null,[i[60]||(i[60]=a("a",{id:"SindbadData.getTargetDimensionOrder-Tuple{Any}",href:"#SindbadData.getTargetDimensionOrder-Tuple{Any}"},[a("span",{class:"jlbinding"},"SindbadData.getTargetDimensionOrder")],-1)),i[61]||(i[61]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[62]||(i[62]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getTargetDimensionOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(info)</span></span></code></pre></div><p>Retrieves the target dimension order to organize the forcing data from the provided information.</p><p><strong>Arguments</strong></p><ul><li><code>info</code>: Input information containing dimension order details.</li></ul><p><strong>Returns</strong></p><p>The ordered sequence of dimensions for the target.</p>',6))]),a("details",I,[a("summary",null,[i[63]||(i[63]=a("a",{id:"SindbadData.getYaxFromSource",href:"#SindbadData.getYaxFromSource"},[a("span",{class:"jlbinding"},"SindbadData.getYaxFromSource")],-1)),i[64]||(i[64]=e()),n(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[65]||(i[65]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">getYaxFromSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_path, data_path_v, source_variable, info, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SindbadInputBackend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Retrieve the data from a specified source.</p><p><strong>Arguments</strong></p><ul><li><p><code>nc</code>: The NetCDF file or object to read data from.</p></li><li><p><code>data_path</code>: The path to the data within the NetCDF file.</p></li><li><p><code>data_path_v</code>: The path to the variable within the NetCDF file.</p></li><li><p><code>source_variable</code>: The name of the source variable to extract data for.</p></li><li><p><code>info</code>: Additional information or metadata required for processing.</p></li><li><p><code>&lt;:SindbadInputBackend</code>: Specifies the SINDBAD backend being used.</p><ul><li><p><code>::BackendNetcdf</code>: Specifies that the function operates on a NetCDF backend.</p></li><li><p><code>::BackendZarr</code>: Specifies that the backend being used is Zarr.</p></li></ul></li></ul><p><strong>Returns</strong></p><ul><li>The file object and extracted YAX data from the specified source.</li></ul><p><strong>Notes</strong></p><ul><li><p>Ensure that the <code>nc</code> object and paths provided are valid and accessible.</p></li><li><p>The functions are specific to the NetCDF and Zarr backend and may not work with other backends.</p></li></ul>',8))]),a("details",P,[a("summary",null,[i[66]||(i[66]=a("a",{id:"SindbadData.loadDataFile-Tuple{Any}",href:"#SindbadData.loadDataFile-Tuple{Any}"},[a("span",{class:"jlbinding"},"SindbadData.loadDataFile")],-1)),i[67]||(i[67]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[68]||(i[68]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loadDataFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Any</span></span></code></pre></div><p>Load data from the specified file path.</p><p><strong>Arguments</strong></p><ul><li><code>data_path::String</code>: The path to the data file to be loaded.</li></ul><p><strong>Returns</strong></p><ul><li>The data loaded from the specified file. The return type depends on the file format and its contents.</li></ul><p><strong>Notes</strong></p><ul><li><p>Ensure that the file exists and is accessible at the given path.</p></li><li><p>The function assumes the file format is supported by the implementation.</p></li></ul>',8))]),a("details",B,[a("summary",null,[i[69]||(i[69]=a("a",{id:"SindbadData.loadDataFromPath-NTuple{4, Any}",href:"#SindbadData.loadDataFromPath-NTuple{4, Any}"},[a("span",{class:"jlbinding"},"SindbadData.loadDataFromPath")],-1)),i[70]||(i[70]=e()),n(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[71]||(i[71]=s('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">loadDataFromPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nc, data_path, data_path_v, source_variable)</span></span></code></pre></div><p>Load data from specified NetCDF paths using given parameters.</p><p><strong>Arguments</strong></p><ul><li><p><code>nc</code>: NetCDF file handle</p></li><li><p><code>data_path</code>: Path to the main data in NetCDF file</p></li><li><p><code>data_path_v</code>: Path to the variable data in NetCDF file</p></li><li><p><code>source_variable</code>: Name of the source variable to load</p></li></ul><p><strong>Returns</strong></p><p>Data loaded from the specified paths in the NetCDF file.</p>',6))])])}const z=l(r,[["render",V]]);export{X as __pageData,z as default};
